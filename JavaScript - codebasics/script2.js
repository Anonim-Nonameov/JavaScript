// Создание (определение) функции

// Определние собственных функций значительно упрощает написание и поддержку программ.
// Функции позволяют объединять сложные (составные) операции в одну.
// Например, отправка письма на сайте - это достаточно сложный процесс, включащий
// в себя взаимодействие с внешними системами (интернет). Благодаря возможности
// определять функции, вся сложность может быть скрыта за простой функцией:

/*

import { send } from 'some-email-package';

const email = 'support@hexlet.io';
const title = 'Помогите';
const body = 'Я написал историю успеха, как я могу получить скидку?';

// Один маленький вызов — и много логики внутри
send(email, title, body);

*/

// P.S - Было взято с Hexlet.

// Создадим нашшу первую функцию. Её задача - выводить на экран следующий текст:
// Today is: December 5

const showCurrentDay = () => {
    const text =  'Today is: December 5'
    console.log(text)
}

// Вызов функции =>
showCurrentDay();
// => Today is: December 5

// P.S:
// Такая функция в JavaScript называется стрелочной. Она появилась со стандартом языка ES6.

// Определение не вызывает и не выполняет функцию. Мы лишь говорим, что теперь такая
// функция есть, она была создана.

// Определение функции выше состоит из двух частей:
// 1) Присваивание функции константе
// 2) Непосредственно определение функции

// Само по себе определение функции - это всё, что находится после присвоения:

/*

Обратите внимание на стиль
Пробелы между символами
Открывающая фигурная скобка в конце той же строчки, где стрелка
Закрывающая - на своей отдельной строчке в конце

() => {
  const text = 'Today is: December 5';
  console.log(text);
};

*/

// Такое определение создает функцию, но не вызывает её.
// Поскольку это определение не связывается ни с каким именем (константой),
// то такой код - абсолютно бесполезен, хоть и является синтаксически корректным.

// Связывание функции с именем является обычным присваиванием.
// В этом смысле функции ведут себя как обычные данные, которые можно
// записывать в константы. Технически функцию можно присвоить и переменной,
// но т.к функции неизменяемы - то смысла в этом нет.

// const doSomething = (определение любой функции)

// В отличие от обычных данных, функции выполняют действия, поэтому их имена
// практически всегда должны быть глаголами: "построить что-то", " нарисовать что-то" и т.д.

// Всё, что описывается внутри фигурных скобок {}, называется телом функции.
// Внутри тела можно описывать любой код.
// Можно так же считать, что это маленькая самостоятельная программа, набор
// инструкций. Тело выполняется только в тот момент, когда вызывается
// (запускается) функция. Причём каждый вызов функции запускает тело
// внезависимости от других вызовов.

// Кстати, тело может быть пустым :D =>

/*

const noop = () => {};

noop(); - вызов есть, а смысла? а смысла то и нет.

*/

// Понятие "создать функцию"  имеет много синонимов:
// "Реализовать"
// "Определить"
// "Заимплементить" (от слова implement).

// Задача из урока:

/*

Текст задачи, задача:

Реализуйте функцию printMotto(), которая печатает на экран фразу "Winter is coming."

Решение:

const printMotto = () => {
  let text = 'Winter is coming'
  console.log(text)
}

*/

// Передача одного аргумента

// Функции без аргументов встречаются крайне редко. Чаще всего, функции
// принимают на вход данные, как-то их используют и выдают результат.
// Посмотрим на определение ниже:

const showAnotherDay = (text) => {
  console.log(`Today is: ${text}`);
}

showAnotherDay('January 29');
// => Today is: January 29

// Теперь то понятно, зачем нужны были круглые скобки после имени функции:
// в них можно указать аргумента (или, что то же самое, параметры).
// Технически, параметры функции всегда являются переменными, а не
// константами (а если подумать, то ведь правда - параметры можно в
// любой момент изменить!). Но лучше относиться к ним как к константам.

// Посмотрев внимательно, можно заметить что мы не объявляем (ну или
// определяем, кто как называет) переменную text, но используем её в теле
// функции.
// JS работает так: переменная сама создаётся при вызове, и указанное
// значение (у нас это было - 'January 29') записывается в эту переменную.

// Аргументы можно называть как угодно, их имена имеют смысл
// исключительно в теле функции.
// Например, если изменить имя аргумента так:

const showCurrentDate = (OhLala) => {
  console.log(`Today is: ${OhLala}`);
}

let date = 'January 29'
showCurrentDate(date);
// => Today is: January 29

// - то поведение функции не изменится. Это касается как имен внутри
// функции (OhLala), так и снаружи (date).

// Новички пытаются сделать примерно такое определение функции:

/*
const showCurrentDate = ('Today is: December 5) {
  (код)
}
*/

// - запустить такой код не получится. Он синтаксически неверен. Как
// вместо переменной, куда записывается значение - может стоять строка?

// Аргумент должен быть переменной, иначе он не сможет быть аргументом,
// то есть чем то, что принимает в себя значение при вызове.

// Если нам нужна какая-то информация в функции, и мы заранее знаем
// какая именно, то аргумент для этого не нужен, ведь мы уже умеем
// сохранять значения для последующего использования - достаточно
// создать переменную (или константу) в самом теле:

/*

const showCurrentDate = () => {
  const text = 'Today is: December 5';

  (какой-то там код)
  (какой-то там код)
  (какой-то там код)
}

*/

// Задача из урока:

/*

Текст задачи, задача:

Реализуйте функцию printJaimesLine(), которая принимает один аргумент — строку,
и выводит реплику на экран в формате - JAIME: переданная_строка.

Примечания:

Как назвать переменную, которая будет аргументом - решайте сами.


P.S (from Hexlet.io):

"Вам не нужно самостоятельно вызывать функцию, только определить её. 
Но для наглядности — вот как наша система вызывает её:

printJaimesLine('Farewell, my friend...');"

Решение:

const printJaimesLine = (replica) => {
  console.log(`JAIME: ${replica}`);
}

*/