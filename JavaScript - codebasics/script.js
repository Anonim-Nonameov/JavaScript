console.log("\"Khal Drogo\'s favorite word is \"athjahakar\"\"");
// символы \" и \' создадут в строке кавычки.

console.log((5 ** 2 ) - (7 * 3)) // => 4.
// Программа выводит в консоль выражение "разница пяти в квадрате и семи
// умноженного на три" несмотря на то, что выражения находятся в скобках.
// Компьютер сначала считает то, что находится в скобках, а затем
// уже что идёт после них.

console.log(2 + 2 * 3);

// Будет выведено 8, потому что компьютер сначала выполняет умножение а затем
// уже сложение и вычитание, и всё было сложено вот так - 2 * 3 + 2.

// Нас учат в школе понятию приоритета операции, так вот - компьютер считает
// точно также, следуя приоритетам в операциях, например - 2 + 16 / 2 + 3 ** 2.

// Сначала вычислится возведение в степень, затем деление, затем сложение - 3 **
// 2 + 16 / 2 + 2 => 19.

// Но иногда можно (и даже нужно) ставить скобки, вот так - (3 ** 2) +(16 / 2) +
// 2.

// Скобки можно ставить вокруг любой операции, неважно сколько раз. Вот пара
// примеров -

console.log(3 ** (4 - 2));
// Ответ = 9.

console.log(7 * 3 + (4 / 2) - (8 + (2 - 1)));
// Ответ = 14.

console.log(3 ** (1 + 1) + (8 + (2 + 2)) + 2);
// Ответ = 23.

// При этом надо соблюдать парность, т.е - закрывать скобки в правильном
// порядке.

console.log("- Сколько будет 5 минус 7?\n- -2!");
// \n - символ переноса строки. Тут, после знака "?" будет перенос строки.

// Конкатенация

console.log('Мяу ' + 'Гав');
console.log('Winter ' + 'came ' + 'for ' + 'the ' + 'House ' + 'of ' + 'Frey.');

let who = "dragon's" + 'mother';
console.log(who);
// Конкатенация - слияние строк при помощи оператора +.

// Важно отметить, что пробел послеа слова "мяу" в 1-ой строке будет также
// выведен в консоли, ведь пробел - такой же символ как и буквы. Чем больше
// пробелов - тем шире отступы.

// В противном случае, всё будет выведено без пробела - МяуГав.

console.log('-Did Joffrey agree?\n-He did. He also said \"I love use \\n\"');
/*
 Вывод -
-Did Joffrey agree?
-He did. He also said "I love use \n"

Экранирующая последовательность - специальная комбинация символов в тексте.
Например, \n — это перевод строки,
 \' -одинарная кавычка, \" - двойная.
*/

/* 
Переменные

Переменная в JS нужна для хранения данных, как и в других языках
программирования.

Переменную объявляют кл. словом let, или же устаревшим var.

Чтобы задать ей значение, нужно использовать оператор присвоения, он же =. Это
не знак равенства, а именно что оператор! их НЕЛЬЗЯ путать.

Значение переменной может быть любым, будь то строка, число или выражение. Чтобы
присвоить ей значение, необходимо прописать let (название переменной) =
(значение);

Пример - let pet = 'Cat';

Имя переменной НЕ должно начинаться с цифры, или содержать в себе тире -, однако
допустимо использовать знак нижнего подчёркивания _ и знак доллара $
(не рекомендуется, потому что он используется компилятором внутренне).

Примеры - let my_pet = 'cat'; 
let Annas_pet = 'dog';
let $price = 30;

Переменную возможно изменять: let a = 'b'; a = "c"; => теперь значение
переменной 'c'.

Констана

Константа - переменная которую нельзя менять, абсолютно. В коде она задётся лишь
1 раз, и всё. Т.е - у неё фикс. значение. Объявить её можно кл. словом const -
const a = 'a';

При этом, имя константы необходимо выбирать правильно, потому что в JS есть УЖЕ
объявленные переменные.

*/

let eurosCount = 100;

let dollarsPerEuro = 1.25;
let rublesPerDollar = 60;

let dollarsCount = eurosCount * dollarsPerEuro
let rublesCount = dollarsCount * rublesPerDollar;

console.log(dollarsCount);
console.log(rublesCount);

/*
Программа берет кол-во евро записанное в переменную eurosCount, затем
пересчитывает евро в доллары, а полученные доллары - в рубли.

Кол-во евро = 100. (eurosCount) 
1 евро - 1.25 долларов (dollarsPerEuro)
1 доллар - 60 рублей (rublesPerDollar)

Простыми словами - 100 * 1.25 = 125 125 * 60 = 7500
*/

// Укороченная версия программы

/*

let dollarsCount = 100 * 1.25, rublesCount = dollarsCount * 60;

console.log(dollarsCount); => 125 console.log(rublesCount); => 7500

Так более кратко, но непонятно. Например - что это за число - 1.25? за что
отвечает 60? что делает 100?

Лучше использовать первый вариант программы, он более читабельный и понятный.

*/

// А вот и третья версия программы, но уже сделанная с константами!

const euros = 1000;

const dollarsInEuro = 1.25;
const rublesInDollar = 60;

const dollars = euros * dollarsInEuro;    // 1250
const rubles = dollars * rublesInDollar; // 75000

console.log(rubles);

// Переменные & конкатенация 

let info = "We couldn't verify you mother's maiden name.";
let intro = 'Here is important information about your account security.';

let firstNameLet = 'Joffrey';
let greetingLet = 'Hello';

console.log(greetingLet + ', ' + firstNameLet + '!'); 
console.log(intro + '\n' + info);


// Программа генерирует заголовок и тело письма используя готовые переменные,
// выводя получившийся текст в консоль.

// Заголовок - greeting & firstName 
// Тело - info & intro.

// Вывод ==>

// Hello, Joffrey! Here is important information about your account security. We
// couldn't verify you mother's maiden name.

// Имена переменных

// gretting - самое обычное название переменной, но не все переменные такие.
// Большинство программистов делает их названия составными (т.е они состоят из
// неск. слов), пример ==> user_name

// В именовании переменных есть разные подходы, стандарты написания переменной ==>

// kebab-case => составные части разделены дефисом

// Пример ==> my-super-puper-var

// snakecase => составные части разделены ниж. подчеркиванием

// Пример ==> my_super_puper_var

// CamelCase => каждое слово в перем. пишется с заглавной буквы

// Пример ==> MySuperPuperVar

// lowerCamelCase => каждое слово в перем. кроме первого пишется с заглавной буквы

// Пример ==> mySuperPuperVar

// В JavaScript обычно используют CamelCase и его вариацию lowerCamelCase.

// Интерполяция

// Прошлую задачу можно решить иначе, не писать длинный код:
// console.log(greeting + ', ' + firstName + '!');

// Можно решить эту задачу при помощи ИНТЕРПОЛЯЦИИ.

const firstName = 'Joffrey';
const greeting = 'Hello';

console.log(`${greeting}, ${firstName}!`);

// Мы создали строку и вставили туда значения константы с
// помощью знака доллара и фигурных скобок - ${}
// Получился бланк, куда мы занесли нужные значения без
// использования строк для каких-то знаков - они были просто
// записаны в одной строке.

// Интерполяция работает только в БЭКТИКАХ, символ ``.
// Практически во всех языках интерполяция предпочтительнее
// конкатенации для склеивания строк. Строка
// склееная, и внутри неё хорошо видны другие символы.
// Во первых, интерполяция позволяет не путать строки и числа
// из-за знака +, а во вторых, так проще понимать строку целиком (
// после практики, конечно).

// Извлечение символов из строки

// Бывает так, что нужно получить один символ из строки.
// Например, если сайт знает имя и фамилию человека, и нужно
// вывести эту информацию в формате А. Иванов.

const userName = 'Alex';
console.log(userName[3]); // ==> X

// Квадратные скобки с цифрой внутри - спец. синтаксис
// извлечения символа из строки.
// Цифра - ИНДЕКС, позиция символа в строке.
// Индексы начинаются с нуля почти во всех языках программирования.
// Поэтому - чтобы получить первый символ, надо указать индекс ноль.

// Индекс последнего элемента равен длине строки и -1 единица.
// Т.е - если мы хотим вывести последний символ в слове Alex - пишем 3.

// Индексом может быть не только число, но и значение переменной.
// Например:

const variableForIndex = 0;
console.log(userName[variableForIndex]); // ==> A

// Значение переменной variableForIndex - 0, и мы
// замесь конкретного числа в индексе записали переменную. 

// В слове Alex индексы от 0 до 3 -
// A - 0
// l - 1
// e - 2
// x - 3

// Но если мы запишем в индексе цифру 4 - консоль выдаст undefined.
// Почему? потому что такого индекса просто нет.

const nameEx = 'Na\nharis';
console.log(nameEx[7]);

// ПРИМЕЧАНИЕ: символы, такие как \n - тоже
// индексируются, т.к они тоже символы.

// Типы данных

// Если мы попробуем умножить число на строку,
// JS выдаст NaN (не число) - знакомое нам значение.
// Оно возникает там, где вместе используются несовмес -
// - тимые значения. Например число и строка -

console.log(3 * 'Dracarys'); // => NaN

// Внутри высокоуровневых языков программирования данные
// разделяются по типам.
// Например - строка к типу String, а числа -
// к типу Number или Bigint (ооочень большие числа).
// Они (типы) нужные для того что защищать
// программу от ошибок.

// Типы определяют две вещи:
// 1) Возможные или допустимые значения.
// Например, числа в JS делятся на 2 типа -
// Number & Bigint.
// Первый тип (Number) - это все числа
// ниже определенного порога (который, кстати, можно посмотреть).
// Второй (Bigint) - выше этого же порога.

// 2) Набор операций выполняемые над этим типом.
// Например, операция умножения имеет смысл для типа
// Number, но не имеет смысла для String.
// Сами подумайте, умножать строку на число - бессмыслица.

// JS может ругаться на недопустимость операции, а может и
// продолжить работу и вывести NaN.

// JS понимает что за тип данных перед ним
// благодаря тому, что любое значение всегда где-то инициализируется
// и, в зависимости от инициализации становится понятно, что же перед нами.
// К примеру, числа - это просто числа без дополнительных символов,
// кроме точки для рациональных чисел.
// А вот строки всегда ограничены спец. символами (в JS 3 варианта),
// например: '234' - строка, хоть внутри нее записаны цифры.

// В JS можно узнать тип данных при помощи оператора typeof:
console.log(typeof 3); // => Number
console.log(typeof 'Text') // => String

// Типы данных Number, Bigint & Number - примитивные, простые
// типы, они встроены в сам язык. Помимо них, есть ещё несколько
// примитивных типов данных - например: Boolean.
// В JS встроен так же составной (надор данных) тип Object (
// а на его базе массивы, даты & другие).

// На английском строки в программировании называются Strings,
// а строчки текстовых файлов - Lines.
// Например, в коде выше - есть 2 строчки (lines), но только
// 1 строка (string).

// JS - Undefined

// Можно объявить переменную можно и без указания значения.
// Если вывести её на экран, будет выдано значение Undefined.
// Undefined означает "не определено", поэтому то нам и будет
// выводить значение "Undefined", если мы захотим вывести на экран
// не заданное значение переменной.

// JS - один из немногих языков где есть такое понятие как
// undefined, в других языках его заменяет тип null (который есть и в JS).

// И да - нельзя объявлять константу без присваивания значения.
// Почему? потому что если мы её объявим но не укажем значение -
// то как же мы нашу константу изменим? это не только
// синтаксическая ошибка, но и бессмыслица.

// Пример использования интерполяции с индексами
let one = 'Dracario';
let two = 'Emirio';
let three = 'Sevilio';

console.log(`${one[3]}${one[2]}${two[3]}${three[4]}`);
// Вывод => carl

// Примечание: интерполяцию можно использовать и с
// техникой индексации, и это порой упрощает работу.

// Невозможно изменить примитивный тип данных

// Если попытаться изменить символ в строке, 
// то код выполнится без ошибок:

firstName[0] = 'B'
console.log(firstName);
// Вывод => Joffrey

// Такое происходит из-за того, что изменить
// примитивный тип в JS - невозможно.
// Нет никакой физической возможности поменять строку.
// Невозможность, неизменяемость примитивных типов
// важна по многим причинам, ключевая из них - производительность.
// Если же мы действительно хотим её изменить - используем переменные:

let firstNameV2 = 'Alexander'
firstNameV2 = 'Blexander'
console.log(firstNameV2);
// Вывод => Blexander

// Есть огромная разница между изменением значения
// переменной и изменением самого значения.
// Примитивные типы изменять в JS нельзя.

// Слабая типизация.

// Известно два типа данных: числа и строки.
// Мы можем складывать числа, потому что
// операция сложения - для типа числа.

// А что если мы применим эту операцию не к двум
// числам а, например, к числу и строке?

console.log(1 + '7'); 
// Вывод => '17'

// Несмотря на то, что '7' - строка а не число,
// интерпретатор JS выдал нам 17, как если бы
// мы складывали две строки.

// Когда JS видит несоответствие типов, он сам
// пытается преобразовать информацию.
// В данном случае он преобразовал число
// 1 в строку ('1'), а потом сделал конкатенацию '1' и '7'.

// Но так поступают не все языки. JS - язык со
// СЛАБОЙ ТИПИЗАЦИЕЙ. Он знает о существовании 
// разных типов (такие как числа, строки и т.д),
// но относится к их использованию не очень
// строго, пытаясь преобразовывать информацию
// когда это кажется разумным.

// Иногда JS доходит до крайностей. Большинство
// выражений не работающих в других языках работают
// в JS. Если попробовать выполнить любую арифм.
// операцию (кроме сложения) подставив туда
// строки или другие типы данных (кроме
// ситуации, когда оба операнда это числа или строки,
// содержащие только число) - выдаст NaN
// и продолжит работу.

console.log('one' * 'two');
// Вывод => NaN

// В языках со строгой типизацией сложить число со
// строкой не получится.

// Функции и их вызов.

/*
Сложение, конкатенация, нахождение
остатка от деления и т.д - базовые возможности
языков программирования.
Математика не ограничена арифметикой,
кроме нее есть и множество других разделов
со своими операциями, например, геометрия.
То же самое касается и строк: их можно
переворачивать, менять регистр букв, удалять 
лишние символы - и это только самое простое.

И, наконец, на более высоком уровне есть 
прикладная логика конкретного приложения.
Программы списывают деньги, считают налоги,
формируют отчеты.
Кол-во подобных операций бексонечно и
индивидуально для каждой программы, и все
они как-то выражены в коде.

Для выражения любой произвольной
операции в коде существует такое понятие как "функция".
Функции бывают встроенные и добавленные программистом.
Пример встроенной функции, с которой мы знакомы -
log() в вызове console.log();

Функции - одна из важнейших конструкций
в программировании, без них невозможно
сделать практически ничего.
*/

// const result = reverse('Hello!')
// console.log(result);
// Вывод => !olleH

// Прим. - такой функции как reverse
// у меня нет, она используется на курсе по JS 
// на hexlet.com.

// В нашем примере - мы создали константу result и указали
// интерпретатору записать в неё результат,
// возвращаемый функцией reverse() при её вызове.
// В этом смысле функции подобны операциям -
// они всегда возвращают результат своей
// работы. Запись reverse('Hello!');
// означает, что вызывается функция с именем
// reverse, в которую был передан аргумент (
// он же параметр) 'Hello!'.

// Аргументы нужны функциям для работы так же, как операторам
// нужны операнды. Функция reverse() переворачивает
// именно ту строку, которая передается ей в аргументах.

// Вызов функции обозначается скобками (),
// которые идут сразу после названия функции
// В скобках может быть любое кол-во аргументов,
// а может быть вообще ни одного.

// Кол-во зависит от используемой функции,
// например, функция pow() принимает на вход ДВА аргум.
// и возводит число, переданное первым аргументом,
// в степень, переданную вторым аргументом:

const resultTwo = Math.pow(2,3);
// 2 * 2 * 2

console.log(resultTwo);
// Вывод => 8.

// Можно сказать, что  операторы и функции - одно
// и то же. Разница лишь в том, как они записываются.
// Представляя сложение как функцию, то она будет
// выглядеть вот так -

console.log(3 + 5);
// Наше обычное представление, вывод => 8

// const sumFoo = sum(3,5)
// console.log(sumFoo);
// В виде функции. В первом аргументе первое слогаемое,
// а во втором - второе. Выводится будет 8.

// Задача из курса:

/* 
В 7 королевствах жил один человек, Сэм Тарли, картограф.
Он имел доступ к компьютерам и умел программировать, поэтому написал для
себя функцию calculateDistance().
Функция высчитывает расстояние между городами в лигах.
Она принимает два строковых аргумента (названия городов) и возвращает
число (расстояние) между ними.

Задача:

Использовать функцию calculateDistance() и вывести на экран расстояние
между городами Qarth и Vaes Dothrak.

Моё решение:

const distanceBetweenCity = calculateDistance('Qarth', 'Vaes Dothrak');
console.log(distanceBetweenCity);
Вывод => 125, задача выполнена.
*/

// Итог:
// Функция это операция, способная принимать результат;
// функция называется так: foo().

// Аргумент - информация, которую функция получает при вызове.
// Например , foo(40) - передача аргумента 40 функции foo()

// В JS  математические функции вызываются через объект (технически это объект)
// (ну, о объектах позже) Math.
// Достаточно знать, что эти функции (такие как pow) вызываются
// через объект Math.

// В JS есть функция Math.abs(), она способна возвращает
// модуль переданного числа:

console.log(Math.abs(-93));
// Вывод => 93

// Допустим, нам необходимо рассчитать кол-во вражеских солдат,
// и мы создали константу soldiersCount со неким значением (у нас это
// должно быть 2309).
// Но мы перепутали знаки операций и получилось -2309,
// и чтобы найти модуль этого числа необходимо использовать функцию abs():

const soldiersCount = -2309;
console.log(Math.abs(soldiersCount));
// Вывод => 2309

// Вернемся к Math.pow() (Math - объект о котором мы пока что
// ничего не знаем, а функция pow - возводит число в какую-нибудь степень,
// принимая два параметра: какое число возводить и в какую степень).
// Если вызывать эту функцию без параметров - вернется NaN.
// Функция пытается выполнить возведение в степень, но если значение
// не передано - интерпретатор автоматом передает ей значение undefined.
// В большинстве языков, если передать в функцию меньше параметров
// чем она ожидает - то возникнет ошибка... но только не в JS.
// NaN вернется и при передаче любых не числовых значений:

const result = Math.pow (2, 'boom')
console.log(result);

// Другая функция может иметь другое число параметров и другие
// типы параметров. Например, может существовать функция, которая
// принимает три параметра: число, строку, и ещё одно число.

// Откуда мы знаем, сколько каких параметров нужно функции
// Math.pow() и какого типа будет "возврат"?
// Мы смотрим в СИГНАТУРУ этой функции.
// Сигнатура определяет входные параметры и их типы, а
// также выходной параметр и его тип.

// Про функцию Math.pow() можно почитать в документации MDN.
// В разделе синтаксис есть вот такой текст:

/*
Math.pow(base, exponent)
 Параметры
base
 Основание степени.

exponent
 Показатель степени, в которую возводится основание.
*/

// Это сигнатура функции и короткое пояснение на Русском языке.
// Документация позволяет нам понять, сколько аргументов у функции
// и какого они типа (строки, числа и т.д), возвращает ли что-то
// функция и если да, то какого типа возвращаемое значение.

// Ещё есть функция Math.ceil() - она округляет до ближайшего большего целого.
// Синтаксис: Math.ceil(x) - x это число.

const num = 923.2238
console.log(Math.ceil(num));
// Вывод => 924

// Аргументы по умолчанию

// Есть такая функция, round() (ПРИМЕЧАНИЕ - 
// она используется на курсе JS от hexlet).
// Она округляет переданное число, пример:

// const result = round(10.25, 0)
// Вывод => 10

// Мы передали в неё два аргумента:
// число и точность округления. 0 означает, что округление будет до целого значения.
// то есть дробная часть будет отбрасываться.

// Часто бывает так, что нужно округлять именно до целого числа, поэтому
// создатели функции round() сделали второй аргумент НЕОБЯЗАТЕЛЬНЫМ и задали ему
// внутри функции ЗНАЧЕНИЕ ПО УМОЛЧАНИЮ 0.
// Значит, можно не указывать второй аргумент, а результат будет тем же:

// const result = round(10.25);L
// Вывод => 10

// а если нужна другая точность, передаём аргумент:

// const result = round(10.25, 1);
// Вывод => 10.3

// Если функция в JS принимает необязательные аргументы, то они всегда стоят после
// обязательных. Их кол-во может быть абсолютно любым (ну а это уже зависит от
// функции), но они всегда идут рядом и в конце списка аргументов.

// Функции с переменным число параметров (аругментов)

// Некоторые функции способны принимать переменное число аргументов, и речь не
// о значениях по умолчанию. Например:

// Math.max(1, 10, 3)
// Вывод => 10

// Функция Math.max() находит максимальное значение среди переданных
// аргументов. Она может принять любое кол-во аргументов, а в документации
// про неё написано вот это:

/*

Math.max([value1[, value2[, ...]]]);

*/

// Эта запись говорит о том, что эта функция принимает на вход любое
// кол-во аргументов (и даже может быть без аргументов). Необязательность
// передаваемых аргументов обозначается скобками [], точно так же обозначаются
// опциональные параметры, у которых есть значения по умолчанию
// А возможность передачи любого кол-ва аргументов зашита в части [, ...].

console.log(Math.max(1, -3 , 2, 3, 2));
// Вывод => 3

// И функция Math.min(). Она максимально похожа на Math.max(), но только действует наоборот.
// Т.е - она находит минимальное значение среди переданных аргументов.

console.log(Math.min(1, 4, 2, 8, -7));
// Вывод => -7

// Вызов функции

// Выражение это код который при выполнении программы вычисляется в значение.
// Все эти фрагменты кода являются выражениями:

/* 
42
10 * 45

'kings ' + 'road'
calculateDistance('Lannisport', 'Bayasabhad')
*/

// Числа и матем. операции - самые простые варианты.
// Выражение 42 вычислится в значение 42, выражение 10 * 45
// вычислится в значение 450.

// Конкатенация строк тоже выражение, которое вычислится
// в соответствующее значение (новую строку).

// Четвертый вариант тоже выражение.
// Мощность и гибкость JS во многом возможна благодаря тому, что ВЫЗОВ
// ФУНКЦИИ - ЭТО ВЫРАЖЕНИЕ.

// Посмотрим на пример:
// const distance = calculateDistance('Lannisport', 'Bayasabhad');

// В константу distance записывается результат вычисления выражения.
// В отличие от операций, таких как 10 + 12, где явно видно какое вычисление
// производится, в функциях само вычисление скрыто от нас, и мы видим
// только результат. Поэтому то мы и говорим, что функция "возвращает"
// значение. Можно применить эту терминологию и к обычным операциям.
// К примеру, можно сказать, что конкатенация двух строк возвращает новую строку.

// "Что является выражением, а что нет?" - кажется так, что это одна
// из скуучных деталей из учебника по программированию.. но это действительно
// важный вопрос. Всё, что работает как выражение, может быть использовано в других
// выражениях, а также во всех местах, где на вход ожидаются выражения.

// Распознавать выражения в коде - очень важный навык, который необходим
// программисту каждый день.

// Допустим, что у нас есть функция numberOfKnights(), которая принимает
// название замка в королевстве и возвращает количество рыцарей в этом замке.
// Зная, что вызов функции - выражение, можно сказать что такой код будет
// работать:

// const result = 4 + numberOfKnights('Winterfell');

// Почему? - потому, что сложение это выражение, а значит его операндами могут
// быть другие выражения: выражения 4 и выражения numberOfKnights('Winterfell').
// В итоге получится 4 + какое то число.
// А что это значит? значит, что и такой код будет работать:

// const result = numberOfKnights('Winterfell') + numberOfKnights('Oldtown');

// Здесь два разных вызова функций, но каждый вызов - выражение, поэтому
// в итоге получится сложение двух значений - двух чисел (кол-ва рыцарей замка
// Winterfell и кол-ва рыцарей замка Oldtown).

// Выражения могут комбинироваться друг с другом в самых причудливых формах.
// Программист умея распознавать выражения, сможет придумывать новые варианты использования
// даже никогда не видев их.