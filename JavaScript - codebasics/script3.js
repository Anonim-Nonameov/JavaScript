// Конструкция Switch

// Многие языки в дополнение к условной конструкции "if" включают в себя
// Switch. Это спецаилизированная версия if, созданная для некоторых особых ситуаций.
// Например, её имеет смысл использовать там, где есть цепочка if else с проверками
// на равенство. Например:

/*

if (status === 'processing') {
    // Делаем раз
} else if (status === 'paid') {
    // Делаем двас
} else if (status === 'new') {
    // Делаем трис
} else {
    // Делаем четырес
}

*/

// Эта составная проверка обладает одной отличительной чертой: каждая ветка
// здесь - это проверка значения переменной status. Switch позволяет записать
// этот код короче и выразительнее (насчет последнего - сомневаюсь, сомневаюсь..):

/*

switch (status) {
  case 'processing': // status == processing
    // Делаем раз
    break;
  case 'paid': // status == paid
    // Делаем два
    break;
  case 'new': // status == new
    // Делаем три
    break;
  default: // else
    // Делаем четыре
}

*/

// Свитч - довольно сложная (еще бы..) конструкция с точки зрения количества
// элементов, из которых она состоит:

// 1) Внешнее описание, в которое входит ключевое слово switch. Переменная,
// по значениям которой switch будет выбирать поведение. И фигурные скобки
// для вариантов поведения.

// 2) Конструкции case и default, внутри которых описывается поведение для
// разных значений рассматриваемой переменной. Каждый case соответствует if
// в примере выше. default - это особая ситуация, соответствующая ветке
// else в условных конструкциях. Как else, указывать default не обязательно.
// НО! - линтер будет всегда настойчиво его просить.

// 3) break. break нужен для предотвращения "проваливания". Если его не
// указать, то после выполнения нужного case выполнение перейдет к следующему
// case, и так либо до ближайшего break, либо до конца switch.
// Что значит "перейдет к следующему"? - представим ситуацию:
// Мы сели в автобус, едем.
// Но вдруг, водитель ПРОПУСТИЛ нашу остановку.
// То же самое и с "проваливанием" - интерпретатор найдет нужное значение,
// нужный case - но пропустит его и будет переходить так до сааамого конца.

// Фигурные скобки в switch не определяют блок кода,
// как это было в других местах. Внутри допустим только тот синтаксис,
// который показан выше. То есть там можно использовать case или default.
// А вот внутри каждого case (и default) ситуация другая. Здесь
// можно выполнять любой произвольный код:

/*

switch (count) {
    case 1:
        // Делаем что-то полезное
        break;
    case 2:
        // Делаем что-то полезное
        break;
    default:
        // Что-то делаем
}

*/

// Иногда результат, полученный внутри case, - это конец выполнения функции.
// содержащей switch. В таком случае его нужно как-то вернуть наружу.
// Для решения этой задачи есть два способа.

// Первый. Создать переменную ПЕРЕД switch, заполнить её в case и затем, в конце
// вернуть значение этой переменной наружу.

/*

(count) => {
  // Объявляем переменную
  let result;

  // Заполняем
  switch (count) {
    case 1:
      result = 'one';
      break;
    case 2:
      result = 'two';
      break;
    default:
      result = null;
  }

  // Возвращаем
  return result;
};

*/

// Второй способ проще и короче.
// Вместо создания переменной, case позволяет внутри себя делать обычный
// возврат из функции. А так как после return никакой код не выполняется,
// то мы можем избавиться от break:

/*

(count) => {
    switch(count) {
        case 1:
            return 'one';
        case 2:
            return 'two';
        default:
            return null;
    }
};

*/

// Switch хоть и встречается в коде, но технически всегда можно обойтись и без
// него, используя if и else. Ключевая польза при его использовании в том, что
// он лучше выражает намерение программиста, когда нужно проверять конкретные
// значения переменной. Хотя кода и стало физически чуть больше, читать его
// легче, в отличие от блоков else if.

// Задача из урока:

/*

Текст задачи, задача:

Реализуйте функцию getNumberExplanation(), которая принимает на вход число и
возвращает объяснение этого числа. Если для числа нет объяснения, то
возвращается null - (примеры вызова):

getNumberExplanation(8);   // null

=> Объяснения есть только для указанных ниже чисел

getNumberExplanation(666); // 'devil number'
getNumberExplanation(42);  // 'answer for everything'
getNumberExplanation(7);   // 'prime number'

Моё решение:

const getNumberExplanation = (num) => {
  switch (num) {
    case 666:
      return 'devil number'
    case 42:
      return 'answer for everything'
    case 7:
      return 'prime number'
    default:
      return null
  }
}

*/

// Цикл While

// «Программы, которые мы пишем, становятся всё сложнее и объемнее. Они всё
// еще очень далеки от реальных программ, где количество строк кода измеряется
// десятками и сотнями тысяч (а иногда и миллионами), но текущая сложность уже
// способна заставить напрячься людей без опыта. Начиная с этого урока, мы пере-
// ходим к одной из самый сложных базовых тем в программировании - циклам.»
// (C) - Hexlet

// Ну, насчет сложности - это правда.
// А мы продолжаем -

// Любые прикладные программмы служат очень прагматичным целям. Они помогают
// управлять сотрудниками, финансами, развлекают - в конце концов.
// Несмотря на различия, все эти прораммы выполняют заложенные в них алгоритмы,
// которые очень похожи между собой. Но что это такое, алогритм? Алгоритм - 
// это последовательность действий (инструкций) которая приводит нас к некоему
// ожидаемому результату.
// В принципе, это описание подходит под любую программу, но под алгоритмами
// обычно понимается что-то более специфичное.

// Представьте себе, что у нас есть книга и мы хотим найти внутри неё какую-то
// конкретную фразу.
// Саму фразу мы помним, но не знаем, на какой она странице. Как найти нужную
// страницу? самый простой (и дооолгий) способ - последовательно просматривать
// страницы до тех пор, пока мы не найдем нужную.
// В худшем случае придется просмотреть все страницы, но результат мы всё
// равно получим (но шанс того что мы пропустим нужную нам фразу - крайне велик).
// Именно этот процесс и называется алгоритмом. Он включает в себя логические
// проверки (нашли ли фразу) и перебор страницы.
// Количество страниц, которое придется посмотреть, заранее неизвестно, но сам
// процесс повторяется из раза в раз совершенно одинаковым образом.
// Для выполнения повторяющихся действий как раз и нужны циклы.
// Каждый повтор, в таком случае, называется итерацией (кто немного разбирается в
// процессорах - тот поймет). 

// А я допишу позже, время вышло.