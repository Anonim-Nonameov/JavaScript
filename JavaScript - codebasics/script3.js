// Конструкция Switch

// Многие языки в дополнение к условной конструкции "if" включают в себя
// Switch. Это спецаилизированная версия if, созданная для некоторых особых ситуаций.
// Например, её имеет смысл использовать там, где есть цепочка if else с проверками
// на равенство. Например:

/*

if (status === 'processing') {
    // Делаем раз
} else if (status === 'paid') {
    // Делаем двас
} else if (status === 'new') {
    // Делаем трис
} else {
    // Делаем четырес
}

*/

// Эта составная проверка обладает одной отличительной чертой: каждая ветка
// здесь - это проверка значения переменной status. Switch позволяет записать
// этот код короче и выразительнее (насчет последнего - сомневаюсь, сомневаюсь..):

/*

switch (status) {
  case 'processing': // status == processing
    // Делаем раз
    break;
  case 'paid': // status == paid
    // Делаем два
    break;
  case 'new': // status == new
    // Делаем три
    break;
  default: // else
    // Делаем четыре
}

*/

// Свитч - довольно сложная (еще бы..) конструкция с точки зрения количества
// элементов, из которых она состоит:

// 1) Внешнее описание, в которое входит ключевое слово switch. Переменная,
// по значениям которой switch будет выбирать поведение. И фигурные скобки
// для вариантов поведения.

// 2) Конструкции case и default, внутри которых описывается поведение для
// разных значений рассматриваемой переменной. Каждый case соответствует if
// в примере выше. default - это особая ситуация, соответствующая ветке
// else в условных конструкциях. Как else, указывать default не обязательно.
// НО! - линтер будет всегда настойчиво его просить.

// 3) break. break нужен для предотвращения "проваливания". Если его не
// указать, то после выполнения нужного case выполнение перейдет к следующему
// case, и так либо до ближайшего break, либо до конца switch.
// Что значит "перейдет к следующему"? - представим ситуацию:
// Мы сели в автобус, едем.
// Но вдруг, водитель ПРОПУСТИЛ нашу остановку.
// То же самое и с "проваливанием" - интерпретатор найдет нужное значение,
// нужный case - но пропустит его и будет переходить так до сааамого конца.

// Фигурные скобки в switch не определяют блок кода,
// как это было в других местах. Внутри допустим только тот синтаксис,
// который показан выше. То есть там можно использовать case или default.
// А вот внутри каждого case (и default) ситуация другая. Здесь
// можно выполнять любой произвольный код:

/*

switch (count) {
    case 1:
        // Делаем что-то полезное
        break;
    case 2:
        // Делаем что-то полезное
        break;
    default:
        // Что-то делаем
}

*/

// Иногда результат, полученный внутри case, - это конец выполнения функции.
// содержащей switch. В таком случае его нужно как-то вернуть наружу.
// Для решения этой задачи есть два способа.

// Первый. Создать переменную ПЕРЕД switch, заполнить её в case и затем, в конце
// вернуть значение этой переменной наружу.

/*

(count) => {
  // Объявляем переменную
  let result;

  // Заполняем
  switch (count) {
    case 1:
      result = 'one';
      break;
    case 2:
      result = 'two';
      break;
    default:
      result = null;
  }

  // Возвращаем
  return result;
};

*/

// Второй способ проще и короче.
// Вместо создания переменной, case позволяет внутри себя делать обычный
// возврат из функции. А так как после return никакой код не выполняется,
// то мы можем избавиться от break:

/*

(count) => {
    switch(count) {
        case 1:
            return 'one';
        case 2:
            return 'two';
        default:
            return null;
    }
};

*/

// Switch хоть и встречается в коде, но технически всегда можно обойтись и без
// него, используя if и else. Ключевая польза при его использовании в том, что
// он лучше выражает намерение программиста, когда нужно проверять конкретные
// значения переменной. Хотя кода и стало физически чуть больше, читать его
// легче, в отличие от блоков else if.

// Задача из урока:

/*

Текст задачи, задача:

Реализуйте функцию getNumberExplanation(), которая принимает на вход число и
возвращает объяснение этого числа. Если для числа нет объяснения, то
возвращается null - (примеры вызова):

getNumberExplanation(8);   // null

=> Объяснения есть только для указанных ниже чисел

getNumberExplanation(666); // 'devil number'
getNumberExplanation(42);  // 'answer for everything'
getNumberExplanation(7);   // 'prime number'

Моё решение:

const getNumberExplanation = (num) => {
  switch (num) {
    case 666:
      return 'devil number'
    case 42:
      return 'answer for everything'
    case 7:
      return 'prime number'
    default:
      return null
  }
}

*/

// Цикл While

// «Программы, которые мы пишем, становятся всё сложнее и объемнее. Они всё
// еще очень далеки от реальных программ, где количество строк кода измеряется
// десятками и сотнями тысяч (а иногда и миллионами), но текущая сложность уже
// способна заставить напрячься людей без опыта. Начиная с этого урока, мы пере-
// ходим к одной из самый сложных базовых тем в программировании - циклам.»
// (C) - Hexlet

// Ну, насчет сложности - это правда.
// А мы продолжаем -

// Любые прикладные программмы служат очень прагматичным целям. Они помогают
// управлять сотрудниками, финансами, развлекают - в конце концов.
// Несмотря на различия, все эти прораммы выполняют заложенные в них алгоритмы,
// которые очень похожи между собой. Но что это такое, алогритм? Алгоритм - 
// это последовательность действий (инструкций) которая приводит нас к некоему
// ожидаемому результату.
// В принципе, это описание подходит под любую программу, но под алгоритмами
// обычно понимается что-то более специфичное.

// Представьте себе, что у нас есть книга и мы хотим найти внутри неё какую-то
// конкретную фразу.
// Саму фразу мы помним, но не знаем, на какой она странице. Как найти нужную
// страницу? самый простой (и дооолгий) способ - последовательно просматривать
// страницы до тех пор, пока мы не найдем нужную.
// В худшем случае придется просмотреть все страницы, но результат мы всё
// равно получим (но шанс того что мы пропустим нужную нам фразу - крайне велик).
// Именно этот процесс и называется алгоритмом. Он включает в себя логические
// проверки (нашли ли фразу) и перебор страницы.
// Количество страниц, которое придется посмотреть, заранее неизвестно, но сам
// процесс повторяется из раза в раз совершенно одинаковым образом.
// Для выполнения повторяющихся действий как раз и нужны циклы.
// Каждый повтор, в таком случае, называется итерацией (кто немного разбирается в
// процессорах - тот поймет). 

// Допустим, мы хотим написать функцию, которая выводит на экран все числа
// от одного до указанного (через аргументы):

/*

printNumbers(3)

=> 1
=> 2
=> 3

*/

// Мы не сможем реализовать эту функцию, применяя ранее изученные функции/свойства
// и т.д, так как количество выводов на экран заранее НЕИЗВЕСТНО. А с циклами
// то не составит никаких проблем:

const printNumbers = (lastNum) => {
  let i = 1
  // i - сокращение от "index" (порядковый номер)
  // Используется по общему соглашению во множестве языков
  // как счетчик цикла
  
  while(i <= lastNum) {
    console.log(i)
    i++ // можно через i = i + 1
  }
  console.log('Finished!')
} 

console.log( )
printNumbers(3) // => 1, 2, 3, 'Finished!'

// В коде функции использован цкил while.
// Он состоит из трёх элементов:

/*

--Ключевое слово while. Несмотря на схожесть с вызовом функции,
это не вызов функции.

----Предикат. Условие, которое указывается в скобках после while. Это условие
вычисляется на каждой итерации.

------Тело цикла. Блок кода в фигурных скобках. Этот блок аналогичен блоку кода
в функциях. Всё, что определено внутри этого блока (константы или переменные),
видно только внутри этого блока.

*/

// Конструкция читается так:
// «Делать то, что указано в теле цикла, пока истинно условие (предикат)
// "i <= lastNum" (i меньше или равен lastNum)».
// Разберем работу этого кода для вызова printNumbers(3):

/*

--Инициализируется переменная i -
let i =  (на этом этапе i равна 1)

--Предикат возвращает true, поэтому выполняется тело цикла -
while (1 <= 3)
=> console.log(1)
i = 1 + 1 (на этом этапе i стал равен 2)

--Закончилось тело цикла, поэтому происходит возврат в начало (типо рестарт) -
while (2 <= 3)
=> console.log(2)
i = 2 + 1 (на этом этапе i стал равен 3)

--Закончилось тело цикла, поэтому происходит возврат в начало (типо рестарт) -
while (3 <= 3)
=> console.log(3)
i = 3 + 1 (на этом этапе i стал равен 4 (!))

--Предикат возвращает false, поэтому выполнение переходит за цикл (прекращено) -
while(4 <= 3) (4 не может быть меньше или равно 3)

=> console.log('Finished!')

--На этом этапе i равен 4, но он нам уже больше не нужен.
--Функция завершается.

*/

// Самое главное в цикле - завершение его работы (выход из цикла).
// Процесс, который порождает цикл, должен в конце концов остановиться.
// Ответственность за остановку ПОЛНОСТЬЮ лежит на программисте.
// Обычно задача сводится к введению переменной, называемой "счётчиком цикла".
// Сначала счётчик инициализируется, то есть ему задается начальное значение.
// В нашем примере это инструкция let i = 1, выполняемая до входа в цикл. Затем
// в условии цикла проверяется, достиг ли счётчик своего предельного значения.
// И, наконец, счётчик меняет свое значение -  i = 1 + 1.

// На этом моменте новички делают больше всего ошибок.
// Например, случайно забытое увеличение счетчика или неправильная
// проверка в предикате способны привести к зацикливанию. Это ситуация, при
// которой цикл работает бесконечно и программа никогда не останавливается.
// В таком случае приходится её завершать принудительно (кажется я понял,
// как происходят зависания в приложениях.. кто знает, может быть когда зависают
// программы, в этот момент внутри них выполняется бесконечный цикл?..).

/* 

const printNumbers = (lastNumber) => {
  let i = 1;

  => Этот цикл никогда не остановится
  => и будет печатать всегда одно значение
  while (i <= lastNumber) {
    console.log(i);
  }
  console.log('finished!');
};

*/

// В некоторых случаях бесконечные циклы весьма полезны.
// Но на этом курсе такие случаи не рассматриваются, но вот как выглядит
// такой код, с бесконечным циклом:

/*

while(true) {
  => Что-то делаем
}

*/

// Подводим итог.
// Когда нужны циклы, а когда можно обойтись и без них?
// Физически невозможно обойтись без циклов тогда, когда алгоритм
// решения задачи требует повторениях каких-то действий, как в
// примере с книгой, и количество этих операций заранеее неизвестно.

// Задача из урока:

/*

Текст задачи, задача:

Модифицируйте функцию printNumbers() так, чтобы она выводила числа в
обратном порядке. Для этого нужно идти от верхней границы к нижней. 
То есть счётчик должен быть инициализирован максимальным значением,
а в теле цикла его нужно уменьшать до нижней границы.

Примеры вызова и вывода:

printNumbers(4)

=> 4
=> 3
=> 2
=> 1
=> finished!

Моё решение:

const printNumbers = (initialNumber) => {
  let i = initialNumber;
  
  while (i > 0) {
    console.log(i);
    i--;
  }
  
  console.log("finished!");

};

*/

// Агрегация данных

// Отдельный класс задач, который не может обойтись без циклов, называется агре-
// -гированием данных. К таким задачам относятся поиск максимального, минимального,
// суммы, среденего арифметического и т.п. Их главная особенность в том, что результат
// зависит от всего набора данных.
// Для рассчета суммы нужно сложить ВСЕ числа, для вычисления максимального
// надо сравнить ВСЕ числа.

// С такими задачами хорошо знакомы все, кто занимаются числами, например бухгалтеры
// или маркетологи. Обычноих выполняют в таблицах наподобие Microsoft -
// Excel или Google Tables.

// Разберем самый простой пример - поиск суммы набора чисел.
// Реализуем функцию, которая складывает числа в указанном диапазоне, включая
// границы. Диапазоном в данном случае называется ряд чисел от какого-то начала
// до определенного конца. Например, диапазон [1, 10] включает в себя
// все целые числа от 1 д 10.

/*

sumNumbersFromRange(5, 7); => 5 + 6 + 7 = 18
sumNumbersFromRange(1, 2); => 1 + 2 = 3

=> [1, 1] диапазон с одинаковым началом и концом – тоже диапазон
=> он в себя включает ровно одно число – саму границу диапазона
sumNumbersFromRange(1, 1); => 1
sumNumbersFromRange(100, 100); => 100

*/

// Для реализации этого кода нам понадобится цикл, так как сложение чисел - это
// итеративный процесс (он повторяется для каждого числа), а количество итераций
// зависит от размера диапазона.
// «Перед тем, как смотреть на код, попробуйте ответить на вопросы ниже:

// 1) Каким значением инициализировать счетчик?
// 2) Как он будет изменяться?
// 3) Когда цикл должен остановиться?
// Попробуйте сначала подумать над этими вопросами, а затем смотреть на код.»

// 1) - Значение счетчика должно быть равно первому передаваемому аргументу
// 2) - ...
// 3) - Когда счетчик цикла дойдет до последнего переданного аргумента

// Код:

const sumNumbersFromRange = (start, finish) => {
  // Технически можно менять start
  // Но входные аргументы нужно оставлять в исходном значении
  // Это сделает код проще для анализа
  let i = start;
  let sum = 0; // Инициализация суммы

  while (i <= finish) { // Двигаемся до конца диапазона
    sum = sum + i; // Считаем сумму для каждого числа
    i = i + 1; // Переходим к следующему числу в диапазоне
  }

  // Возвращаем получившийся результат
  return sum;
};

console.log( )
console.log(sumNumbersFromRange(5,9)) // => 35 (5 + 6 + 7  + 8 + 9)

// Общая структура цикла здесь стандартна. Есть счетчик, который
// инициализируется начальным значением диапазона, есть сам цикл
// с условием остановки при достижении конца диапазона, и, наконец,
// изменением счетчика в коцне тела цикла.
// Количество итераций в таком цикле равно finish - start + 1.
// То есть для диапазона от 5 до 7 => это 7 - 5 + 1, то есть 3 итерации.

// Главные отличия от обычной обработки связаны с логикой вычисления результата.
// В задачах на агрегацию всегда есть какая-то переменная, которая хранит
// внутри себя результат работы цикла.
// В коде выше это sum.
// На каждой итерации цикла происходит её изменение, прибавление следующего числа
// в диапазоне: sum = sum + i. Весь процесс выглядит вот так:

/*

=> Для вызова sumNumbersFromRange(2, 5);

let sum = 0;
sum = sum + 2; => 2
sum = sum + 3; => 5
sum = sum + 4; => 9
sum = sum + 5; => 14

=> 14 – результат сложения чисел в диапазоне [2, 5]

*/

// У переменной sum есть начальное значение, равное 0.
// Зачем вообще задавать значение?
// Любая повторяющаяся операция начинается с какого-то значения.
// Нельзя просто так объяить переменную и начать с ней работать внутри цикла.
// Это приведет к неверному результату:

/*

=> Начальное значение не задано.
=> JS автоматически делает его равным undefined.
let sum;

=> Первая итерация цикла
sum = sum + 2 => ?

*/

// В результате такого вызова внутри sum окажется NaN, то есть не число.
// Оно возникает из-за попытки сложить 2 и undefined.
// Значит, какое-то значение всё же нужно. Но почему в коде выше выбран 0?
// Очень легко проверить, что все остальные варианты приведут к неверному результату.
// Если начальное значение будет 1, то результат получится на 1 больше, чем нужно.
// Или если нач. значение будет 5 - результат получится на 5 больше.

// В математике существует понятие "НЕЙТРАЛЬНЫЙ ЭЛЕМЕНТ ОПЕРАЦИИ" (у каждой
// операции есть свой элемент). Это понятие имеет очень простой смысл.
// Операция с этим элементом не изменяет то значение, над которым проводится
// операция. В сложении любое число плюс ноль дает само число. При вычитании -
// тоже самое. Да даже у конкатенации есть свой нейтральный элемент - это пустая
// строка: "" + "one" => "one".

// Вопрос на самопроверку. Какой нейтральный элемент у операции умножения?
// Ответ - я думаю что 1. Ибо какое бы число мы не умножали на 1, то оно
// всегда будет давать нам одно и то же значение: 50 * 1 = 50, 40 * 1 = 40,
// 182 * 1 = 182.

// Задача из урока:

/*

Реализуйте функцию multiplyNumbersFromRange(), которая перемножает числа
в указанном диапазоне включая граница диапазона.

Примеры вызова:

iplyNumbersFromRange(1, 5); => 1 * 2 * 3 * 4 * 5 = 120
multiplyNumbersFromRange(2, 3); => 2 * 3 = 6
multiplyNumbersFromRange(6, 6); => 6

Моё решение:

const multiplyNumbersFromRange = (start, finish) => {
  let i = start
  let sum = 1
  
  while (i <= finish) {
    sum = sum * i
    i = i + 1
  }
  
  return sum
}

*/

// Агрегация данных: строки

// Агрегация применяется не только к числам, но и к строкам.
// Это такие задачи, в которых строка формируется динамически, то есть заранее
// неизвестно, какого она размера и что будет содержать.

// Представим себе функцию, которая умеет "умножать" строку, то есть она
// будет повторять её указанное кол-во раз:

// repeat('hexlet', 3) => 'hexlethexlethexlet';

// Принцип работы этой функции довольно простой (ага, щас.. над функцией выше
// больше 40 минут сидел думал, разъедал себе мозги):
// в цикле происходит "наращивание строки" указанное количество раз:

const repeat = (text, times) => {
  // Нейтральный элемент для строк - пустая строка
  let result = ''
  let i = 1

  while (i <= times) {
    // Каждый раз добавляем строку к результату
    result =  `${result}${text}`
    i = i + 1
  }

  return result
}

console.log(repeat('Ismail', 4)) // => 'IsmailIsmailIsmailIsmail'

// Задача из урока:

/*

Реализуйте функцию joinNumbersFromRange(), которая объединяет все числа из
диапазона в строку.

Примеры вызова:

joinNumbersFromRange(1, 1); => '1'
joinNumbersFromRange(2, 3); => '23'
joinNumbersFromRange(5, 10); => '5678910'

Моё решение:

const joinNumbersFromRange = (start, finish) => {
  let i = start
  let result  = ""
  
  while (i <= finish) {
    result = `${result}${i}`
    i = i + 1
  }
  
  return result
};

*/

// Обход строк

// Циклы подходят не только для обработки чисел, но и при работе со строками.
// В первую очередь благодаря возможности получить конкретный символ по его индексу.
// Ниже пример кода, который распечатывает буквы каждого слова на отдельной строке:

const printNameBySymbol = (name) => {
  let i = 0;
  // Такая проверка будет выполняться до конца строки
  // включая последний символ. Его индекс `length - 1`.
  while (i < name.length) {
    // Обращаемся к символу по индексу
    console.log(name[i]);
    i = i + 1;
  }
};

let Name = 'Arya'

console.log( )
console.log(printNameBySymbol(Name))
// => A
// => r
// => y
// => a

// Самое главное в этом коде, поставить правильное условие в while.
// Это можно сделать сразу двумя способами: i < name.length или i <= name.length - 1.
// Оба способа приводят к одному результату.

// Задача из урока:

/*

Текст задачи, задача:

Реализуйте функцию printReversedNameBySymbol(), которая печатает переданное слово
посимвольно, как в примере из теории, но делает это в обратном порядке.

Примеры вызова:

const name = 'Arya';

printReversedNameBySymbol(name);
=> 'a'
=> 'y'
=> 'r'
=> 'A'

Моё решение:

const printReversedNameBySymbol = (name) => {
  let i = 1;
  
  while ( i <= name.length ) {
    console.log(name[name.length - i]);
    i = i + 1;
  };
};

P.S - немножко подглядел ответ (условие), но да ладно.)

*/

// Условия внутри тела цикла

// Тело цикла, как и тело функции - это место выполнения инструкций.
// Значит, мы  можем использовать внутри него всё изученное ранее, например -
// условные конструкции.

// Представим функцию, которая считает, сколько раз входит буква в предложение.
// Пример её работы:

/*

countChars('Fear cuts deeper than swords.', 'e') => 4
=> Если вы ничего не нашли, то результат  - 0 совпадений.
countChars('Sansa', 'y') => 0

*/

// Перед тем как посмотреть её содержимое, попробуем ответить на вопросы:

// => Является ли эта операция агрегацией?
// => Какой будет проверка на вхождение символа?

// 1) - Наверное, да. Тут будет происходить поиск символа в строке, а это агрегация.
// 2) - Вообще не понял вопроса.

const countChars = (str, char) => {
  let i = 0;
  let count = 0;
  while (i < str.length) {
    if (str[i] === char) {
      // Считаем только подходящие символы
      count = count + 1;
    }
    // Счетчик увеличивается в любом случае
    i = i + 1;
  }
}

// Эта задача является агрегирующей. Несмотря на то, что она считает не все
// символы, для подсчета самой суммы все равно приходится анализировать каждый символ.

// Ключевое отличие этого цикла от расммотреных - в наличии условия внутри тела.
// Переменная count увеличивается только в том случае, когда текущий рассматриваемый  
// символ сопвпадает с ожидаемым.

// В остальном - это типичная агрегатная функция, которая возвращает
// количество нужных символов вызываемому коду.

// Задача из урока:

/*

Текст задачи, задача:

Функция из теории учитывает регистр букв.
То есть "A" и "a" с её точки зрения разные символы.
Реализуйте вариант этой же функции, но так чтобы регистр букв был не важен.

Примеры вызова:

countChars('HexlEt', 'e'); => 2
countChars('HexlEt', 'E'); => 2

Моё решение:

(Я тут подумал над функцией, и вспомнил оператор "ИЛИ")

const countChars = (str, char) => {
  let i = 0;
  let count = 0;

  while (i < str.length) {
    if (str[i] === char.toLowerCase() || str[i] === char.toUpperCase()) {
      count = count + 1;
    }

    i = i + 1;
}

return count;
};

Типо, или так - или так))
Т.е, изначально я думал над тем, чтобы функция принимала и так и так - а тут прям
идеально подходит "ИЛИ" (||).

*/

// Формирование строк в циклах

// Еще одно использование циклов - формирование строк. Подобная задача нередко
// встречается в веб-программировании. Она сводится к обычной агрегации
// с применением интерполяции или конкатенации.

// Есть одна задача, крайне популярная среди людей, проводящих собеседования, это
// переворот строки. Её можно решить множеством разных способов, но именно посимвольный
// перебор считается самым базовыми.
// Прмиер работы этой функции:

// reverse('Hexlet') => telxeH

// Общая идея переворота состоит в следующем: нужно брать символы по очереди с
// начала строки и соединять их в обратном порядке.
// Звучит довольно просто (7 предыдущих задач тоже звучали "просто"..), а мы это
// сейчас и проверим:

const reverse = (str) => {
  let i = 0;
  // Нейтральный элемент для строк это пустая строка
  let result = '';

  while (i < str.length) {
    // Соединяем в обратном порядке
    result = `${str[i]}${result}`;
    // То же самое через конкатенацию - result = str[i] + result;
    i = i + 1;
  }

  return result;
};

Name = "Bran"

console.log( )
console.log(reverse(Name)) // => narB

// Проверка нейтрального элемента -

console.log( )
console.log(reverse('')) // => '' (в консоли VSCode и в консоли Node - не выведется)

// Единственны возможно сложный момент в этом коде - прочувствовать, как
// собирается сама строка. Так как каждый следующий символ прикрепляется к
// результирующей строке слева, то, в конечном итоге, строка оказывается перевернута.

// Задача из урока:

/*

Текст задачи, задача:
Реализуйте такую же функцию reverse(), но выполняющую обход строки не с первого
элемента по последний, а наоборот, от последнего к первому. Общая структура
функции при этом останется такой же.

Примечания:

Изменится начальный индекс, условие
окончания цикла, сборка новой строки и формирование нового индекса в цикле.

Мое решение:

const reverse = (str) => {
  let i = str.length - 1; // Индекс последнего элемента
  let result = ''; // Нейтралка
  
  while (i >= 0) {
    result = `${result}${str[i]}`;
    i = i - 1;
  }
  
  return result;
}

*/

// Cинтаксический сахар

// Подобные конструкции - index = index + 1 в JS используются довольно часто,
// поэтому создатели языка добавили сокращенный вариант записи - index += 1.
// Такие сокращения принято называть "СИНТАКСИЧЕСКИМ САХАРОМ", потому что они делают
// процесс написания кода немного проще и приятнее, "подслащивая" его :) (Проржался :D)

// Существуют сокращенные формы для всех арифметических операций и для конкатенации строк:

/*

=> a = a + 1 → a += 1
=> a = a - 1 → a -= 1
=> a = a * 2 → a *= 2
=> a = a / 1 → a /= 1
=> a = a + 'foo' → a += 'foo'

*/

// Задача из урока:

/* 

Текст задачи, задача:

Реализуйте функцию filterString(), принимающую на вход строку и символ, и возвра-
-щающую новую строку в которой удален переданный символ во всех его позициях.

Примеры вызова:

const str = 'If I look back I am lost';
filterString(str, 'I'); => 'f  look back  am lost'
filterString(str, 'o'); => 'If I lk back I am lst'

Мое решение:

const filterString = (str, smb) => {  
  let i = 0;
  let result = "";
  
  while (i < str.length) {
    if (str[i] !== smb) {
      result = `${result}${str[i]}`;
    }
    i += 1;
  }
  return result;
}

Объяснение кода:

Инициализируем счетчик - изначально он равен 0.
Создаем переменную result - она и будет нашей новой строкой.
Создаем цикл, условие - пока счетчик меньше длины строки (таким образом, цикл
будет проходить всю переданную строку).
Далее логические условие:  "если символ в строке с индексом равным счетчику не равен
переданному символу - добавляй этот символ в новую строку", или что-то типо этого.
А если он наоборот равен - он будет пропускаться, ибо условие не будет равным true.
Далее, в цикле счетчик увеличивается на 1 каждую итерацию.
В конце возвращается сама строка result.

*/

// Кочевники: Инкремент++ и декремент--

// Из языка C в JS перекочевали две операции: инкремент (++) и декремент (--),
// которые очень часто встречаются вместе с циклами. Эти унарные операции
// увеличивают и уменьшают на единицу число, записанное в переменную:

/*

let i = 0;
i++; => 0
i++; => 1

i--; => 2
i-- => 1


*/

// Кроме постфиксной формы у них есть и префкисная:

/*

let i = 0;
++i; => 1
++i; => 2

--i; => 1
--i; => 0

*/

// Кажется, что нет никакой разницы между постфиксной и префиксной формами. Но тут
// начинаются все сложности.

// В отличие от всех остальных операций, которые не имеют побочные эффектов и просто
// возвращают новое значение, инкремент и декремент не только возвращают
// значение, но и ИЗМЕНЯЮТ значение переменной.

// При использовании префиксной нотации сначала происходит изменение переменной,
// а потом возврат.

// При использовании постфиксной нотации - наоборот: можно считать, что сначала 
// происходит возврат, а потом изменение переменной.

// Правило работает одинаково для инкремента и декремента. Для простоты будем
// рассматрвиать только инкремент:

/*

let x = 5;

console.log(++x); => 6
console.log(x); => 6

console.log(x++); => 6
console.log(x); => 7

*/

// Что происходит?

// 1) Вывели на экран ++x. Это префиксный инкремент, поэтому сначала значение
// переменной увеличилось на 1, потом результат вернулся и вывелся на экран.

// 2) Так как значение изменилось, console.log(x) вывел 6.

// 3) Теперь выводим на экран x++. Это постфиксный инкремент, поэтому возвращено
// значение, содержавшееся в переменной до ее увеличения на 1.

// 4) Так как значение изменилось (но не вывелось), console.log(x) вывел 7.

// Как-то так.

// Особенно страшным это становится тогда, когда инкремент вставляют внутрь других
// операций: x = 1++ - 7 + --h. Понять такой код почти невозможно, и его написание
// должно рассматриваться как тяжкое преступление.

// Например, в языке JS линтер (программа, проверяющая код) сразу начинает ругаться,
// когда встречает использование инкремента или декремента.

// Рекомендации по использованию:

// 1) Никогда не мешать в рамках одного выражения операции/функции без побочных
// эффектов с операциями/функциями, обладающими побочными эффектами.

// 2) Используйте инкремент и декремент только там, где нет разницы между префиксным
// и постфиксным вариантом: отдельно от всего, на своей собственной строчке кода.

// Задача из урока:

/*

Текст задачи, задача:

Напишите функцию makeItFunny(), которая принимает на вход строку и возвращает её копию,
у которой каждый n-ный элемент переведен в верхний регистр. n - задается на входе в функцию.

Примечания:

Для опеределения каждого n-ного элемента понадобится остаток от деления - оператор %.
"Подумайте, как его можно использовать."

Примеры вызова функции:

const text = "I never look back"
=> Каждый третий элемент
makeItFunny(text, 3) // "I NevEr LooK bAck"

Мое решение (решение учителя):

const makeItFunny = (str, smb) => {
  let i = 0;
  let result = "";
  
  while (i < str.length) {
    let currentSmb = str[i]; // Текущий символ
    if ((i + 1) % smb === 0) {
      result = `${result}${currentSmb.toUpperCase()}`;
    } else {
      result  = `${result}${currentSmb}`
    }
    ++i; 
  }
  
  return result;
}

P.S - это был полнейший пипец. Задача оказалась настолько сложной, что я над ней сидел
целых ДВА С ПОЛОВИНОЙ ЧАСА! ДВА С ПОЛОВИНОЙ, КАРЛ!
Я сидел и думал - "лучше уж стану депутатом, чем этим вашим прОгроммистОм".
Когда я увидел решение учителя, вспомнил фразу священника из фильма "Очень
страшное кино" - "Ну на*ер!"
Это было нечто. Саааамое сложное задание за всю мою учебу, капец.
Всё настроение под ноль.

*/

// Возврат из циклов

// Работа с циклами обычно сводится к двум сценариям:

/*

1) Агрегация. Накопление результата во время итераций и работа с ним после цикла.
Переворот строки как раз относится к такому варианту.

2) Выполнение цикла до достижения необходимого результата и выход.
Например, задача поиска простых чисел. Простое число - это число, которое делится
только на себя или на единицу.

*/

// Рассмотрим простой алгоритм проверки простоты числа.
// Будем делить искомое число "x" на все числа из диапазона от двух до x - 1
// и смотреть остаток от деления. Если в этом диапазоне не найден делитель,
// который делит число x без остатка, значит перед нами простое число.

// Если задуматься, то можно заметить, что достаточно проверять числа не до x - 1,
// а до половины числа. Например, 11 не делится на 2, 3, 4, 5. Но и дальше гарантированно
// не будет делиться на числа больше своей половины. Значит, можно провести
// небольшую оптимизацию и проверять деление только до x / 2.

const isPrime = (number) => {
  if (number < 2) {
    return false;
  }

  let divider = 2;

  while (divider <= number / 2) {
    if (number % divider === 0) {
        return false;
    }

    divider += 1;
  }
  return true;
}

console.log( )
console.log(isPrime(1)) // => false
console.log( )
console.log(isPrime(2)) // => true
console.log( )
console.log(isPrime(3)) // => true
console.log( )
console.log(isPrime(4)) // => false

// Алгоритм построен таким образом, что если во время последовательного деления на числа
// до x / 2 находится хоть одно, которое делит без остатка, то переданный
// аргумент - не простое число, а значит - дальнейшие вычисления на имеют смысла.
// В этом месте стоит возврат false.

// И только если цикл отработал целиком, можно сделать вывод, что число - простое,
// так как не было найдено ни одного числа, которое делит число без остатка.

// Задача из урока:

/*

Текст задачи, задача:

Реализуйте функцию hasChar(), которая проверяет (с учетом регистра), содержит
ли строка указанную букву.

Примечания:

Функция будет принимать два параметра:

1) Строка
2) Буква для поиска

Примеры вызова:

hasChar('Renly', 'R'); => true
hasChar('Renly', 'r'); => false
hasChar('Tommy', 'm'); => true
hasChar('Tommy', 'd'); => false

Моё решение:

const hasChar = (str, smb) => {
  let i = 0; // => Счетчик для цикла
  let TorF;

  while (i < str.length) {
    if (str.includes(smb)) {
      TorF = true;
    } else {
      TorF = false;
    }

    i = i + 1;
  }

  return TorF;
}

*/