// Конструкция Switch

// Многие языки в дополнение к условной конструкции "if" включают в себя
// Switch. Это спецаилизированная версия if, созданная для некоторых особых ситуаций.
// Например, её имеет смысл использовать там, где есть цепочка if else с проверками
// на равенство. Например:

/*

if (status === 'processing') {
    // Делаем раз
} else if (status === 'paid') {
    // Делаем двас
} else if (status === 'new') {
    // Делаем трис
} else {
    // Делаем четырес
}

*/

// Эта составная проверка обладает одной отличительной чертой: каждая ветка
// здесь - это проверка значения переменной status. Switch позволяет записать
// этот код короче и выразительнее (насчет последнего - сомневаюсь, сомневаюсь..):

/*

switch (status) {
  case 'processing': // status == processing
    // Делаем раз
    break;
  case 'paid': // status == paid
    // Делаем два
    break;
  case 'new': // status == new
    // Делаем три
    break;
  default: // else
    // Делаем четыре
}

*/

// Свитч - довольно сложная (еще бы..) конструкция с точки зрения количества
// элементов, из которых она состоит:

// 1) Внешнее описание, в которое входит ключевое слово switch. Переменная,
// по значениям которой switch будет выбирать поведение. И фигурные скобки
// для вариантов поведения.

// 2) Конструкции case и default, внутри которых описывается поведение для
// разных значений рассматриваемой переменной. Каждый case соответствует if
// в примере выше. default - это особая ситуация, соответствующая ветке
// else в условных конструкциях. Как else, указывать default не обязательно.
// НО! - линтер будет всегда настойчиво его просить.

// 3) break. break нужен для предотвращения "проваливания". Если его не
// указать, то после выполнения нужного case выполнение перейдет к следующему
// case, и так либо до ближайшего break, либо до конца switch.
// Что значит "перейдет к следующему"? - представим ситуацию:
// Мы сели в автобус, едем.
// Но вдруг, водитель ПРОПУСТИЛ нашу остановку.
// То же самое и с "проваливанием" - интерпретатор найдет нужное значение,
// нужный case - но пропустит его и будет переходить так до сааамого конца.

// Фигурные скобки в switch не определяют блок кода,
// как это было в других местах. Внутри допустим только тот синтаксис,
// который показан выше. То есть там можно использовать case или default.
// А вот внутри каждого case (и default) ситуация другая. Здесь
// можно выполнять любой произвольный код:

/*

switch (count) {
    case 1:
        // Делаем что-то полезное
        break;
    case 2:
        // Делаем что-то полезное
        break;
    default:
        // Что-то делаем
}

*/

// Иногда результат, полученный внутри case, - это конец выполнения функции.
// содержащей switch. В таком случае его нужно как-то вернуть наружу.
// Для решения этой задачи есть два способа.

// Первый. Создать переменную ПЕРЕД switch, заполнить её в case и затем, в конце
// вернуть значение этой переменной наружу.

/*

(count) => {
  // Объявляем переменную
  let result;

  // Заполняем
  switch (count) {
    case 1:
      result = 'one';
      break;
    case 2:
      result = 'two';
      break;
    default:
      result = null;
  }

  // Возвращаем
  return result;
};

*/

// Второй способ проще и короче.
// Вместо создания переменной, case позволяет внутри себя делать обычный
// возврат из функции. А так как после return никакой код не выполняется,
// то мы можем избавиться от break:

/*

(count) => {
    switch(count) {
        case 1:
            return 'one';
        case 2:
            return 'two';
        default:
            return null;
    }
};

*/

// Допишу позже.