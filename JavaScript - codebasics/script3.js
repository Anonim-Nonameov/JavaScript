// Конструкция Switch

// Многие языки в дополнение к условной конструкции "if" включают в себя
// Switch. Это спецаилизированная версия if, созданная для некоторых особых ситуаций.
// Например, её имеет смысл использовать там, где есть цепочка if else с проверками
// на равенство. Например:

/*

if (status === 'processing') {
    // Делаем раз
} else if (status === 'paid') {
    // Делаем двас
} else if (status === 'new') {
    // Делаем трис
} else {
    // Делаем четырес
}

*/

// Эта составная проверка обладает одной отличительной чертой: каждая ветка
// здесь - это проверка значения переменной status. Switch позволяет записать
// этот код короче и выразительнее (насчет последнего - сомневаюсь, сомневаюсь..):

/*

switch (status) {
  case 'processing': // status == processing
    // Делаем раз
    break;
  case 'paid': // status == paid
    // Делаем два
    break;
  case 'new': // status == new
    // Делаем три
    break;
  default: // else
    // Делаем четыре
}

*/

// Свитч - довольно сложная (еще бы..) конструкция с точки зрения количества
// элементов, из которых она состоит:

// 1) Внешнее описание, в которое входит ключевое слово switch. Переменная,
// по значениям которой switch будет выбирать поведение. И фигурные скобки
// для вариантов поведения.

// 2) Конструкции case и default, внутри которых описывается поведение для
// разных значений рассматриваемой переменной. Каждый case соответствует if
// в примере выше. default - это особая ситуация, соответствующая ветке
// else в условных конструкциях. Как else, указывать default не обязательно.
// НО! - линтер будет всегда настойчиво его просить.

// 3) break. break нужен для предотвращения "проваливания". Если его не
// указать, то после выполнения нужного case выполнение перейдет к следующему
// case, и так либо до ближайшего break, либо до конца switch.
// Что значит "перейдет к следующему"? - представим ситуацию:
// Мы сели в автобус, едем.
// Но вдруг, водитель ПРОПУСТИЛ нашу остановку.
// То же самое и с "проваливанием" - интерпретатор найдет нужное значение,
// нужный case - но пропустит его и будет переходить так до сааамого конца.

// Фигурные скобки в switch не определяют блок кода,
// как это было в других местах. Внутри допустим только тот синтаксис,
// который показан выше. То есть там можно использовать case или default.
// А вот внутри каждого case (и default) ситуация другая. Здесь
// можно выполнять любой произвольный код:

/*

switch (count) {
    case 1:
        // Делаем что-то полезное
        break;
    case 2:
        // Делаем что-то полезное
        break;
    default:
        // Что-то делаем
}

*/

// Иногда результат, полученный внутри case, - это конец выполнения функции.
// содержащей switch. В таком случае его нужно как-то вернуть наружу.
// Для решения этой задачи есть два способа.

// Первый. Создать переменную ПЕРЕД switch, заполнить её в case и затем, в конце
// вернуть значение этой переменной наружу.

/*

(count) => {
  // Объявляем переменную
  let result;

  // Заполняем
  switch (count) {
    case 1:
      result = 'one';
      break;
    case 2:
      result = 'two';
      break;
    default:
      result = null;
  }

  // Возвращаем
  return result;
};

*/

// Второй способ проще и короче.
// Вместо создания переменной, case позволяет внутри себя делать обычный
// возврат из функции. А так как после return никакой код не выполняется,
// то мы можем избавиться от break:

/*

(count) => {
    switch(count) {
        case 1:
            return 'one';
        case 2:
            return 'two';
        default:
            return null;
    }
};

*/

// Switch хоть и встречается в коде, но технически всегда можно обойтись и без
// него, используя if и else. Ключевая польза при его использовании в том, что
// он лучше выражает намерение программиста, когда нужно проверять конкретные
// значения переменной. Хотя кода и стало физически чуть больше, читать его
// легче, в отличие от блоков else if.

// Задача из урока:

/*

Текст задачи, задача:

Реализуйте функцию getNumberExplanation(), которая принимает на вход число и
возвращает объяснение этого числа. Если для числа нет объяснения, то
возвращается null - (примеры вызова):

getNumberExplanation(8);   // null

=> Объяснения есть только для указанных ниже чисел

getNumberExplanation(666); // 'devil number'
getNumberExplanation(42);  // 'answer for everything'
getNumberExplanation(7);   // 'prime number'

Моё решение:

const getNumberExplanation = (num) => {
  switch (num) {
    case 666:
      return 'devil number'
    case 42:
      return 'answer for everything'
    case 7:
      return 'prime number'
    default:
      return null
  }
}

*/

// Цикл While

// «Программы, которые мы пишем, становятся всё сложнее и объемнее. Они всё
// еще очень далеки от реальных программ, где количество строк кода измеряется
// десятками и сотнями тысяч (а иногда и миллионами), но текущая сложность уже
// способна заставить напрячься людей без опыта. Начиная с этого урока, мы пере-
// ходим к одной из самый сложных базовых тем в программировании - циклам.»
// (C) - Hexlet

// Ну, насчет сложности - это правда.
// А мы продолжаем -

// Любые прикладные программмы служат очень прагматичным целям. Они помогают
// управлять сотрудниками, финансами, развлекают - в конце концов.
// Несмотря на различия, все эти прораммы выполняют заложенные в них алгоритмы,
// которые очень похожи между собой. Но что это такое, алогритм? Алгоритм - 
// это последовательность действий (инструкций) которая приводит нас к некоему
// ожидаемому результату.
// В принципе, это описание подходит под любую программу, но под алгоритмами
// обычно понимается что-то более специфичное.

// Представьте себе, что у нас есть книга и мы хотим найти внутри неё какую-то
// конкретную фразу.
// Саму фразу мы помним, но не знаем, на какой она странице. Как найти нужную
// страницу? самый простой (и дооолгий) способ - последовательно просматривать
// страницы до тех пор, пока мы не найдем нужную.
// В худшем случае придется просмотреть все страницы, но результат мы всё
// равно получим (но шанс того что мы пропустим нужную нам фразу - крайне велик).
// Именно этот процесс и называется алгоритмом. Он включает в себя логические
// проверки (нашли ли фразу) и перебор страницы.
// Количество страниц, которое придется посмотреть, заранее неизвестно, но сам
// процесс повторяется из раза в раз совершенно одинаковым образом.
// Для выполнения повторяющихся действий как раз и нужны циклы.
// Каждый повтор, в таком случае, называется итерацией (кто немного разбирается в
// процессорах - тот поймет). 

// Допустим, мы хотим написать функцию, которая выводит на экран все числа
// от одного до указанного (через аргументы):

/*

printNumbers(3)

=> 1
=> 2
=> 3

*/

// Мы не сможем реализовать эту функцию, применяя ранее изученные функции/свойства
// и т.д, так как количество выводов на экран заранее НЕИЗВЕСТНО. А с циклами
// то не составит никаких проблем:

const printNumbers = (lastNum) => {
  let i = 1
  // i - сокращение от "index" (порядковый номер)
  // Используется по общему соглашению во множестве языков
  // как счетчик цикла
  
  while(i <= lastNum) {
    console.log(i)
    i++ // можно через i = i + 1
  }
  console.log('Finished!')
} 

console.log( )
printNumbers(3) // => 1, 2, 3, 'Finished!'

// В коде функции использован цкил while.
// Он состоит из трёх элементов:

/*

--Ключевое слово while. Несмотря на схожесть с вызовом функции,
это не вызов функции.

----Предикат. Условие, которое указывается в скобках после while. Это условие
вычисляется на каждой итерации.

------Тело цикла. Блок кода в фигурных скобках. Этот блок аналогичен блоку кода
в функциях. Всё, что определено внутри этого блока (константы или переменные),
видно только внутри этого блока.

*/

// Конструкция читается так:
// «Делать то, что указано в теле цикла, пока истинно условие (предикат)
// "i <= lastNum" (i меньше или равен lastNum)».
// Разберем работу этого кода для вызова printNumbers(3):

/*

--Инициализируется переменная i -
let i =  (на этом этапе i равна 1)

--Предикат возвращает true, поэтому выполняется тело цикла -
while (1 <= 3)
=> console.log(1)
i = 1 + 1 (на этом этапе i стал равен 2)

--Закончилось тело цикла, поэтому происходит возврат в начало (типо рестарт) -
while (2 <= 3)
=> console.log(2)
i = 2 + 1 (на этом этапе i стал равен 3)

--Закончилось тело цикла, поэтому происходит возврат в начало (типо рестарт) -
while (3 <= 3)
=> console.log(3)
i = 3 + 1 (на этом этапе i стал равен 4 (!))

--Предикат возвращает false, поэтому выполнение переходит за цикл (прекращено) -
while(4 <= 3) (4 не может быть меньше или равно 3)

=> console.log('Finished!')

--На этом этапе i равен 4, но он нам уже больше не нужен.
--Функция завершается.

*/

// Самое главное в цикле - завершение его работы (выход из цикла).
// Процесс, который порождает цикл, должен в конце концов остановиться.
// Ответственность за остановку ПОЛНОСТЬЮ лежит на программисте.
// Обычно задача сводится к введению переменной, называемой "счётчиком цикла".
// Сначала счётчик инициализируется, то есть ему задается начальное значение.
// В нашем примере это инструкция let i = 1, выполняемая до входа в цикл. Затем
// в условии цикла проверяется, достиг ли счётчик своего предельного значения.
// И, наконец, счётчик меняет свое значение -  i = 1 + 1.

// На этом моменте новички делают больше всего ошибок.
// Например, случайно забытое увеличение счетчика или неправильная
// проверка в предикате способны привести к зацикливанию. Это ситуация, при
// которой цикл работает бесконечно и программа никогда не останавливается.
// В таком случае приходится её завершать принудительно (кажется я понял,
// как происходят зависания в приложениях.. кто знает, может быть когда зависают
// программы, в этот момент внутри них выполняется бесконечный цикл?..).

/* 

const printNumbers = (lastNumber) => {
  let i = 1;

  => Этот цикл никогда не остановится
  => и будет печатать всегда одно значение
  while (i <= lastNumber) {
    console.log(i);
  }
  console.log('finished!');
};

*/

// В некоторых случаях бесконечные циклы весьма полезны.
// Но на этом курсе такие случаи не рассматриваются, но вот как выглядит
// такой код, с бесконечным циклом:

/*

while(true) {
  => Что-то делаем
}

*/

// Подводим итог.
// Когда нужны циклы, а когда можно обойтись и без них?
// Физически невозможно обойтись без циклов тогда, когда алгоритм
// решения задачи требует повторениях каких-то действий, как в
// примере с книгой, и количество этих операций заранеее неизвестно.

// Задача из урока:

/*

Текст задачи, задача:

Модифицируйте функцию printNumbers() так, чтобы она выводила числа в
обратном порядке. Для этого нужно идти от верхней границы к нижней. 
То есть счётчик должен быть инициализирован максимальным значением,
а в теле цикла его нужно уменьшать до нижней границы.

Примеры вызова и вывода:

printNumbers(4)

=> 4
=> 3
=> 2
=> 1
=> finished!

Моё решение:

const printNumbers = (initialNumber) => {
  let i = initialNumber;
  
  while (i > 0) {
    console.log(i);
    i--;
  }
  
  console.log("finished!");

};

*/

// Агрегация данных

// Отдельный класс задач, который не может обойтись без циклов, называется агре-
// -гированием данных. К таким задачам относятся поиск максимального, минимального,
// суммы, среденего арифметического и т.п. Их главная особенность в том, что результат
// зависит от всего набора данных.
// Для рассчета суммы нужно сложить ВСЕ числа, для вычисления максимального
// надо сравнить ВСЕ числа.

// С такими задачами хорошо знакомы все, кто занимаются числами, например бухгалтеры
// или маркетологи. Обычноих выполняют в таблицах наподобие Microsoft -
// Excel или Google Tables.

// Разберем самый простой пример - поиск суммы набора чисел.
// Реализуем функцию, которая складывает числа в указанном диапазоне, включая
// границы. Диапазоном в данном случае называется ряд чисел от какого-то начала
// до определенного конца. Например, диапазон [1, 10] включает в себя
// все целые числа от 1 д 10.

/*

sumNumbersFromRange(5, 7); => 5 + 6 + 7 = 18
sumNumbersFromRange(1, 2); => 1 + 2 = 3

=> [1, 1] диапазон с одинаковым началом и концом – тоже диапазон
=> он в себя включает ровно одно число – саму границу диапазона
sumNumbersFromRange(1, 1); => 1
sumNumbersFromRange(100, 100); => 100

*/

// Для реализации этого кода нам понадобится цикл, так как сложение чисел - это
// итеративный процесс (он повторяется для каждого числа), а количество итераций
// зависит от размера диапазона.
// «Перед тем, как смотреть на код, попробуйте ответить на вопросы ниже:

// 1) Каким значением инициализировать счетчик?
// 2) Как он будет изменяться?
// 3) Когда цикл должен остановиться?
// Попробуйте сначала подумать над этими вопросами, а затем смотреть на код.»

// 1) - Значение счетчика должно быть равно первому передаваемому аргументу
// 2) - ...
// 3) - Когда счетчик цикла дойдет до последнего переданного аргумента

// Код:

const sumNumbersFromRange = (start, finish) => {
  // Технически можно менять start
  // Но входные аргументы нужно оставлять в исходном значении
  // Это сделает код проще для анализа
  let i = start;
  let sum = 0; // Инициализация суммы

  while (i <= finish) { // Двигаемся до конца диапазона
    sum = sum + i; // Считаем сумму для каждого числа
    i = i + 1; // Переходим к следующему числу в диапазоне
  }

  // Возвращаем получившийся результат
  return sum;
};

console.log( )
console.log(sumNumbersFromRange(5,9)) // => 35 (5 + 6 + 7  + 8 + 9)

// Общая структура цикла здесь стандартна. Есть счетчик, который
// инициализируется начальным значением диапазона, есть сам цикл
// с условием остановки при достижении конца диапазона, и, наконец,
// изменением счетчика в коцне тела цикла.
// Количество итераций в таком цикле равно finish - start + 1.
// То есть для диапазона от 5 до 7 => это 7 - 5 + 1, то есть 3 итерации.

// Главные отличия от обычной обработки связаны с логикой вычисления результата.
// В задачах на агрегацию всегда есть какая-то переменная, которая хранит
// внутри себя результат работы цикла.
// В коде выше это sum.
// На каждой итерации цикла происходит её изменение, прибавление следующего числа
// в диапазоне: sum = sum + i. Весь процесс выглядит вот так:

/*

=> Для вызова sumNumbersFromRange(2, 5);

let sum = 0;
sum = sum + 2; => 2
sum = sum + 3; => 5
sum = sum + 4; => 9
sum = sum + 5; => 14

=> 14 – результат сложения чисел в диапазоне [2, 5]

*/

// У переменной sum есть начальное значение, равное 0.
// Зачем вообще задавать значение?
// Любая повторяющаяся операция начинается с какого-то значения.
// Нельзя просто так объяить переменную и начать с ней работать внутри цикла.
// Это приведет к неверному результату:

/*

=> Начальное значение не задано.
=> JS автоматически делает его равным undefined.
let sum;

=> Первая итерация цикла
sum = sum + 2 => ?

*/

// В результате такого вызова внутри sum окажется NaN, то есть не число.
// Оно возникает из-за попытки сложить 2 и undefined.
// Значит, какое-то значение всё же нужно. Но почему в коде выше выбран 0?
// Очень легко проверить, что все остальные варианты приведут к неверному результату.
// Если начальное значение будет 1, то результат получится на 1 больше, чем нужно.
// Или если нач. значение будет 5 - результат получится на 5 больше.

// В математике существует понятие "НЕЙТРАЛЬНЫЙ ЭЛЕМЕНТ ОПЕРАЦИИ" (у каждой
// операции есть свой элемент). Это понятие имеет очень простой смысл.
// Операция с этим элементом не изменяет то значение, над которым проводится
// операция. В сложении любое число плюс ноль дает само число. При вычитании -
// тоже самое. Да даже у конкатенации есть свой нейтральный элемент - это пустая
// строка: "" + "one" => "one".

// Вопрос на самопроверку. Какой нейтральный элемент у операции умножения?
// Ответ - я думаю что 1. Ибо какое бы число мы не умножали на 1, то оно
// всегда будет давать нам одно и то же значение: 50 * 1 = 50, 40 * 1 = 40,
// 182 * 1 = 182.

// Задача из урока:

/*

Реализуйте функцию multiplyNumbersFromRange(), которая перемножает числа
в указанном диапазоне включая граница диапазона.

Примеры вызова:

iplyNumbersFromRange(1, 5); => 1 * 2 * 3 * 4 * 5 = 120
multiplyNumbersFromRange(2, 3); => 2 * 3 = 6
multiplyNumbersFromRange(6, 6); => 6

Моё решение:

const multiplyNumbersFromRange = (start, finish) => {
  let i = start
  let sum = 1
  
  while (i <= finish) {
    sum = sum * i
    i = i + 1
  }
  
  return sum
}

*/

// Агрегация данных: строки

// Агрегация применяется не только к числам, но и к строкам.
// Это такие задачи, в которых строка формируется динамически, то есть заранее
// неизвестно, какого она размера и что будет содержать.

// Представим себе функцию, которая умеет "умножать" строку, то есть она
// будет повторять её указанное кол-во раз:

// repeat('hexlet', 3) => 'hexlethexlethexlet';

// Принцип работы этой функции довольно простой (ага, щас.. над функцией выше
// больше 40 минут сидел думал, разъедал себе мозги):
// в цикле происходит "наращивание строки" указанное количество раз:

const repeat = (text, times) => {
  // Нейтральный элемент для строк - пустая строка
  let result = ''
  let i = 1

  while (i <= times) {
    // Каждый раз добавляем строку к результату
    result =  `${result}${text}`
    i = i + 1
  }

  return result
}

console.log(repeat('Ismail', 4)) // => 'IsmailIsmailIsmailIsmail'

// Задача из урока:

/*

Реализуйте функцию joinNumbersFromRange(), которая объединяет все числа из
диапазона в строку.

Примеры вызова:

joinNumbersFromRange(1, 1); => '1'
joinNumbersFromRange(2, 3); => '23'
joinNumbersFromRange(5, 10); => '5678910'

Моё решение:

const joinNumbersFromRange = (start, finish) => {
  let i = start
  let result  = ""
  
  while (i <= finish) {
    result = `${result}${i}`
    i = i + 1
  }
  
  return result
};

*/

// Обход строк

// Допишу позже, опять всё время на задачу потратил.