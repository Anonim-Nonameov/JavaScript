// Конструкция Switch

// Многие языки в дополнение к условной конструкции "if" включают в себя
// Switch. Это спецаилизированная версия if, созданная для некоторых особых ситуаций.
// Например, её имеет смысл использовать там, где есть цепочка if else с проверками
// на равенство. Например:

/*

if (status === 'processing') {
    // Делаем раз
} else if (status === 'paid') {
    // Делаем двас
} else if (status === 'new') {
    // Делаем трис
} else {
    // Делаем четырес
}

*/

// Эта составная проверка обладает одной отличительной чертой: каждая ветка
// здесь - это проверка значения переменной status. Switch позволяет записать
// этот код короче и выразительнее (насчет последнего - сомневаюсь, сомневаюсь..):

/*

switch (status) {
  case 'processing': // status == processing
    // Делаем раз
    break;
  case 'paid': // status == paid
    // Делаем два
    break;
  case 'new': // status == new
    // Делаем три
    break;
  default: // else
    // Делаем четыре
}

*/

// Свитч - довольно сложная (еще бы..) конструкция с точки зрения количества
// элементов, из которых она состоит:

// 1) Внешнее описание, в которое входит ключевое слово switch. Переменная,
// по значениям которой switch будет выбирать поведение. И фигурные скобки
// для вариантов поведения.

// 2) Конструкции case и default, внутри которых описывается поведение для
// разных значений рассматриваемой переменной. Каждый case соответствует if
// в примере выше. default - это особая ситуация, соответствующая ветке
// else в условных конструкциях. Как else, указывать default не обязательно.
// НО! - линтер будет всегда настойчиво его просить.

// 3) break. break нужен для предотвращения "проваливания". Если его не
// указать, то после выполнения нужного case выполнение перейдет к следующему
// case, и так либо до ближайшего break, либо до конца switch.
// Что значит "перейдет к следующему"? - представим ситуацию:
// Мы сели в автобус, едем.
// Но вдруг, водитель ПРОПУСТИЛ нашу остановку.
// То же самое и с "проваливанием" - интерпретатор найдет нужное значение,
// нужный case - но пропустит его и будет переходить так до сааамого конца.

// Фигурные скобки в switch не определяют блок кода,
// как это было в других местах. Внутри допустим только тот синтаксис,
// который показан выше. То есть там можно использовать case или default.
// А вот внутри каждого case (и default) ситуация другая. Здесь
// можно выполнять любой произвольный код:

/*

switch (count) {
    case 1:
        // Делаем что-то полезное
        break;
    case 2:
        // Делаем что-то полезное
        break;
    default:
        // Что-то делаем
}

*/

// Иногда результат, полученный внутри case, - это конец выполнения функции.
// содержащей switch. В таком случае его нужно как-то вернуть наружу.
// Для решения этой задачи есть два способа.

// Первый. Создать переменную ПЕРЕД switch, заполнить её в case и затем, в конце
// вернуть значение этой переменной наружу.

/*

(count) => {
  // Объявляем переменную
  let result;

  // Заполняем
  switch (count) {
    case 1:
      result = 'one';
      break;
    case 2:
      result = 'two';
      break;
    default:
      result = null;
  }

  // Возвращаем
  return result;
};

*/

// Второй способ проще и короче.
// Вместо создания переменной, case позволяет внутри себя делать обычный
// возврат из функции. А так как после return никакой код не выполняется,
// то мы можем избавиться от break:

/*

(count) => {
    switch(count) {
        case 1:
            return 'one';
        case 2:
            return 'two';
        default:
            return null;
    }
};

*/

// Switch хоть и встречается в коде, но технически всегда можно обойтись и без
// него, используя if и else. Ключевая польза при его использовании в том, что
// он лучше выражает намерение программиста, когда нужно проверять конкретные
// значения переменной. Хотя кода и стало физически чуть больше, читать его
// легче, в отличие от блоков else if.

// Задача из урока:

/*

Текст задачи, задача:

Реализуйте функцию getNumberExplanation(), которая принимает на вход число и
возвращает объяснение этого числа. Если для числа нет объяснения, то
возвращается null - (примеры вызова):

getNumberExplanation(8);   // null

=> Объяснения есть только для указанных ниже чисел

getNumberExplanation(666); // 'devil number'
getNumberExplanation(42);  // 'answer for everything'
getNumberExplanation(7);   // 'prime number'

Моё решение:

const getNumberExplanation = (num) => {
  switch (num) {
    case 666:
      return 'devil number'
    case 42:
      return 'answer for everything'
    case 7:
      return 'prime number'
    default:
      return null
  }
}

*/

// Цикл While

// «Программы, которые мы пишем, становятся всё сложнее и объемнее. Они всё
// еще очень далеки от реальных программ, где количество строк кода измеряется
// десятками и сотнями тысяч (а иногда и миллионами), но текущая сложность уже
// способна заставить напрячься людей без опыта. Начиная с этого урока, мы пере-
// ходим к одной из самый сложных базовых тем в программировании - циклам.»
// (C) - Hexlet

// Ну, насчет сложности - это правда.
// А мы продолжаем -

// Любые прикладные программмы служат очень прагматичным целям. Они помогают
// управлять сотрудниками, финансами, развлекают - в конце концов.
// Несмотря на различия, все эти прораммы выполняют заложенные в них алгоритмы,
// которые очень похожи между собой. Но что это такое, алогритм? Алгоритм - 
// это последовательность действий (инструкций) которая приводит нас к некоему
// ожидаемому результату.
// В принципе, это описание подходит под любую программу, но под алгоритмами
// обычно понимается что-то более специфичное.

// Представьте себе, что у нас есть книга и мы хотим найти внутри неё какую-то
// конкретную фразу.
// Саму фразу мы помним, но не знаем, на какой она странице. Как найти нужную
// страницу? самый простой (и дооолгий) способ - последовательно просматривать
// страницы до тех пор, пока мы не найдем нужную.
// В худшем случае придется просмотреть все страницы, но результат мы всё
// равно получим (но шанс того что мы пропустим нужную нам фразу - крайне велик).
// Именно этот процесс и называется алгоритмом. Он включает в себя логические
// проверки (нашли ли фразу) и перебор страницы.
// Количество страниц, которое придется посмотреть, заранее неизвестно, но сам
// процесс повторяется из раза в раз совершенно одинаковым образом.
// Для выполнения повторяющихся действий как раз и нужны циклы.
// Каждый повтор, в таком случае, называется итерацией (кто немного разбирается в
// процессорах - тот поймет). 

// Допустим, мы хотим написать функцию, которая выводит на экран все числа
// от одного до указанного (через аргументы):

/*

printNumbers(3)

=> 1
=> 2
=> 3

*/

// Мы не сможем реализовать эту функцию, применяя ранее изученные функции/свойства
// и т.д, так как количество выводов на экран заранее НЕИЗВЕСТНО. А с циклами
// то не составит никаких проблем:

const printNumbers = (lastNum) => {
  let i = 1
  // i - сокращение от "index" (порядковый номер)
  // Используется по общему соглашению во множестве языков
  // как счетчик цикла
  
  while(i <= lastNum) {
    console.log(i)
    i++ // можно через i = i + 1
  }
  console.log('Finished!')
} 

console.log( )
printNumbers(3) // => 1, 2, 3, 'Finished!'

// В коде функции использован цкил while.
// Он состоит из трёх элементов:

/*

--Ключевое слово while. Несмотря на схожесть с вызовом функции,
это не вызов функции.

----Предикат. Условие, которое указывается в скобках после while. Это условие
вычисляется на каждой итерации.

------Тело цикла. Блок кода в фигурных скобках. Этот блок аналогичен блоку кода
в функциях. Всё, что определено внутри этого блока (константы или переменные),
видно только внутри этого блока.

*/

// Конструкция читается так:
// «Делать то, что указано в теле цикла, пока истинно условие (предикат)
// "i <= lastNum" (i меньше или равен lastNum)».
// Разберем работу этого кода для вызова printNumbers(3):

/*

--Инициализируется переменная i -
let i =  (на этом этапе i равна 1)

--Предикат возвращает true, поэтому выполняется тело цикла -
while (1 <= 3)
=> console.log(1)
i = 1 + 1 (на этом этапе i стал равен 2)

--Закончилось тело цикла, поэтому происходит возврат в начало (типо рестарт) -
while (2 <= 3)
=> console.log(2)
i = 2 + 1 (на этом этапе i стал равен 3)

--Закончилось тело цикла, поэтому происходит возврат в начало (типо рестарт) -
while (3 <= 3)
=> console.log(3)
i = 3 + 1 (на этом этапе i стал равен 4 (!))

--Предикат возвращает false, поэтому выполнение переходит за цикл (прекращено) -
while(4 <= 3) (4 не может быть меньше или равно 3)

=> console.log('Finished!')

--На этом этапе i равен 4, но он нам уже больше не нужен.
--Функция завершается.

*/

// Самое главное в цикле - завершение его работы (выход из цикла).
// Процесс, который порождает цикл, должен в конце концов остановиться.
// Ответственность за остановку ПОЛНОСТЬЮ лежит на программисте.
// Обычно задача сводится к введению переменной, называемой "счётчиком цикла".
// Сначала счётчик инициализируется, то есть ему задается начальное значение.
// В нашем примере это инструкция let i = 1, выполняемая до входа в цикл. Затем
// в условии цикла проверяется, достиг ли счётчик своего предельного значения.
// И, наконец, счётчик меняет свое значение -  i = 1 + 1.

// А еще у меня время вышло))
// Допишу позже...