// Повтор изученного

// Переменные: что такое переменная, создание переменной, присваивание значений и т.д.

/*

Что такое переменная?
Переменная это такая себе коробочка с некими данными, которые
мы можем использовать в нашем коде.
Мы можем сохранить в переменную любую информацию, будь то объект,
массив, числа/строки и т.д.

Создание переменной и присваивание ей значения

Создаются переменные при помощи ключевого слова, let (кроме let есть еще var,
но он устарел и не рекомендуется его использовать!):

let (имя_переменной);

Имя переменной может содержать только буквы (лучше латинского алфавита),
цифры и символы "$" и "_". При этом первый символ НЕ должен быть цифрой.

Верное объявление:

let age;
let info123;
let i123nfo;
let $size;
let _color;

Неверное объявление:

let 123info;
let my-age;
let 123-my-age;

Чтобы задать переменной значение, надо с новый строки прописать имя переменной
и поставить знак равно, после этого знака мы уже задаем значение:

let number
number = 45

Или

let string
string = "string"

Но, можно написать ещё короче - после создания переменной мы сразу прописываем
знак равно и присваиваем значение:

let children = "Jordan, Anna"

Такой вариант рекомендуется использовать, так как он короче и легче читается.
Ну правда - не надо переводить глаза на новую строку и печатать лишнее.

Кстати, для лучшей читабельности кода названия переменных должны соответствовать их
значениям, ибо другие люди котоыре будут читать наш код не поймут
для чего нам нужна эта переменная.
И правда - допустим мы хотим положить в коробку книжки, и потом отнести
её на склад. Спустя какое-то время нам они понадобились, и мы зашли в склад.
Там полно других коробок и мы будем читать их названия на наклейках,
которые прикреплены к нашим коробкам, чтобы понять какая коробка
нам нужна. Но мы назвали нашу коробку как-то так - "x1dz38", и как нам
теперь понять, что внутри неё лежит?
Чтобы избежать таких проблем, нужно задавать переменным правильные значения.

И раз уж мы заговорили о том, что надо называть переменные более "открыто",
я думаю что стоит поговорить о стилях наименования переменных.

Да-да, существуют СТИЛИ наименования переменных.
Например, CamelCase - «ГорбатыйРегистр», «ВерблюжийРегистр».
Чаще всего используется в JS, реже в других языках программирования.

Как его использовать? - просто бери и используй :D
А если серьезно - то так:

let MyName = "Jordan"

В этом стиле наименования переменных каждое слово начинается с заглавной буквы:

MyName
MyFatherName
MyFatherAndMotherName
т.д.

Но чаще всего используется стиль lowerCamelCase*, который схож с CamelCase, но
отличается от него тем, что первое слово начинается с маленькой
буквы (в отличие от остальных):

myName
myFatherName
myFatherAndMotherName

* - лично я использую именно этот стиль, он мне больше по душе.

Поэтому, вместо...

let s;
let skfkafasafaoapca;
let leftsidebarsize;

...лучше писать так...

let size;
let age;
let leftSideBarSize

... и учитывать регистр...

let height;
let Height;

...ибо регистр в JS имеет значение, и эти две переменные - разные.

Использование других символов

let яПеременная;

Да, помимо латинских символов можно использовать и буквы/символы из других языков,
но так делать не рекомендуется.

*/

// Повтор изученного

// Массивы: что такое массив, как его создавать, его методы и т.д.

/*

Шо такое массив

Массивы - то же самое что и объекты (надеюсь меня не убьют за такие слова),
в них мы можем хранить различные данные - но управлять ими мы можем намного
гибче, нежели в объектах!

И как его создать, массив этот?

Создаются массивы просто - для начала создаем переменную, готовимся поставить
знак равно (оператор присваивания), и после него ставим квадратные скобки.
Но есть и другой, более длинный способ: после знака равно пишем слово new,
затем Array (с большой буквы), после Array сразу ставим круглые скобки и готово.


Заполняем моссев.. мэссив.. маоссэев.. МАССИВ!

Заполняются они также просто, как и создаются. После квадратных скобок мы пишем
любое значение, будь-то числовое или строковое значение, и ставим запятую.
Т.е так: массив = ["значение", "значение", "значение"]. Всё просто!
Но, после последнего значения обычно ставится "висячая" запятая. Она нужна
для того, чтобы если мы будем перемещать элементы (ставить 3-е значение на
место 1-го, и так далее) не возникало никаких ошибок.

Что можно сохранить в массив?

В массиве могут храниться самые-самые разные типы данных - от простейших
чисел до сложных функций и огромных объектов, вот пример такого массива:

let arr = [
    "Коля",
    {
        type: "JS",
        age: 36,
    },
    true,
    function () {
        console.log("Привет, я Коля");
    }
]

Но и это еще не всё - массивы в массиве.
Да, массив может храниться внутри другого! такие массивы называются многомерными,
их элементы такие же массивы как и они сами:

let matrix = [
    [1, 2 ,3],
    [4, 5, 6],
    [7, 8, 9]
]

Получение значений из мОссева!

Вы не поверите (а может и поверите), но мы можем "получить" значение массива и
делать с ним что-то очень интересное! (или не совсем.. кто знает?)
Чтобы получить значение массива, мы прописываем его имя, ставим квадратные
скобки (без пробелов, сразу после имени) и затем внутри квад. скобок пишем
индекс искомого значения. Что такое индекс? - индекс это что-то вроде "позиции"
в массивах и объектах. Важно знать, что индексы начинаются с 0 (да, не с еди-
ницы, а с нуля)! то есть - у первого элемента массива будет нулевой индекс,
у второго - первый, у третьего - второй и т.д:

let arr = ["one", "two", "three"];
console.log(arr[1]);

Код выше создает массив, а затем выводит в консоль слово "two" (т.к индекс
мы указали первый, а первый индекс это элемент №2).
При попытке получить значение, которое не соответствует ни одному значению -
нам выдаст undefined (логично: undefined = не определено).
Получать значения можно также из многомерных мОссевов:

let matrix = [
    [1, 2 ,3],
    [4, 5, 6],
    [7, 8, 9]
]

console.log(matrix[0][1])

Код выше создает мм. массив, затем выводит в консоль цифру 2 (потому что
[0] - первый элемент массива, массив с числами от 1 до 3, а [1] - второй
элемент "дочернего" массива у массива matrix (как бы странно это не звучало)).

Узнаем длину массива, э!

Массивы настолько уникальны, что мы можем УЗНАТЬ ИХ ДЛИНУ! (хотя это не делает
их уникальными.. ну и ладно) Для этого обычно используют свойство length.
Использовать его максимааааааально просто - ставишь точку после названия массива
и готово! вот так вот всё делается:

let arr = [1, 2, 3];
console.log(arr.length);

Код выше выдаст нам цифру 5 в консоль, так как элементов в массиве всего пять.
В общем - простое свойство, очень простое. Ничего сложного в использовании нет.

Доступ к массиву

Я напоминаю, что массив = объект и, следовательно, ведет он себя как и объект.
Напримеееееер... копируется по ссылке!

let arr = ["Ваня", "Иштван", "Оля"];

let arrNew = arr;
arrNew.length = 2;

console.log(arr);
=> ["Ваня", "Иштван"]

Код выше вывел нам 2 элемента, хотя в массиве было целых 3. Так произошло потому,
что: во первых - массив arrNew скопировал массив arr, то же самое можно делать и
с массивами, а во вторых- "length.2" как-бы укоротил наш массив до 2 элементов,
удалив самый последний элемент. Лично я не знаю, кому может понадобиться такая
"способность" объектов и массивов, но... но она всё же есть, и её можно как-то
да использовать. Для меня она пока что бесполезна, вот просто бесполезна.
Кстати, по словам Жеки наш массив (arr) не скопировался! фактически мы не ско-
пировали массив, массив остался один и тот же, просто у нас появилось к нему
два разных ключа (arrNew и arr).

Изменение уже существующих значений массива и добавление новых

Мы можем менять существующие значения массива, на абсолютно новые. Была строка,
а щас число! был объект а щас булевое значение! делается это очень простА:
прописываем название массива, после сразу после него (без пробела) ставим
квадратные скобки и индекс того элемента, который мы хотим заменить. Далее
ставим знак равно (то бишь оператор присваивания) и прописывам новое значение.
Вуаля, значение массива изменено, мир спасен! а выглядит это так:

let arr = ["Ваня", "Иштван", "Оля"];
arr[0] = "Коля";

Вот и всё, ничего сложного! а мы тем временем перейдем к добавлению новых
элементов в массив. Если посмотреть, то в массиве выше всего лишь 3 элемента:
"Ваня", "Иштван" и "Оля", а индексов там всего лишь 3, от 0 до 2.
Если мы хотим добавить новый элемент в массив, то нам необходимо сделать
то же самое, что мы бы сделали если бы хотели изменить какой-то элемент.
Т.е - пишем название массива, квадратные скобки и индекс, знак равно и
значение. Но, тут есть одно очень важное правило - индекс должен
быть не существующим. Что это значит? ну допустим, у нас в массиве выше
всего лишь 3 индекса - 0, 1 и 2. Индекс 0 это "Ваня", индекс 1 это "Иштван",
а индекс 2 это "оля"! следовательно, индекса 3 не существует, его то мы и
пишем в квадратных скобках:

arr[3] = "Ваня";
console.log(arr);
=> ["Коля", "Иштван", "Оля", "Ваня"];

Методы массивов

Шо такое метод мы знаем, но мы не знаем что есть методы для массивов!
Перед тем как разбирать методы, стоит поговорить о вариантах применения
для массивов (или не ДЛЯ, а просто о применении массивов).
Первый из вариантов - очередь, или упорядоченная коллекция элементов.
Очередь поддерживает два вида операций:

1) Добавление элемента в конец очереди
2) Удаление элемента в начале, сдвигая очередь так, что второй элемент
становится первым, третий - вторым и так далее.

Второй вариант применения для массивов - структура данных, называемая "стек".
Стек, ровно также как и очередь, поддерживает два вида операций:

1) Добавление элементв в конец
2) Удаление последнего элемента.

Ну вот! на последок осталось сказать, что массивы в JS могут работать
и как очередь, и как стек. Мы можем добавлять элементы как в начало,
так и в конец массива, или наоборот - удалять их в начале, или в конце
массива. В этом (добавлении и удалении) нам помогут следующие методы:

1) arr.push() - добавление элемента в конец массива

Метод push способен добавлять любой элемент в конец массива, будь то число,
будь то строка или же вообще объект. Но что еще интересней - мы можем добавлять
в массив НЕСКОЛЬКО элементов!!! делается это очень просто, честное мужское слово:

 Создаем массив
let arr = ["Ваня", "Иштван", "Оля"];

 Обращаемся к массиву, применяем метод
arr.push("Вася", "Катя");

 Выводим массив в консоль
console.log(arr);
=> ["Ваня", "Иштван", "Оля", "Вася", "Катя"]

Метод push удобен тем, что позволяет нам изменить уже существующий массив и не
менять его вручную, но как нам быть если мы захотим УДАЛИТЬ элемент В НАЧАЛЕ,
а не в конце? в таком случае нам понадобится новый метод!

2) arr.shift() - удаляет (а не добавляет) элемент в начале массива, так что второй
эллемент становится первым, третий становится вторым и так далее

Метод shift способен удалить элемент в начале массива... и всё. Не думаю что нужно
как-то детально разъяснять принцип его действия, всё ясно уже из описания. А, да -
при удалении элемента соответственно изменится и длина всего массива (length), а
второй элемент становится первым, третий становится вторым, четвертый становится
третьим и так далее. Использовать его необходимо без передачи аргументов, то есть
просто поставить круглые скобки и всё. Так как мы не добавляем этим методом ни-
каких элементов в массив, используется метод без передачи аргументов :)

 Создаем массив
let arr = ["Ваня", "Иштван", "Оля"];

 Обращаемся к массиву, применяя метод
arr.shift();

 Выводим массив в консоль
console.log(arr);
=> ["Иштван", "Оля"]

Также очень полезный метод, который довольно часто (по словам Жеки) используется
в чистом JavaScript'е и в верстке (понятия не имею, как его применить в верстке).
Это всё хорошо, мы научились добавлять элементы в конец массива и удалять в начале,
но как нам удалить элемент В КОНЦЕ, а не в начале? в этом нам поможет следующий метод!

3) arr.pop(); - удаляет последний элемент в массиве

Объяснять работу метода - не нужно. Он работает точно также как и shift, отличия лишь
в том, что элементы массива остаются на месте, а не сдвигаются. Т.е первый элемент
останется первым, второй останется вторым и так далее, изменится только длина массива.
Применять метод нужно также без передачи аргументов.

 Создаем массив
let arr = ["Ваня", "Иштван", "Оля"];

 Обращаемся к массиву, применяя метод
arr.pop();

Выводим массив в консоль
console.log(arr);
=> ["Ваня", "Иштван"]

Ничего интересного, простое удаление последнего элемента массива.
А что если нам нужно добавить элемент, или несколько элементов в начало массива?
В этом нам также поможет следующий метод!

4) arr.unshift(); - добавляет элемент(ы) в начало массива

Этот метод похож на push, отличие лишь в том, что он добавляет элементы В НАЧАЛО,
а не в конец, как push. Использвать его нужно также, как и push - в круглые скобки
вписываем те элементы, которые хотим отправить в массив.

 Создаем массив
let arr = ["Ваня", "Иштван", "Оля"];

 Обращаемся к массиву, применяя метод
arr.unshift("Вася, Катя");

 Выводим массив в консоль
console.log(arr);
=> ["Вася", "Катя", "Ваня", "Иштван", "Оля"]

Вот и всё. С методами мы покончили! Но осталось еще кое что, что мы должны знать.
А знать мы должны то, что shift и unshift - медлительны, а push и pop - быстры.
Давайте разбираться.

Жажда скорости: метод = машина

Все мы знаем, что есть два типа машин: быстрые и не быстрые. Быстрыми зачастую
оказываются гоночные машины, т.к они заднеприводные, но бывают и исключения.. но
сейчас не об этом, не о машинах мы будем говорить (точнее - не о машинах буду писать).
Всё дело в том, что push и pop быстрее, чем shift и unshift.

Почему? а щас расскажу! рассмотрим эту тему на примере добавления элемента в начало
массива (unshift) - просто взять и добавить элемент с индексом "0" в начало массива
не достаточно, здесь всё делается по другому:

Операция unshift выполняет сразу 3 действия:
1) Добавить элемент с индексом "0" в начало массива
2) Сдвинуть все элементы вправо, затем заново пронумеровать их, заменив 0 на 1, 1
на 2, 2 на 3 и так далее.
3) Полностью обновить свойство length.

А теперь подумайте - что если добавляемых элементов очень много, а массив содержит
в себе и без того не малое количество элементов? а это всё надо добавлять, нумеровать
заново, проверить и обновить свойство length.. кошмар! в этом и вся соль: чем больше
хранит в себе элементов массив, тем больше времени потребуется для того, чтобы их
переместить. Это, в свою очередь, значит, что понадобится больше операций с памятью!
А вот чтобы добавить элемент в конец массива (push) не нужно ничего перемещать и
заново нумеровать, достаточно увеличить значение свойства length на количество
добавляемых элементов в массив. То же самое и с pop - просто удаляешь элемент в
конце массива, нужно просто изменить свойство length! ничего сложного, правда? :)

Удаление, добавление и изменение конкретных элементов

Мы с вами уже знаем как добавлиять, удалять элементы в начале и конце массива,
но мы не можем делать то же самое С КОНКРЕТНЫМИ ЭЛЕМЕНТАМИ. Т.е - мы не знаем
как добавить (или удалить) элемент в середину(не) массива, или как его изменить,
например. Но это всё не проблема! совсем скоро мы станем гуру по управлению
массивами, и сможем делать с ними всё (почти) что захотим! начнем с директивы
delete, из уроков про объекты. Если вы еще не забыли, то директива delete в
буквальном смысле СТИРАЕТ элемент в объекте. Но так как у массивов и объектов
есть много чего общего (они дальние родственники, так сказать), эта директива
работает не только с объектами - она работает и с массивами! пример:

let arr = ["Ваня", "Иштван", "Оля"];
delete arr[1];

console.log(arr);
=> ["Ваня", empty, "Оля"]
console.log(arr[1]);
=> undefined
console.log(arr.length);
// => 3

И так. Что же произошло? ну.. элемент номер 1 (тот что по середине) удалился,
но... но его заменил другой элемент! как так? на самом деле этого элемента НЕТ,
но он ЕСТЬ. Звучит странно, но оно так. Если мы возьмем и выведем в консоль сам
массив, то мы можем заметить надпись "empty", а если мы возьмем и выведем в
консоль этот элемент - окажется что его нет! нам выдаст "undefined". Если же
мы возьмем и проверим ДЛИНУ массива, то окажется что внутри него 3 элемента,
то есть нам выдаст цифру 3. Корочеее... странные вещи с delete'ом происходят.

Метод splice.

Так как директива delete работает.. мягко говоря, странно, мы должны изучить
другие методы по добавлению/удалению/изменению элементов. Первым методом
будет splice, который способен заменить ВСЕ другие методы. Дело в том, что
благодаря нему мы можем и удалять, добавлять и изменять элементы в массиве!

Синтаксис прост: arr.splice(index[, deleteCount, elem1, ... elemN])

Первым делом, в круглых скобках указываем индекс элемента в массиве, дальше
мы записываем индекс элемента, до которого будет идти удаление, добавление
или изменение. Третий аргумент можно и не добавлять: это элемент или элементы,
которые мы будем добавлять в массив или заменять ими другие.
Вот все примеры использования метода splice:

 1) - удаление элемента
let arr = ["Ваня", "Иштван", "Оля"];
arr.splice(1, 1);
console.log(arr);
=> ["Ваня", "Оля"]

 2) - "перенос" элемента в другую переменную
let arr = ["Ваня", "Иштван", "Оля"];
let removedElement = arr.splice(1, 1);
console.log(removedElement, arr);
=> ["Иштван"],
   ["Ваня", "Оля"]

 3) - замена элемента
let arr = ["Ваня", "Иштван", "Оля"];
arr.spice(0, 1, "Коля");
console.log(arr);
=> ["Коля", "Иштван", "Оля"]

 4) - добавление элемента
let arr = ["Ваня", "Иштван", "Оля"]
arr.splice(1, 0, "Коля", "Маша");
console.log(arr);
=> ["Ваня", "Коля", "Маша", "Иштван", "Оля"]

 5) - удаление элемента (с конца)
let arr = ["Ваня", "Иштван", "Оля"]
arr.splice(-1, 1);
console.log(arr);

И так, сейчас я объясню, что и где произошло...

Но не сегодня, а.. позже!)

*/