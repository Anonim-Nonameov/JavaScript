// Важная информация

// Этот JS файл создан для повторения прошлых уроков. Т.е - здесь я буду повторять
// все свои прошлые уроки. Как это будет происходить? - повтор будет происходить
// 1 раз через урок. Т.е - сделал урок, прошло какое-то время (2 дня), теперь делаю
// вместо него повтор. Всё то же самое, что и с уроками по JS от "ФЛС", он же Жека.

// --------------------------------------------------------------------------------

// Типы данных и взаимодействие с пользователем

// Итак. Что такое типы данных в JS? по простому, это та информация, которую мы
// можем использовать в своих скриптах, и эта информация может быть чем угодно.
// У этой информации есть своя классификация, её можно найти в интернете.
// Но так как вам может быть лень гуглить эту классификацию, оставлю её здесь:

/*

Простые типы                    Объекты                      Обычные объекты
------------                    -------
Числа - 1, 2, 3	 		   	 	Массивы
Строки - "text"            	 	Функции
Логический тип - true/false 	Объект даты
null                       		Регулярные выражения
undefined                  		Ошибки
Symbol
Bigint

*/

// Мы с течением времени будем потихоньку разбирать каждый тип данных, даже
// это займет у нас не мало времени. Начнем с того, что конечно же все типы
// данных разделяются на две небольшие группы: простые типы и сложные, ком-
// плексные, или же по другому они называются объекты. Начнем мы с простых
// типов, т.к комплексные типы данных трудно изучать и там много информации:
// первым у нас идет тип "Числа", пожалуй один из самых прос-тейших типов
// данных в JavaScript'е. Благодаря нему мы можем обозначать номер по порядку:
// 1, 2, 3; либо считать сумму зарплаты за месяц: 1000, 2000, 3000 и так далее.
// Следующим типом данных являются строки. Я думаю, что ни для кого не секрет,
// что если я напишу какое-то выражение, например "Text", это не будет числом:
// это будет некое описание, то есть то что мы может написать как обычную стро-
// ку. Так что если мы что-то пишем как обычный текст, то это будет строкой.
// Давайте создадим простую переменную "myName", значением которой будет "Alex":

let myName = 'Alex';

// Отлично! теперь эта переменная содержит в себе строку. Стоит отметить, что
// строки всегда записываются в кавычках. В JavaScript'е нет разницы между тем,
// какие кавычки вы используете: одинарные (''), двойные ("") или обратные (``).
// Если я запишу ту же строку "Alex" в одинарных кавычках - она останется строкой,
// то же самое будет и с обратными кавычками. Кстати, заметили ли вы как я назвал
// переменную выше? а назвал я её используя стиль "CamelCase"! в JS существует
// огромное множество стилей наименования переменных, одним из которых является
// camelCase, он же "ВерблюжийРегистр". Если название переменной состоит из не-
// кольких слов, то каждая первая буква в слове будет прописана как заглавная.
// То есть: "my new variable" будет записано как "MyNewVariable". Но использовал
// я схожий с "CamelCase" стиль - "lowerCamelCase". Этот стиль почти ничем не
// отличается от "CamelCase", разве что тем, что первое слово в названии пере-
// менной будет написано с строчной буквы. То есть: "my new variable" будет за-
// писано как "myNewVariable". lowerCamelCase используется чаще чем camelCase,
// так как он выглядит более приятным глазу (по моему мнению). Кстати, обратные
// кавычки также называют "бектиками", и при помощи бектиков мы можем делать кое
// что очень интересное! но об этом позже, сейчас рано говорить о таких вещах.

// Следующий тип данных - булевый, он же логический тип данных. Содержит он
// в себе либо правду, либо ложь. Что это значит? давайте создадим простейшую
// реальную конструкцию: если вы сейчас читаете этот текст на компьютере, то вы,
// в принципе, должны сказать, что да, это правда. Если с мобильного телефона -
// то это будет ложь, false, не правда. В принципе всё верно - на телефоне этот
// текст вы бы вряд-ли прочитали, ведь чтобы прочитать его вам бы пришлось
// заходить в гитхаб, так как только там есть копия этого файла.. но не суть.
// Такие логические утверждения как раз таки и будут работать в нашем коде.
// Например, в коде мы можем проверять, открыто ли у пользователя модальное окно.
// Если вдруг оно открыто, то мы получаем булевое значение true, то есть "правда",
// и в зависимости от этого ответа мы можем какие-то действия выполнять, а какие
// то наоборот запрещать. Например, если модальное окно будет открыто, то мы
// можем запретить скролл подложки, то есть всего сайта, а когда его закроем то
// можно будет вновь скроллить. Если же говорить о коде, то мы можем создать
// переменную... ну, bool например, и задать ей значение true, то бишь правду:

let bool = true;

// Или наоборот, задать переменной значение false, то бишь ложь:

bool = false;

// Отлично, идем к следующему... нет, к следуюЩИМ типам данных. А дальше у нас
// два таких "философских" типов данных, как сказал лектор - null и undefined.
// Различать их довольно просто - главное понять как они работают, и в этом и
// заключается вся сложность:

// null - это когда чего-то просто НЕ СУЩЕСТВУЕТ.
// undefined - это когда что-то существует, но значения никакого вообще не имеет.

// Разберем всё это на реальном примере. Допустим, что я хочу поместить в перемен-
// ную modal строку 'string':

// modal = "string";

// Или, например, вывести в браузере диалоговое окошко со значением переменной a:

// alert(a);

// А теперь пересмотрите весь этот  файл и попытайтесь найти такие переменные.
// Вы конечно же не найдете ни одну из этих переменных - их просто нет! если
// такой скрипт выполнить, заходя в браузер, нам выдаст в консоли вот такую
// надпись: "Uncaught ReferenceError: a is not defined". Отлично, а теперь
// возьмем другой пример. Код на 98 строке, где мы меняли значение переменной
// modal, я закомментировал, так как он будет нам мешать. Код на 102-ой строке
// также закомментирован. Давайте создадим переменную modal, но значения ей
// мы не присвоим:

let modal;

// Отлично, мы создали переменную, но она пуста. Что это значит? мы взяли и
// подписали коробку, но она пуста - значения в переменной нет! на данный момент
// её значение равно undefined, так как переменная ЕСТЬ, но ЗНАЧЕНИЯ НЕ ИМЕЕТ.
// Чуть позже мы узнаем, как получить это значение в консоль. Опять же - заметьте,
// что null и undefined - два разных типа данных! и конечно, вопросы о null и
// undefined часто задают на собеседованиях, чтобы понять, ориентируетесь вы в
// этой теме вообще или нет. А так, тема о null и undefined в целом легкая.
// Если же говорить о двух оставшихся типов данных, то на сегодняшний день они
// считаются более-менее новыми, и появились они, ну.. относительно недавно. Это
// Symbol и Bigint. Symbol это технический тип данных, который появился в стан-
// дарте ES6, поэтому вы вряд-ли с ним когда-то да столкнетесь, так что пока про-
// сто знайте что он есть. А вот такой тип данных как Bigint появился не так уж
// и давно - летом 2019-го года. Если говорить по простому, то Bigint это просто
// ОГРОМНЫЕ числа, которые не влезают в допустимый диапазон чисел. Bigint, также
// расшифровываемый как big integer, это числа, которые больше чем 2 в 53 степени.
// Дело в том, что в обычном типе данных "Number" есть, так сказать, лимит. Если
// использовать такие огромные числа с обычном типом данных "Number", могут возник-
// нуть ошибки. Именно поэтому в JS был введен новый (почти) тип данных, Bigint.
// И как раз в него включаются все эти огромные числа, не влезающие в диапазон
// доступных. Естественно, при работе с такими огромными числами используя этот
// тип данных никаких ошибок у нас возникать не будет - для них создан тип данных!

// Следующие типы данных - объекты и массивы. Начнем с простых примеров, что же
// такое объекты и что такое массивы.

// 1) - Объекты

// Сначала возьмем какую нибудь информацию.. апельсин, например. Теперь подумайте -
// как мы можем его описать? ну, во 1-ых, его категория - фрукт. Еще можно сказать,
// что его форма - круглая, цвет - оранжевый, а вес, например, 300 грамм. Соответ-
// ственно сейчас мы с вами описали некий предмет, элемент, и то же самое можно
// сделать в коде. "Как", вы спросите, а я вам отвечу - при помощи объектов! в коде
// мы можем описать ЛЮБОЙ предмет или что нибудь еще при помощи конструкции под наз-
// ванием "объект". Объекты состоят из двух внутренний категорий - свойства и методы,
// или как их еще (иногда) называют ключи и значения. Чуть выше мы описали ВСЕ СВОЙ-
// СТВА апельсина, т.е что он в себя включает или как его можно описать. И я думаю
// вы уже заметили (если вы, конечно, очень внимательный человек), что объект как
// комплексный (сложный) тип данных может содержать в себе разные типы данных. Почему
// я так решил? а потому, что на примере апельсина мы (я) показали (показал), что он
// какого цвета? правильно - ОРАНЖЕВОГО, каков его вес? правильно - 300 грамм! Соот-
// ветственно, можно даже писать объект в объекте в объекте в объекте, такое тоже воз-
// можно :D И также я сказал, что объекты содержат в себе МЕТОДЫ. То есть любая конс-
// трукция может что-то делать, но только не апельсин - максимум сгнить :) поэтому возь-
// мем другой пример - пылесос! пылесос как объект можно описать следующими способами:
// его модель, его вес, его мощность всасывания. Но вот он, в отличии от апельсина,
// умеет что-то делать. Например... пылесосить ваш пол, как бы странно это не зву-
// чало! и, конечно же, так далее. Соответственно, как вы уже поняли (я надеюсь),
// объекты cлужат нам для того, чтобы мы могли какие-то сущности полностью описывать.
// Эти сущности, кстати, могут быть и на вашем сайте - возьмем простое модальное
// окно. Мы можем описать его ширину, высоту, то что он умеет делать (отправлять
// формы, закрываться и прочее-прочее). Таким образом, при помощи объекта как
// комплексного типа данных мы можем всё это очень красиво и опрятно организовать.
// Надеюсь, что с этим всё понятно, а чуть позже я покажу всё это в реальном коде.

// 2) - Массивы

// Вы должны запомнить - массивы это частный случай объектов, или говоря простыми
// словами - его потомок, дальний родственник или как-то так. Это НЕ отдельный тип
// данных. А теперь к сути, что такое массив ВООБЩЕ? ответ прост - это конструкция,
// которая позволяет нам записать какие-то данные ПО ПОРЯДКУ, строго ПО ПОРЯДКУ.
// Что это значит? допустим, вы берете одну вещь и хотить записать её в массив,
// записали и поставили запятую, затем добавили вторую вещь и также записываете
// в массив, ставя запятую, и только затем третий элемент. У вас строгий порядок
// этих элементов. И, соответственно, нам абсолютно не важно какие это элементы -
// это могут быть строки, это могут быть числа, это могут быть объекты, массивы
// или вообще какие нибудь функции. Так что, здесь массивы служат для расположения
// элементов (вообще любой информации) строго по порядку, и это их основное предназ-
// начение. Как реальный пример, мы с вами можем взять и написать список ссылок
// на картинки, чтобы в будущем их использовать, или список заголовков, параграфов
// и так далее. Чуть позже я расскажу, как это применяется на реальных проектах.

// С теорией покончено, надеюсь вам всё стало ясно. Дальше дело практики...

// Но практиковаться мы будем чуууть позже :)