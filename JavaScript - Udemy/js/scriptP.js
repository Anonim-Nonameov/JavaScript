// Важная информация

// Этот JS файл создан для повторения прошлых уроков. Т.е - здесь я буду повторять
// все свои прошлые уроки. Как это будет происходить? - повтор будет происходить
// 1 раз через урок. Т.е - сделал урок, прошло какое-то время (2 дня), теперь делаю
// вместо него повтор. Всё то же самое, что и с уроками по JS от "ФЛС", он же Жека.

// --------------------------------------------------------------------------------

// Типы данных и взаимодействие с пользователем

// Итак. Что такое типы данных в JS? по простому, это та информация, которую мы
// можем использовать в своих скриптах, и эта информация может быть чем угодно.
// У этой информации есть своя классификация, её можно найти в интернете.
// Но так как вам может быть лень гуглить эту классификацию, оставлю её здесь:

/*

Простые типы                    Объекты                      Обычные объекты
------------                    -------
Числа - 1, 2, 3	 		   	 	Массивы
Строки - "text"            	 	Функции
Логический тип - true/false 	Объект даты
null                       		Регулярные выражения
undefined                  		Ошибки
Symbol
Bigint

*/

// Мы с течением времени будем потихоньку разбирать каждый тип данных, даже
// это займет у нас не мало времени. Начнем с того, что конечно же все типы
// данных разделяются на две небольшие группы: простые типы и сложные, ком-
// плексные, или же по другому они называются объекты. Начнем мы с простых
// типов, т.к комплексные типы данных трудно изучать и там много информации:
// первым у нас идет тип "Числа", пожалуй один из самых прос-тейших типов
// данных в JavaScript'е. Благодаря нему мы можем обозначать номер по порядку:
// 1, 2, 3; либо считать сумму зарплаты за месяц: 1000, 2000, 3000 и так далее.
// Следующим типом данных являются строки. Я думаю, что ни для кого не секрет,
// что если я напишу какое-то выражение, например "Text", это не будет числом:
// это будет некое описание, то есть то что мы может написать как обычную стро-
// ку. Так что если мы что-то пишем как обычный текст, то это будет строкой.
// Давайте создадим простую переменную "myName", значением которой будет "Alex":

let myName = 'Alex';

// Отлично! теперь эта переменная содержит в себе строку. Стоит отметить, что
// строки всегда записываются в кавычках. В JavaScript'е нет разницы между тем,
// какие кавычки вы используете: одинарные (''), двойные ("") или обратные (``).
// Если я запишу ту же строку "Alex" в одинарных кавычках - она останется строкой,
// то же самое будет и с обратными кавычками. Кстати, заметили ли вы как я назвал
// переменную выше? а назвал я её используя стиль "CamelCase"! в JS существует
// огромное множество стилей наименования переменных, одним из которых является
// camelCase, он же "ВерблюжийРегистр". Если название переменной состоит из не-
// кольких слов, то каждая первая буква в слове будет прописана как заглавная.
// То есть: "my new variable" будет записано как "MyNewVariable". Но использовал
// я схожий с "CamelCase" стиль - "lowerCamelCase". Этот стиль почти ничем не
// отличается от "CamelCase", разве что тем, что первое слово в названии пере-
// менной будет написано с строчной буквы. То есть: "my new variable" будет за-
// писано как "myNewVariable". lowerCamelCase используется чаще чем camelCase,
// так как он выглядит более приятным глазу (по моему мнению). Кстати, обратные
// кавычки также называют "бектиками", и при помощи бектиков мы можем делать кое
// что очень интересное! но об этом позже, сейчас рано говорить о таких вещах.

// Следующий тип данных - булевый, он же логический тип данных. Содержит он
// в себе либо правду, либо ложь. Что это значит? давайте создадим простейшую
// реальную конструкцию: если вы сейчас читаете этот текст на компьютере, то вы,
// в принципе, должны сказать, что да, это правда. Если с мобильного телефона -
// то это будет ложь, false, не правда. В принципе всё верно - на телефоне этот
// текст вы бы вряд-ли прочитали, ведь чтобы прочитать его вам бы пришлось
// заходить в гитхаб, так как только там есть копия этого файла.. но не суть.
// Такие логические утверждения как раз таки и будут работать в нашем коде.
// Например, в коде мы можем проверять, открыто ли у пользователя модальное окно.
// Если вдруг оно открыто, то мы получаем булевое значение true, то есть "правда",
// и в зависимости от этого ответа мы можем какие-то действия выполнять, а какие
// то наоборот запрещать. Например, если модальное окно будет открыто, то мы
// можем запретить скролл подложки, то есть всего сайта, а когда его закроем то
// можно будет вновь скроллить. Если же говорить о коде, то мы можем создать
// переменную... ну, bool например, и задать ей значение true, то бишь правду:

let bool = true;

// Или наоборот, задать переменной значение false, то бишь ложь:

bool = false;

// Отлично, идем к следующему... нет, к следуюЩИМ типам данных. А дальше у нас
// два таких "философских" типов данных, как сказал лектор - null и undefined.
// Различать их довольно просто - главное понять как они работают, и в этом и
// заключается вся сложность:

// null - это когда чего-то просто НЕ СУЩЕСТВУЕТ.
// undefined - это когда что-то существует, но значения никакого вообще не имеет.

// Разберем всё это на реальном примере. Допустим, что я хочу поместить в перемен-
// ную modal строку 'string':

// modal = "string";

// Или, например, вывести в браузере диалоговое окошко со значением переменной a:

// alert(a);

// А теперь пересмотрите весь этот  файл и попытайтесь найти такие переменные.
// Вы конечно же не найдете ни одну из этих переменных - их просто нет! если
// такой скрипт выполнить, заходя в браузер, нам выдаст в консоли вот такую
// надпись: "Uncaught ReferenceError: a is not defined". Отлично, а теперь
// возьмем другой пример. Код на 98 строке, где мы меняли значение переменной
// modal, я закомментировал, так как он будет нам мешать. Код на 102-ой строке
// также закомментирован. Давайте создадим переменную modal, но значения ей
// мы не присвоим:

let modal;

// Отлично, мы создали переменную, но она пуста. Что это значит? мы взяли и
// подписали коробку, но она пуста - значения в переменной нет! на данный момент
// её значение равно undefined, так как переменная ЕСТЬ, но ЗНАЧЕНИЯ НЕ ИМЕЕТ.
// Чуть позже мы узнаем, как получить это значение в консоль. Опять же - заметьте,
// что null и undefined - два разных типа данных! и конечно, вопросы о null и
// undefined часто задают на собеседованиях, чтобы понять, ориентируетесь вы в
// этой теме вообще или нет. А так, тема о null и undefined в целом легкая.
// Если же говорить о двух оставшихся типов данных, то на сегодняшний день они
// считаются более-менее новыми, и появились они, ну.. относительно недавно. Это
// Symbol и Bigint. Symbol это технический тип данных, который появился в стан-
// дарте ES6, поэтому вы вряд-ли с ним когда-то да столкнетесь, так что пока про-
// сто знайте что он есть. А вот такой тип данных как Bigint появился не так уж
// и давно - летом 2019-го года. Если говорить по простому, то Bigint это просто
// ОГРОМНЫЕ числа, которые не влезают в допустимый диапазон чисел. Bigint, также
// расшифровываемый как big integer, это числа, которые больше чем 2 в 53 степени.
// Дело в том, что в обычном типе данных "Number" есть, так сказать, лимит. Если
// использовать такие огромные числа с обычном типом данных "Number", могут возник-
// нуть ошибки. Именно поэтому в JS был введен новый (почти) тип данных, Bigint.
// И как раз в него включаются все эти огромные числа, не влезающие в диапазон
// доступных. Естественно, при работе с такими огромными числами используя этот
// тип данных никаких ошибок у нас возникать не будет - для них создан тип данных!

// Следующие типы данных - объекты и массивы. Начнем с простых примеров, что же
// такое объекты и что такое массивы.

// 1) - Объекты

// Сначала возьмем какую нибудь информацию.. апельсин, например. Теперь подумайте -
// как мы можем его описать? ну, во 1-ых, его категория - фрукт. Еще можно сказать,
// что его форма - круглая, цвет - оранжевый, а вес, например, 300 грамм. Соответ-
// ственно сейчас мы с вами описали некий предмет, элемент, и то же самое можно
// сделать в коде. "Как", вы спросите, а я вам отвечу - при помощи объектов! в коде
// мы можем описать ЛЮБОЙ предмет или что нибудь еще при помощи конструкции под наз-
// ванием "объект". Объекты состоят из двух внутренний категорий - свойства и методы,
// или как их еще (иногда) называют ключи и значения. Чуть выше мы описали ВСЕ СВОЙ-
// СТВА апельсина, т.е что он в себя включает или как его можно описать. И я думаю
// вы уже заметили (если вы, конечно, очень внимательный человек), что объект как
// комплексный (сложный) тип данных может содержать в себе разные типы данных. Почему
// я так решил? а потому, что на примере апельсина мы (я) показали (показал), что он
// какого цвета? правильно - ОРАНЖЕВОГО, каков его вес? правильно - 300 грамм! Соот-
// ветственно, можно даже писать объект в объекте в объекте в объекте, такое тоже воз-
// можно :D И также я сказал, что объекты содержат в себе МЕТОДЫ. То есть любая конс-
// трукция может что-то делать, но только не апельсин - максимум сгнить :) поэтому возь-
// мем другой пример - пылесос! пылесос как объект можно описать следующими способами:
// его модель, его вес, его мощность всасывания. Но вот он, в отличии от апельсина,
// умеет что-то делать. Например... пылесосить ваш пол, как бы странно это не зву-
// чало! и, конечно же, так далее. Соответственно, как вы уже поняли (я надеюсь),
// объекты cлужат нам для того, чтобы мы могли какие-то сущности полностью описывать.
// Эти сущности, кстати, могут быть и на вашем сайте - возьмем простое модальное
// окно. Мы можем описать его ширину, высоту, то что он умеет делать (отправлять
// формы, закрываться и прочее-прочее). Таким образом, при помощи объекта как
// комплексного типа данных мы можем всё это очень красиво и опрятно организовать.
// Надеюсь, что с этим всё понятно, а чуть позже я покажу всё это в реальном коде.

// 2) - Массивы

// Вы должны запомнить - массивы это частный случай объектов, или говоря простыми
// словами - его потомок, дальний родственник или как-то так. Это НЕ отдельный тип
// данных. А теперь к сути, что такое массив ВООБЩЕ? ответ прост - это конструкция,
// которая позволяет нам записать какие-то данные ПО ПОРЯДКУ, строго ПО ПОРЯДКУ.
// Что это значит? допустим, вы берете одну вещь и хотить записать её в массив,
// записали и поставили запятую, затем добавили вторую вещь и также записываете
// в массив, ставя запятую, и только затем третий элемент. У вас строгий порядок
// этих элементов. И, соответственно, нам абсолютно не важно какие это элементы -
// это могут быть строки, это могут быть числа, это могут быть объекты, массивы
// или вообще какие нибудь функции. Так что, здесь массивы служат для расположения
// элементов (вообще любой информации) строго по порядку, и это их основное предназ-
// начение. Как реальный пример, мы с вами можем взять и написать список ссылок
// на картинки, чтобы в будущем их использовать, или список заголовков, параграфов
// и так далее. Чуть позже я расскажу, как это применяется на реальных проектах.

// С теорией покончено, надеюсь вам всё стало ясно. Дальше дело практики.
// Если рассматривать с позиции кода, объекты создаются просто: просто создаем
// любую коробку (то есть переменную), даем ей имя и раскрываем фигурные скобки.
// Мы можем его даже не заполнять, это УЖЕ считается как объект, правда пустой.
// Но если нам внутри нужна какая-то информация, мы записываем название свойства
// (важно - название свойства должно описывать его значение), ставим двоеточие и
// прописываем само значение. Значение может быть любым - строка, число, булевое
// значение, массив и даже другой объект! но если мы хотим чтобы у нас было еще
// и второе, или даже третье свойство со своим значением, мы ставим запятую после
// того, как написали значение свойству. Пример такого объекта:

// obj - сокращение от object (объект по англ.)
let obj = {
	dog: 'Puppey',
	cat: "Murrr"
}

// Всё, наш объект готов. Но следует отметить, что у него сейчас есть только
// свойства со значениями, а то, что он будет УМЕТЬ делать, мы разберем позже,
// когда речь пойдет о функциях. А теперь о массивах!

// Если говорить о массивах как о таком.. специфическом объекте, то он служит
// непосредственно для того, чтобы данные в нем располагались по порядку. А в
// коде это выглядит примерно так: мы также как и в случае с объектами создаем
// простую коробку (переменную), даем ей название и ставим квадратные скобки.
// И здесь то же самое, что и с объектами - а только поставлены квад. скобки,
// он УЖЕ является массивом. Но опять же - он пустой. Как только мы поставили
// квадратные скобки, можем наполнять его значениями. Опять же - значением
// массива может быть абсолютно что угодно, точно как и в объектах. Разделение
// происходит также через запятую. Пример массива:

// arr - сокращение от array (массив по англ.)
let arr = [1, 'str', false];

// Вот и всё! массив создан. Но имея массив, мы можем выполнять некоторые опе-
// -рации по его "модернизации" (цитата, лектор). Например, если я хочу получить
// лемент под индексом №1 (то есть первый элемент), то я прописываю слово arr
// (то есть название нашего массива), ставлю квадратные скобки и внутрь вписываю
// число 0. Но вы спросите: "почему 0, если нам нужен ПЕРВЫЙ элемент?", а я вам
// отвечу так - в JS нумерация начинается с нуля. Так вот - после всего этого я
// могу и ИЗМЕНИТЬ этот элемент! для этого я ставлю знак равенства (т.е оператор
// присваивания) и прописываю новое значение, например - 2:

// Запись эквивалентна следующей: let arr = [2, 'str', false], т.к мы изменили
// первый элемент (1) на другой (2) 
arr[0] = 2;

// Отлично! а теперь мы научимся пользоваться консолью. Для того чтобы написать
// туда хоть что нибудь, мы воспользуемся командой "console.log()". Вообще, это
// простейший способ тестирования своего кода. Например, мы можем вывести туда
// значение своей переменной в данный момент. Чтобы это сделать, прописываем эту
// команду и внутри круглых скобок вписываем любую информацию, например нашу
// старую переменную modal, которую мы создавали еще в начале (но не забываем ;):

console.log(modal);
// => undefined

// Заходим в консоль (Браузер - HTML файл, к которому привязан скрипт - CTRL +
// SHIFT + I/ F12 - Console), смотрим - а там у нас undefined! справа от него
// даже указано, на какой строке мы "отправили" значение переменной modal в эту
// консоль (в нашем случае это 240). Кстати, значение переменной modal равно
// undefined потому, что переменная ЕСТЬ, мы её создали, НО ЗНАЧЕНИЯ ОНА НЕ
// ИМЕЕТ, абсолютно. И это как раз один из тех типов данных, о которых мы еще
// в начале говорили. А если вывести в консоль значение переменной myName?
// её мы еще в самом начале создавали (также, как и modal), и я помню что у неё
// было какое-то значение. В любом случае мы это сейчас узнаем! -

console.log(myName);
// => "Alex";

// В консоль мы получили строку Alex, и правильно - у переменной myName такое
// значение! И кстати, JS "прощает" нам некоторые ошибки которые мы допускаем
// в коде, потому что он был придуман для "не программистов", как я уже когда
// то давно говорил. Поэтому попробуем сделать какую-то неочевидную операцию
// и вывести её в консоль:

console.log(4/0)
// => Infinity

// Мы знаем, что на 0 делить НЕЛЬЗЯ, но в консоли мы получаем Infinity. Так что
// если у нас произошла какая-то не математическая операция, то что сделать дей-
// -ствительно нельзя, то у нас не вылезет ошибка, а выйдет специальное значение
// под названием Infinity. Кстати, можно получить также "минус бесконечность":
// для этого просто делим отрицательное четыре на ноль -

console.log(-4/0);
// => -Infinity

// Ну вот, как я и говорил (писал) - минус бесконечность и плюс радости в штанах!
// Такая вот защита "от дурака". Кстати, значение Infinity по классификации ухо-
// -дит к числам, т.е это по факту число. Кроме этого, кстати, есть еще один
// возможный вариант когда у нас всё отходит от нормальной логики. Когда мы
// с вами возьмем и какую-то строку попробуем умножить на.. ну, 9 например.

console.log('string' * 9);
// => NaN

// В консоль нам выдало специальное значение, которое называется NaN (not a num),
// то есть буквально "не число". NaN нам выдает тогда, когда мы совершаем подоб-
// -ные не математические операции, например умножаем строку на число и так далее.
// И кстати, NaN расшифровывается как "не число", но по факту он восходит к типу
// данных "числа", number. Парадокс! И кстати, вы заметили, что мы недавно приме-
// -нили самые простые математические конструкции - что-то делили или умножали?
// В JavaScript'е эти математические знаки операций называются просто - опе-
// -раторы. Оператор деления, оператор умножения и так далее, большинство опе-
// -раторов это математические знаки, такие как плюс, минум и прочие. Сразу вам
// скажу - большинство из них редко/крайне редко используемые, так что на многие
// операторы даже не стоит обращать внимания. Понимание того, на что следует
// обращать внимание а на что нет придет со временем, по мере роста в языке,
// а мы продолжаем. Знаки присваивания, деления и умножения не такие уж и инте-
// -ресные, как инкремент и декремент! но о нем позже, конечно же. Помните, как
// в начальных уроках я писал, что знак равно на самом деле не знак равно (стран-
// -но звучит, да), а знак присваивания, который используется когда мы что-то
// помещаем в переменную? так вот, в JS есть и другие знаки, которые очень по-
// -хожи на оператор присваивания. Например, если я хочу проверить: 2 + 2 = 4;
// и напишу так:

// Закомментировано!
// console.log(2 + 2 = 4);
// => Uncaught SyntaxError: ...

// Нам выдаст ошибку синтаксиса! мы не можем какому-то выражению ПРИСВОИТЬ 4-ку.
// Для того чтобы сравнить это выражение с четверкой, нам надо поставитьь 2-ой
// знак равенства и... всё заработает:

console.log(2 + 2 == 4);
// => true

// Этот оператор называется "оператор сравнения". При сравнивании этого выраже-
// -ния. Но мы можем пойти дальше и поставить еще один оператор присваивания:

console.log(2 + 2 === 4);
// => true

// В таком случае значение не изменится - как true стояло так и стоит. Но этот
// оператор сравнения "строгий", он даже называется "оператор строг. сравнения".
// Почему? всё просто - он сравнивает еще и типы данных у элементов. Давайте
// проведем интересный эксперимент:

console.log(2 + "2" == 4);
// => false

// При сравнении такого выражения мы получаем false, это очевидно. У нас при
// сложении двойки в виде числа и двойки в виде строки выйдет не 4 а "22", но
// об этом позже, к этой теме мы еще вернемся. Хорошо, а теперь сравниваем 4
// в виде строки и 4 в обыкновенном виде (в виде числа)? сейчас узнаем!

console.log("4" == 4);
// => true

// Вот это да.. получили true! хоть у этих двух элементов разные типы данных,
// мы получили.. true. Всё дело в том, что при обычном сравнении (два оператора
// сравнения) разные типы данных приводятся к одному - если в выражении есть
// число и строка, то строка будет приводиться к числу. Таким образом мы полу-
// -чаем true. Но что если поставить оператор строгого сравнения?

console.log("4" === 4);
// => false

// А на этот раз всё правильно. Мы получили false, так так оператор строгого
// сравнения не приводит типы данных к одному - он сравнивает "как есть".
// А теперь про конкатенацию и что это вообще такое. Если коротко - это просто
// сложение строк, не более того. Легче понять на примере -

console.log(4 + "4");
// => "44"

// Как мы видим, число (цифра) 4 сложилось со строкой "4". И тут есть одно очень
// важное правило, которое объяснит весь смысл конкатенации и суть того, почему
// 4 + "4" превратилось в "44" - "если мы что-то складываем со строкой, то всё
// наше выражение превращается в одну строку". То есть 4 превратилось в "4",
// а при сложении строк они "скрепляются", из этого и вышел след. результат:
// "4" + "4" = "44". Это всё равно, что в тетради написать 44. Так что повторяю,
// что если мы складываем любой тип данных со строкой. А также я упомянул два
// таких оператора как инкремент и декремент, сейчас мы узнаем, что это такое!

// Для начала создадим переменную, а значением будет цифра 5
let x = 5;

// Допустим, что у нас есть переменная x со значением 5. В будущем я хочу уве-
// -личить переменную на единицу, для этого я могу написать следующее:

x = x + 1;

// Что значит этот код? это значит, что к текущему значению переменной x мы
// добавляем единицу, и всё .То есть в данный момент значение переменной x
// равно шести. Но так как программисты люди очень ленивые (а оно и неудиви-
// -тельно, за компом 25/8 сидят), они придумали много способов, которые позво-
// -ляют сократить такую запись. Например, перед знаком равно (т.е оператором
// присваивания) необходимо поставить плюс:

x += 1;

// Ну вот, теперь значение переменной x равно 7-ми. Запись x += 1 равносильна
// записи x = x + 1, разве что она короче. Но и это не всё, мы можем использовать
// ИНКРЕМЕНТ, сократив запись ДО МИНИМУМА:

x++;

// Эта запись равносильна двум предыдущим, т.е эти два плюсика добавляют одну
// единицу к нашему изначальному числу, поэтому значение переменной x в данный
// момент равняется восьми. Тут вы просто должны понять, что мы берем предыдущее
// значение переменной x и просто добавляем к нему единицу! добавьте к 7-ми цифру
// 1, получится 8. Чтобы убедиться, что наша переменная x реально изменила своё
// значение на полученную 8-мёрку, давайте выведем её в консоль и убедимся в этом:

console.log(x);
// => 8

// Действительно - мы получили в консоли цифру восемь! всё потому, что мы посто-
// -янно как-то да увеличивали эту переменную (x = x + 1, x += 1, x++). А теперь
// про декремент! декремент - близнец инкремента. Их отличие лишь в том, что если
// инкремент увеличивает переменную на единицу, то декремент наоборот - уменьшает.
// В данный момент значение переменной x равно 8-ми, это мы знаем. Но каким оно
// будет ПОСЛЕ использования декремента? сейчас узнаем! применим декремент:

x--;

// Отлично, декремент мы применили. Вообще, не трудно догадаться, каким будет
// результат всей этой операции - было 8, отняли единицу, стало... -

console.log(x);
// => 7

// Стало 7! так-то всё правильно, так и должно быть. В будущем мы будем часто
// использовать инкременты и декременты, в основном они нам понадобятся в ЦИКЛАХ.
// Но сейчас не об этом. Мы должны хоть как-то взаимодействовать с пользователем
// сайта на странице, поскольку JS и был придуман для взаимодействия с юзерами
// самых различных сайтов! Однако рядовой пользователь лезть в консоль для того,
// чтобы взаимодействовать со страницей, не будет. Для этого в JavaScript'е есть
// уже заранее созданные методы, и с первым из них мы уже знакомы - это команда,
// которая выводит что-то в консоль, то есть console.log(). Но я, опять же, напо-
// -минаю, что обычный пользователь сайта в консоль лезть не будет и, возможно,
// даже не знает о существовании такой вещи как DevTools. Ну или знает, но как
// именно с ними работать он не знает. Поэтому идем дальше. И тут опять то же
// самое, что и в случае с console.log() -  с этой командой мы тоже знакомы! это
// alert, который выводит диалоговое окно. Этот метод выводит ту информацию, ко-
// -торую мы в него передали. Ну, скажем, циферку один:

// Закомментировано: мешает при входе на страницу.
// alert(1);
// => 1 (в диалоговом окне)

// Зайдя в браузер, на встречу пользователю вылезет диалоговое окно с цифрой 1.
// Но если говорить о практическом применении этого метода, то можно вспомнить
// простые формы, где надо что-то заполнить. Если мы случайно нажали на клавишу
// закрытия, а у нас открыта вкладка с заполненными формами, иногда нам может
// вылезти диалоговое окошко с надписью "Вы уверены, что хотите закрыть вкладку?"
// или чем-то похожим на это, я думаю вы, читатель, меня поняли. Но эти две
// команды.. скучненькие. Одна выводит информацию в консоль, другая в окошко!
// А что, если мы о чём-то СПРОСИМ пользователя? ну, в таком случае нам поможет
// метод confirm! в неё мы передаем вопрос, который хотим задать нашему текущему
// пользователю. Зададим самый дефолтный - "Вам есть 18 лет?":

// Закомментировано: мешает при входе на страницу.
// confirm("Вам есть 18 лет?");

// Если пользователь зайдет на наш сайт, первым делом ему зададут вопрос - "Вам
// есть 18 лет?", и он может ответить на него двумя кнопками: "Ок" и "Отмена",
// типа "Да" и "Нет". Делается это просто - под вопросом находятся две кнопки,
// которые похожи на кнопку из простого alert'а (а у него только один вариант
// ответа - "Ок"), нажимаем на конкретную кнопку и ожидаем результата. Но, что
// еще интереснее так это то, что мы можем СОХРАНИТЬ ответ пользователя в какую
// нибудь переменную! делается это следующим образом: создаем переменную, затем
// в качестве значения передаем метод confirm с вопросом:

// Закомментировано: мешает.
// let answer = confirm("Вам есть 18 лет?");

// Готово! теперь как только пользователь ответит, его ответ сохранится в пере-
// -менную. Давайте узнаем, действительно ли оно так:

// console.log(answer);
// => true, если пользователь ответил "Ок"; false, если пользователь ответит "Отмена"

// Теперь, когда пользователь нажмет на кнопку "Ок", в консоль нам выдаст "true",
// если же он нажмет на кнопку "Отмена", в консоль мы получим "false". То есть
// это всё равно, что спросить человека о чём-то и ожидать ответа - он ответит
// либо да, либо нет. Идём дальше.

// Последний метод взаимодействия с пользователем - prompt. Этот метод делает
// то же самое, что и два предыдущих, но у пользователя появляется возможность
// вписать СВОЙ ответ! вы спросите: "как же он сможет написать свой ответ?",
// а вам отвечу - очень просто. вместе с кнопками внутри диалогового окошка
// появляется инпут, в который пользователь и введет ответ. Посмотрим на этот
// метод в действии, закомментировав старый код, ибо он будет нам мешать (ну вы
// сами подумайте, при каждом заходе на страницу нам задают вопрос.. кошмар!).
// Но, есть один нюанс! Помните, как мы сохранили ответ пользователя, когда мы
// задавали вопрос через confirm? так вот, если мы зададим пользователю тот же
// вопрос через метод prompt, то и его мы можем СОХРАНИТЬ! мы с вами одновременно
// и на метод посмотрим, и на сохранение ответа от посетителя сайта:

// let answer = prompt("Вам есть 18 лет?");
// console.log(answer);
// => (зависит от ответа, введенного пользователем)

// Прекрасно, теперь залазим в браузер и открываем на той же странице консоль.
// После нашего ответа (или пользователя), он придет в консоль и мы сможем его
// увидеть. Например, если я отвечу "Да", то я увижу эту же надпись в консоли.
// Но то, что мы написали - неправильно. А точнее правильно, но не для Internet
// Explorer'а. После первой строчки, необходимо добавить простую пустую кавычку,
// вот так: prompt("Вам есть 18 лет?", ""). Без этого, в работе IE могут воз-
// -никнуть какие-то баги или нечто похожее. Поэтому код сверху я закомментирую
// и перепишу его обратно, добавив кавычки - так он будет нормально поддерживаться
// Internet Explorer'ом:

// let answer = prompt("Вам есть 18 лет?", "");
// console.log(answer);
// => (зависит от ответа, введенного пользователем)

// Великолепно, если зайти в браузер, то никаких изменений мы не увидим. На самом
// деле так и должно быть - это относится лишь к IE, но мы же ведь не хотим, чтобы
// во время работы пользователя со страницей возникли какие-то баги, и чтобы наш
// пользователь ушел, оставив плохой отзыв? Нет, нам такого нинада. А теперь
// давайте немного попрактикуемся, заранее закомментировав старый код.

// У нас есть такая структура, которая называется МАССИВ. Если вспомнить класси-
// -фикацию, то массивы восходят к объектам и создаются при помощи квадратных
// скобок, как раз они служат для хранения данных по порядку. И теперь, умея
// взаимодействовать с пользователем, мы будем задавать вопросы пользователю
// и сохранять их в массив! и чтобы сразу немного поработать со страницей,
// мы должны научиться выводить информацию на страницу. Для этого существует
// команда "document.write". Используется эта команда крайне редко, потому что
// она буквально СТИРАЕТ наш сайт. Не в том смысле, что он пропадает с хостинга,
// а в том смысле, что с него уходит всё содержимое и вся стилизация. То есть
// весь контент удаляется, и на его место приходит наше, через document.write.
// Поэтому, использовать мы его будем исключительно в учебных целях, использовать
// его крайне не рекомендуется. Хорошо, дальше я создаю переменную answers, но
// ничего ей не присваиваю. Вместо этого, я просто оставлю квадратные скобки.
// Даже так, answers УЖЕ является массивом, заполнять его мы будем позже:

// let answers = [];

// Теперь этот массив я хочу заполнить данными, и напоминаю, что в массиве данные
// будут лежать по порядку - первый элемент, второй элемент и так далее. Причем
// эти элементы могут быть из любых типов данных - числа, строки, и даже другие
// массивы, но самое главное, что все эти данные идут по порядку. Для того, чтобы
// получить элемент на определенной позиции, мы должны обратиться к массиву. Для
// этого просто пишем название массива, а дальше надо поставить квадратные скобки
// и вписать внутри позицию элемента. Если мы хотим получить ПЕРВЫЙ элемент, то
// тогда внутри записываем цифру 0. Вы спросите: "почему 0, а не 1?", а я вам
// отвечу, что в JS (как и во многих других языках программирования) нумерация
// начинается С НУЛЯ. То есть первый элемент будет на позиции 0, второй элемент
// на позиции 1 и так далее. Хорошо, записали цифру 0, тепреь нам надо поставить
// знак равенства (оператор присваивания, напоминаю) и после этого вписать слово
// prompt, открыть круглые скобки, поставить кавычки, написать свой вопрос и уже
// после первой строки поставить еще одни кавычки, для совместимости с IE:

// answers[0] = prompt("Как ваше имя?", "");

// Прекрасно! таким образом, первым элементом в массиве станет ответ на вопрос.
// Сделаем еще две таких же записи, но с разными вопросами:

// answers[1] = prompt("Как ваша фамилия?", "");
// answers[2] = prompt("Сколько вам лет?", "");

// Отлично, теперь в массив будут по порядку записываться ответы от пользователя.
// Чтобы это увидеть, воспользуемся той командой, о которой я уже рассказывал чуть
// выше - document.write. Вообще, вывести массив можно в консоль, но чтобы хоть
// ненмого поработать со страницей можно и изменить кое-что :) выводим на страницу
// наш массив:

// document.write(answers);
// => (зависит от ответа пользователья)
// => (зависит от ответа пользователья)
// => (зависит от ответа пользователья)

// Теперь, когда пользователь будет отвечать на наши вопросы, его ответы будут
// сохраняться в массиве, а из массива уже выводиться на страницу. Появляться
// ответы будут возле уже сужествующей надписи (надпись Hello World, которую
// мы добавляли еще давным-давно в index.html): либо под ней, либо после неё.
// И заметьте - все элементы массива выводятся через запятую, поскольку в самом
// массиве все эдементы идут по порядку, разделяются этой же запятой.

// Ну что-ж, круто - мы с вами получили от юзера информацию и вывели её прямо
// на экран (страницу). Но представьте себе, что бы было, если бы это был
// опросник.. нам бы пришлось ДЕСЯТКИ раз переписывать код, в смысле повторять
// его раз за разом! это кошмар. Но нет, так мы поступать не будем, ведь програм-
// -мирование создано для того, чтобы избавлять людей от однотипной и рутинной
// работы! и как правильно огранизовать структуру, когда у нас МНОООГО вопросов
// и мы должны их выводить, опять же, по порядку - узнаем в следующем уроке,
// а именно в уроке про циклы! и начнем мы.. сейчас :D

// Циклы

// Начнем с исторической теории. Любой человек подвластен лени, даже с начала
// понятия "человечество". Он вседа (ну..) старался как-то да автоматизировать
// выполняемые им процессы. Это дошло и до программирования. Сегодня речь пойдет
// об одном из важнейших постулатов вообще во всем программировании - о циклах.
// Мы заставим (можем заставить) код делать работу за нас! и давайте на простых
// примерах разберем, что такое цикл. Самый простейший для объяснения цикл, это
// тот, который мы повторяем КАЖДЫЙ день: утром мы просыпаемся, завтракаем, идем
// на работу/в школу, там мы работаем/учимся, вечером/днём возвращаемся домой,
// делаем работу по дому/домашнее задание и ложимся спать, соотвественно ночью
// мы спим. На утро наш цикл повторяется. Это самый простой цикл, повторяющийся
// человеком каждый день, вплоть до его сме.. ну, вы поняли. А более сложный,
// это годичный: осенью, первого сентября дети идут в школу, зимой многие народы
// празднуют новый год и так далее. Каждый год всё повторяется (но школа не для
// всех повторяется, поколения то меняются) и цикл тоже! Если брать другие, более
// житейские примеры, можно взять следующий: заходим в душ, берем бутылку шампуня,
// намыливаем голову, смываем шампунь. Опять берем бутылку шампуня, намыливаем
// голову, смываем. Некоторые повторяют это по 3-4 раза. То есть цикл это те
// действия, которые доведены до автоматизма - в программировании то же самое.
// Этот механизм позволяет нам оптимизировать многие-многие задачи, и как это
// всё реализуется - сейчас и узнаем!
// A.S: старый код я закомментировал, да, но он нам еще понадобится, так что
// о нём пока что не стоит забывать.

// В JS есть 3 вида циклов, начнем с первого и с самого популярнейшего, который
// используется в 95% случаев. Но сначала запомните, что в JS лишь 3 цикла, и
// всё остальное, что будет встречаться вам по мере развития - методы или цикло-
// -подобные структуры. Ну а теперь о том,
// как же именно создаются циклы и о том, какой из них самый популярный - это
// цикл for. Создается он очень-очень просто, надо просто написать ключевое
// слово "for". После него мы должны поставить круглые скобки, в них мы будем
// настраивать наш цикл. После периода настройки открываются фигурные скобки,
// там и будет находится тело цикла. В теле цикла будут выполняться те действия,
// которые мы и укажем в них же. Вот как цикл выглядит на данном этапе:

/*

for (...) {
	...
}

*/

// Ну, обо всем по порядку:
// в круглых скобках, в месте, где мы настраиваем цикл, должно находиться только
// 3 аргумента, хоть они и не необязательные. Первый из них - задание начальной
// точки, то есть с чего наш цикл будет начинаться. Стартовая позиция, вкратце :)
// Здесь, на данном этапе нам понадобится переменная, которая будет работать
// внутри цикла, и обычно её называют буквой i, от английского слова "iterator",
// по русски это будет "перечислитель". По умолчанию, переменная хранит в себе
// цифру 0, а мы помним, что индексы начинаются с нуля - это и значит, что это
// наша стартовая позиция. После задания значения мы ставим точку с запятой, и
// это очень важно! если мы поставим запятую, то ничего работать не будет, так
// что ставим именно ";". Первый аргумент - "начальную позицию" мы установили.
// Второй аргумент - то, до какого периода наш цикл будет продолжать работу.
// Например, если мы хотим вывести в столбик числа от нуля до девяти. Что мы
// можем сделать для достижения этой цели? мы можем сказать циклу, чтобы он
// повторялся до определенного момента, поставить ему условие:

/*

for (let i = 0; i < 10;) {
	...	
};

*/

// Таким образом, наш цикл будет работать до тех пор, пока условие истинно.
// Мы указали циклу, что он будет работать, пока наш итератор (i - iterator)
// МЕНЬШЕ чем 10. Таким образом, цикл остановит свою работу тогда, когда наша
// переменная i станет равна числу 10. Если брать примеры из реальной жизни,
// то представим, что у нас на какой-то странице есть 10 карточек товаров.
// Мы можем пройтись по ним циклом, и сказать, что пока у нас не кончатся эти
// карточки товаров, мы будем выполнять какое-то действие. Раскрашивать их в
// другой цвет, например. Ну и после того как мы написали второй аргумент, мы
// должны написать сразу третий, поставив точку с запятой. Третий аргумент -
// это...

// Что же? узнаем позже!)