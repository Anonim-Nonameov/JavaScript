// Важная информация

// Этот JS файл создан для повторения прошлых уроков. Т.е - здесь я буду повторять
// все свои прошлые уроки. Как это будет происходить? - повтор будет происходить
// 1 раз через урок. Т.е - сделал урок, прошло какое-то время (2 дня), теперь делаю
// вместо него повтор. Всё то же самое, что и с уроками по JS от "ФЛС", он же Жека.

// --------------------------------------------------------------------------------

// Типы данных и взаимодействие с пользователем

// Итак. Что такое типы данных в JS? по простому, это та информация, которую мы
// можем использовать в своих скриптах, и эта информация может быть чем угодно.
// У этой информации есть своя классификация, её можно найти в интернете.
// Но так как вам может быть лень гуглить эту классификацию, оставлю её здесь:

/*

Простые типы                    Объекты                      Обычные объекты
------------                    -------
Числа - 1, 2, 3	 		   	 	Массивы
Строки - "text"            	 	Функции
Логический тип - true/false 	Объект даты
null                       		Регулярные выражения
undefined                  		Ошибки
Symbol
Bigint

*/

// Мы с течением времени будем потихоньку разбирать каждый тип данных, даже
// это займет у нас не мало времени. Начнем с того, что конечно же все типы
// данных разделяются на две небольшие группы: простые типы и сложные, ком-
// плексные, или же по другому они называются объекты. Начнем мы с простых
// типов, т.к комплексные типы данных трудно изучать и там много информации:
// первым у нас идет тип "Числа", пожалуй один из самых прос-тейших типов
// данных в JavaScript'е. Благодаря нему мы можем обозначать номер по порядку:
// 1, 2, 3; либо считать сумму зарплаты за месяц: 1000, 2000, 3000 и так далее.
// Следующим типом данных являются строки. Я думаю, что ни для кого не секрет,
// что если я напишу какое-то выражение, например "Text", это не будет числом:
// это будет некое описание, то есть то что мы может написать как обычную стро-
// ку. Так что если мы что-то пишем как обычный текст, то это будет строкой.
// Давайте создадим простую переменную "myName", значением которой будет "Alex":

let myName = 'Alex';

// Отлично! теперь эта переменная содержит в себе строку. Стоит отметить, что
// строки всегда записываются в кавычках. В JavaScript'е нет разницы между тем,
// какие кавычки вы используете: одинарные (''), двойные ("") или обратные (``).
// Если я запишу ту же строку "Alex" в одинарных кавычках - она останется строкой,
// то же самое будет и с обратными кавычками. Кстати, заметили ли вы как я назвал
// переменную выше? а назвал я её используя стиль "CamelCase"! в JS существует
// огромное множество стилей наименования переменных, одним из которых является
// camelCase, он же "ВерблюжийРегистр". Если название переменной состоит из не-
// кольких слов, то каждая первая буква в слове будет прописана как заглавная.
// То есть: "my new variable" будет записано как "MyNewVariable". Но использовал
// я схожий с "CamelCase" стиль - "lowerCamelCase". Этот стиль почти ничем не
// отличается от "CamelCase", разве что тем, что первое слово в названии пере-
// менной будет написано с строчной буквы. То есть: "my new variable" будет за-
// писано как "myNewVariable". lowerCamelCase используется чаще чем camelCase,
// так как он выглядит более приятным глазу (по моему мнению). Кстати, обратные
// кавычки также называют "бектиками", и при помощи бектиков мы можем делать кое
// что очень интересное! но об этом позже, сейчас рано говорить о таких вещах.

// Следующий тип данных - булевый, он же логический тип данных. Содержит он
// в себе либо правду, либо ложь. Что это значит? давайте создадим простейшую
// реальную конструкцию: если вы сейчас читаете этот текст на компьютере, то вы,
// в принципе, должны сказать, что да, это правда. Если с мобильного телефона -
// то это будет ложь, false, не правда. В принципе всё верно - на телефоне этот
// текст вы бы вряд-ли прочитали, ведь чтобы прочитать его вам бы пришлось
// заходить в гитхаб, так как только там есть копия этого файла.. но не суть.
// Такие логические утверждения как раз таки и будут работать в нашем коде.
// Например, в коде мы можем проверять, открыто ли у пользователя модальное окно.
// Если вдруг оно открыто, то мы получаем булевое значение true, то есть "правда",
// и в зависимости от этого ответа мы можем какие-то действия выполнять, а какие
// то наоборот запрещать. Например, если модальное окно будет открыто, то мы
// можем запретить скролл подложки, то есть всего сайта, а когда его закроем то
// можно будет вновь скроллить. Если же говорить о коде, то мы можем создать
// переменную... ну, bool например, и задать ей значение true, то бишь правду:

let bool = true;

// Или наоборот, задать переменной значение false, то бишь ложь:

bool = false;

// Отлично, идем к следующему... нет, к следуюЩИМ типам данных. А дальше у нас
// два таких "философских" типов данных, как сказал лектор - null и undefined.
// Различать их довольно просто - главное понять как они работают, и в этом и
// заключается вся сложность:

// null - это когда чего-то просто НЕ СУЩЕСТВУЕТ.
// undefined - это когда что-то существует, но значения никакого вообще не имеет.

// Разберем всё это на реальном примере. Допустим, что я хочу поместить в перемен-
// ную modal строку 'string':

// modal = "string";

// Или, например, вывести в браузере диалоговое окошко со значением переменной a:

// alert(a);

// А теперь пересмотрите весь этот  файл и попытайтесь найти такие переменные.
// Вы конечно же не найдете ни одну из этих переменных - их просто нет! если
// такой скрипт выполнить, заходя в браузер, нам выдаст в консоли вот такую
// надпись: "Uncaught ReferenceError: a is not defined". Отлично, а теперь
// возьмем другой пример. Код на 98 строке, где мы меняли значение переменной
// modal, я закомментировал, так как он будет нам мешать. Код на 102-ой строке
// также закомментирован. Давайте создадим переменную modal, но значения ей
// мы не присвоим:

let modal;

// Отлично, мы создали переменную, но она пуста. Что это значит? мы взяли и
// подписали коробку, но она пуста - значения в переменной нет! на данный момент
// её значение равно undefined, так как переменная ЕСТЬ, но ЗНАЧЕНИЯ НЕ ИМЕЕТ.
// Чуть позже мы узнаем, как получить это значение в консоль. Опять же - заметьте,
// что null и undefined - два разных типа данных! и конечно, вопросы о null и
// undefined часто задают на собеседованиях, чтобы понять, ориентируетесь вы в
// этой теме вообще или нет. А так, тема о null и undefined в целом легкая.
// Если же говорить о двух оставшихся типов данных, то на сегодняшний день они
// считаются более-менее новыми, и появились они, ну.. относительно недавно. Это
// Symbol и Bigint. Symbol это технический тип данных, который появился в стан-
// дарте ES6, поэтому вы вряд-ли с ним когда-то да столкнетесь, так что пока про-
// сто знайте что он есть. А вот такой тип данных как Bigint появился не так уж
// и давно - летом 2019-го года. Если говорить по простому, то Bigint это просто
// ОГРОМНЫЕ числа, которые не влезают в допустимый диапазон чисел. Bigint, также
// расшифровываемый как big integer, это числа, которые больше чем 2 в 53 степени.
// Дело в том, что в обычном типе данных "Number" есть, так сказать, лимит. Если
// использовать такие огромные числа с обычном типом данных "Number", могут возник-
// нуть ошибки. Именно поэтому в JS был введен новый (почти) тип данных, Bigint.
// И как раз в него включаются все эти огромные числа, не влезающие в диапазон
// доступных. Естественно, при работе с такими огромными числами используя этот
// тип данных никаких ошибок у нас возникать не будет - для них создан тип данных!

// Следующие типы данных - объекты и массивы. Начнем с простых примеров, что же
// такое объекты и что такое массивы.

// 1) - Объекты

// Сначала возьмем какую нибудь информацию.. апельсин, например. Теперь подумайте -
// как мы можем его описать? ну, во 1-ых, его категория - фрукт. Еще можно сказать,
// что его форма - круглая, цвет - оранжевый, а вес, например, 300 грамм. Соответ-
// ственно сейчас мы с вами описали некий предмет, элемент, и то же самое можно
// сделать в коде. "Как", вы спросите, а я вам отвечу - при помощи объектов! в коде
// мы можем описать ЛЮБОЙ предмет или что нибудь еще при помощи конструкции под наз-
// ванием "объект". Объекты состоят из двух внутренний категорий - свойства и методы,
// или как их еще (иногда) называют ключи и значения. Чуть выше мы описали ВСЕ СВОЙ-
// СТВА апельсина, т.е что он в себя включает или как его можно описать. И я думаю
// вы уже заметили (если вы, конечно, очень внимательный человек), что объект как
// комплексный (сложный) тип данных может содержать в себе разные типы данных. Почему
// я так решил? а потому, что на примере апельсина мы (я) показали (показал), что он
// какого цвета? правильно - ОРАНЖЕВОГО, каков его вес? правильно - 300 грамм! Соот-
// ветственно, можно даже писать объект в объекте в объекте в объекте, такое тоже воз-
// можно :D И также я сказал, что объекты содержат в себе МЕТОДЫ. То есть любая конс-
// трукция может что-то делать, но только не апельсин - максимум сгнить :) поэтому возь-
// мем другой пример - пылесос! пылесос как объект можно описать следующими способами:
// его модель, его вес, его мощность всасывания. Но вот он, в отличии от апельсина,
// умеет что-то делать. Например... пылесосить ваш пол, как бы странно это не зву-
// чало! и, конечно же, так далее. Соответственно, как вы уже поняли (я надеюсь),
// объекты cлужат нам для того, чтобы мы могли какие-то сущности полностью описывать.
// Эти сущности, кстати, могут быть и на вашем сайте - возьмем простое модальное
// окно. Мы можем описать его ширину, высоту, то что он умеет делать (отправлять
// формы, закрываться и прочее-прочее). Таким образом, при помощи объекта как
// комплексного типа данных мы можем всё это очень красиво и опрятно организовать.
// Надеюсь, что с этим всё понятно, а чуть позже я покажу всё это в реальном коде.

// 2) - Массивы

// Вы должны запомнить - массивы это частный случай объектов, или говоря простыми
// словами - его потомок, дальний родственник или как-то так. Это НЕ отдельный тип
// данных. А теперь к сути, что такое массив ВООБЩЕ? ответ прост - это конструкция,
// которая позволяет нам записать какие-то данные ПО ПОРЯДКУ, строго ПО ПОРЯДКУ.
// Что это значит? допустим, вы берете одну вещь и хотить записать её в массив,
// записали и поставили запятую, затем добавили вторую вещь и также записываете
// в массив, ставя запятую, и только затем третий элемент. У вас строгий порядок
// этих элементов. И, соответственно, нам абсолютно не важно какие это элементы -
// это могут быть строки, это могут быть числа, это могут быть объекты, массивы
// или вообще какие нибудь функции. Так что, здесь массивы служат для расположения
// элементов (вообще любой информации) строго по порядку, и это их основное предназ-
// начение. Как реальный пример, мы с вами можем взять и написать список ссылок
// на картинки, чтобы в будущем их использовать, или список заголовков, параграфов
// и так далее. Чуть позже я расскажу, как это применяется на реальных проектах.

// С теорией покончено, надеюсь вам всё стало ясно. Дальше дело практики.
// Если рассматривать с позиции кода, объекты создаются просто: просто создаем
// любую коробку (то есть переменную), даем ей имя и раскрываем фигурные скобки.
// Мы можем его даже не заполнять, это УЖЕ считается как объект, правда пустой.
// Но если нам внутри нужна какая-то информация, мы записываем название свойства
// (важно - название свойства должно описывать его значение), ставим двоеточие и
// прописываем само значение. Значение может быть любым - строка, число, булевое
// значение, массив и даже другой объект! но если мы хотим чтобы у нас было еще
// и второе, или даже третье свойство со своим значением, мы ставим запятую после
// того, как написали значение свойству. Пример такого объекта:

// obj - сокращение от object (объект по англ.)
let obj = {
	dog: 'Puppey',
	cat: "Murrr"
}

// Всё, наш объект готов. Но следует отметить, что у него сейчас есть только
// свойства со значениями, а то, что он будет УМЕТЬ делать, мы разберем позже,
// когда речь пойдет о функциях. А теперь о массивах!

// Если говорить о массивах как о таком.. специфическом объекте, то он служит
// непосредственно для того, чтобы данные в нем располагались по порядку. А в
// коде это выглядит примерно так: мы также как и в случае с объектами создаем
// простую коробку (переменную), даем ей название и ставим квадратные скобки.
// И здесь то же самое, что и с объектами - а только поставлены квад. скобки,
// он УЖЕ является массивом. Но опять же - он пустой. Как только мы поставили
// квадратные скобки, можем наполнять его значениями. Опять же - значением
// массива может быть абсолютно что угодно, точно как и в объектах. Разделение
// происходит также через запятую. Пример массива:

// arr - сокращение от array (массив по англ.)
let arr = [1, 'str', false];

// Вот и всё! массив создан. Но имея массив, мы можем выполнять некоторые опе-
// -рации по его "модернизации" (цитата, лектор). Например, если я хочу получить
// лемент под индексом №1 (то есть первый элемент), то я прописываю слово arr
// (то есть название нашего массива), ставлю квадратные скобки и внутрь вписываю
// число 0. Но вы спросите: "почему 0, если нам нужен ПЕРВЫЙ элемент?", а я вам
// отвечу так - в JS нумерация начинается с нуля. Так вот - после всего этого я
// могу и ИЗМЕНИТЬ этот элемент! для этого я ставлю знак равенства (т.е оператор
// присваивания) и прописываю новое значение, например - 2:

// Запись эквивалентна следующей: let arr = [2, 'str', false], т.к мы изменили
// первый элемент (1) на другой (2) 
arr[0] = 2;

// Отлично! а теперь мы научимся пользоваться консолью. Для того чтобы написать
// туда хоть что нибудь, мы воспользуемся командой "console.log()". Вообще, это
// простейший способ тестирования своего кода. Например, мы можем вывести туда
// значение своей переменной в данный момент. Чтобы это сделать, прописываем эту
// команду и внутри круглых скобок вписываем любую информацию, например нашу
// старую переменную modal, которую мы создавали еще в начале (но не забываем ;):

console.log(modal);
// => undefined

// Заходим в консоль (Браузер - HTML файл, к которому привязан скрипт - CTRL +
// SHIFT + I/ F12 - Console), смотрим - а там у нас undefined! справа от него
// даже указано, на какой строке мы "отправили" значение переменной modal в эту
// консоль (в нашем случае это 240). Кстати, значение переменной modal равно
// undefined потому, что переменная ЕСТЬ, мы её создали, НО ЗНАЧЕНИЯ ОНА НЕ
// ИМЕЕТ, абсолютно. И это как раз один из тех типов данных, о которых мы еще
// в начале говорили. А если вывести в консоль значение переменной myName?
// её мы еще в самом начале создавали (также, как и modal), и я помню что у неё
// было какое-то значение. В любом случае мы это сейчас узнаем! -

console.log(myName);
// => "Alex";

// В консоль мы получили строку Alex, и правильно - у переменной myName такое
// значение! И кстати, JS "прощает" нам некоторые ошибки которые мы допускаем
// в коде, потому что он был придуман для "не программистов", как я уже когда
// то давно говорил. Поэтому попробуем сделать какую-то неочевидную операцию
// и вывести её в консоль:

console.log(4/0)
// => Infinity

// Мы знаем, что на 0 делить НЕЛЬЗЯ, но в консоли мы получаем Infinity. Так что
// если у нас произошла какая-то не математическая операция, то что сделать дей-
// -ствительно нельзя, то у нас не вылезет ошибка, а выйдет специальное значение
// под названием Infinity. Кстати, можно получить также "минус бесконечность":
// для этого просто делим отрицательное четыре на ноль -

console.log(-4/0);
// => -Infinity

// Ну вот, как я и говорил (писал) - минус бесконечность и плюс радости в штанах!
// Такая вот защита "от дурака". Кстати, значение Infinity по классификации ухо-
// -дит к числам, т.е это по факту число. Кроме этого, кстати, есть еще один
// возможный вариант когда у нас всё отходит от нормальной логики...

// Но какой? - узнаем позже!