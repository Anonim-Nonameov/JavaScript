// Полноценная практкика по написанию корзины товаров

// Итак.. сегодня мы займемся практикой. Но не простой, как в прошлом уроке - мы
// реализуем корзину товаров! и кроме этого, мы узнаем про еще несколько методов,
// которые применимы для элементов на странице. Вообщем, будет такая же как и
// в прошлый практика, но будет чутка посложнее.. но об этом позже. Сейчас у меня
// есть для вас сразу одно очень важное сообщение: понятное дело, что в реальных
// проектах создание корзины товаров и перемещение элементов в неё осуществляется
// при помощи комбинации языков - там есть и код PHP, взаимодействие с базами дан-
// -ных и так далее. Но в данном уроке мы будем эмулировать всё это при помощи
// одного лишь JavaScript'a. Этого будет достаточно для того, чтобы убедиться
// в том, что JS на самом деле способен на многое и что он один сможет реализовать
// целую корзину товаров. Но прежде чем приступать к коду, мы должны поставить
// перед собой одну главную задачу: у нас на странице есть список товаров. У каж-
// -дого товара есть своя кнопка "Купить". Мы должны реализовать такой функционал,
// чтобы при клике на эту кнопку товар исчезал из общего списка и попадал в кор-
// -зину товаров, которой сейчас на сайте нет. На верстке её, кстати, тоже нет.
// Эту корзину мы будем создавать динамически, при помощи того же JavaScript'а.
// Кроме этого, когда товар будет попадать в корзину, у него будет исчезать его
// кнопка, ведь товар УЖЕ находится в корзинке и попадать туда повторно не надо :)
// Каждую эту задачу мы будем постепенно реализовывать в коде. Начинаем!

// Первое, с чего чаще всего начинают свой скрипт программисты, это получение той
// информации со страницы, с которой они и будут работать. Здесь подразумевается,
// что мы будем работать с "продуктами" - это те же самые карточки с товарами, у
// каждого этого товара есть свой определенный класс (общий) - product. Дальше,
// мы точно будем работать с кнопкой "Купить!" внутри каждого продукта. Почему
// именно "внутри"? потому, что кнопка находится ВНУТРИ элемента с этим классом.
// А также, мы точно будем работать с кнопкой "Открыть корзину", которая нахо-
// -дится выше всех остальных элементов на сайте. Для того, чтобы получить эти
// элементы, мы воспользуемся переменными и современным методом querySelectorAll.
// Первая переменная у нас будет называться products, в ней будут храниться все
// товары с сайта. Пользоваться мы будем именно методом querySelectorALL, который
// возвращает псевдо-массив, ведь элементов на сайте у нас много и получать каждый
// элемент по отдельности.. плохо. Вторая переменная будет называться buttons, и
// уже из названия становится предельно ясно, что в ней будут храниться кнопки
// "Купить!", находящиеся внутри каждого товара. Третяя переменная будет назы-
// -ваться openBtn, но использовать мы будем метод querySelector, без All в конце,
// потому что кнопка "Открыть корзину" у нас на сайте находится в единственном
// экземпляре. И вот названия классов, по которым мы будем искать эти элементы:
// "product" у товаров, у кнопок нет класса - просто тег "button", а у кнопки
// класс "open" соответственно:

let products = document.querySelectorAll(".product"),
	buttons = document.querySelectorAll("button"),
	openBtn = document.querySelector(".open");

// Превосходно, теперь мы получили переменные с элементами со страницы. Теперь,
// перед тем как начать работу с корзиной, я расскажу вам, читатель, о том как
// происходит отрисовка страницы в браузере. Я уверен на 99%, что вы из прошлых
// знаете уроков знаете о том, что когда HTML-документ попадает в браузер, он
// начинает грузится сверху вниз. Но этим всё не ограничивается. Что значит
// сверху вниз? это значит, что сначала подгружаеся его title, затем стили, они
// считываются и рассматриваются, затем идёт верстка, а после, к ней применяются
// сами стили. На нашем сайте есть блоки, и всё это дерево тегов можно представить
// как обычный документ, который можно записать в Word'е, только он у нас со своей
// специфической разметкой. А далее, когда уже загрузилась вся страница и рендер
// (отрисовка) почти кончена, браузер доходит до тега script. Подгружается наш
// JS-скрипт и.. на этом всё заканчивается, после него идут закрывающие теги и всё.
// Но здесь есть один важный момент, про который мы могли не подумать или забыли,
// а именно - картинки. На нашем рабочем сайте, каждый товар имеет свою картинку,
// которая показывает то, за какой товар отвечает тот или иной блок. Если у юзера
// (или даже у вас) слабый интернет, а картинка весит много (10-15 мегабайт), то
// она просто-напросто повиснет. Таким образом, наша страница может быть не до
// конца построена! но наш скрипт уже начинает прогрузку, и если вдруг какой-то
// скрипт начинает взаимодействовать с элементами на странице, а их еще нет, в
// таком случае наш скрипт может сломаться. В этой ситуации мы должны знать, что
// мы должны запускать наш скрипт тогда, когда страница уже готова ко всем дейст-
// -виям, которые может провести пользователь. В JS есть такое событие, а вернее
// даже два события, которые помогут нам "отловить" такие моменты и спасти наш
// скрипт от поломки. Какие это события? сейчас и узнаем!

// Первое событие называется просто load. Оно срабатывает тогда, когда наш сайт 
// был полностью прогружен, когда наше дерево тегов простроилось, картинки были
// загружены и шрифты из интернета были применены - полная готовность сайта. Но
// есть и событие попроще, которое на практике чаще всего и применяется. Сраба-
// -тывает он тогда, когда дерево тегов уже построено и тег, к которому что-то
// применяется уже есть. Ему не важно, что картинка не загружена или что стили
// еще не до конца прогружены - тег есть? есть, значит уже можно приступать к
// работе. Пусть там всякие стили, шрифты и прочее-прочее займутся прогрузкой,
// а нас, как JS-разработчиков волнуют лишь теги. Именно это событие в реальных
// проектах мы будем отлавливать. Пока что название события я говорить не буду,
// так как есть кое что, о чем очень важно поговорить. На практике, вы очень
// часто будете слышать такую аббревиатуру, как...

// Какую же? узнаем позже!)