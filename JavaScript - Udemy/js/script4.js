window.addEventListener('DOMContentLoaded', function() {
	let products = document.querySelectorAll(".product"),
		buttons = document.querySelectorAll("button"),
		openBtn = document.querySelector(".open");

		function createCart() {
			let cart = document.createElement('div'),
				field = document.createElement('div'),
				heading = document.createElement('h2'),
				closeBtn = document.createElement('button');

			cart.classList.add('cart');
			field.classList.add('cart-field');
			closeBtn.classList.add('close');

			heading.textContent = "В нашей корзине:";
			closeBtn.textContent = "Закрыть";

			document.body.appendChild(cart);

			cart.appendChild(heading);
			cart.appendChild(field);
			cart.appendChild(closeBtn);
		}

		createCart();
});

// Полноценная практкика по написанию корзины товаров

// Итак.. сегодня мы займемся практикой. Но не простой, как в прошлом уроке - мы
// реализуем корзину товаров! и кроме этого, мы узнаем про еще несколько методов,
// которые применимы для элементов на странице. Вообщем, будет такая же как и
// в прошлый практика, но будет чутка посложнее.. но об этом позже. Сейчас у меня
// есть для вас сразу одно очень важное сообщение: понятное дело, что в реальных
// проектах создание корзины товаров и перемещение элементов в неё осуществляется
// при помощи комбинации языков - там есть и код PHP, взаимодействие с базами дан-
// -ных и так далее. Но в данном уроке мы будем эмулировать всё это при помощи
// одного лишь JavaScript'a. Этого будет достаточно для того, чтобы убедиться
// в том, что JS на самом деле способен на многое и что он один сможет реализовать
// целую корзину товаров. Но прежде чем приступать к коду, мы должны поставить
// перед собой одну главную задачу: у нас на странице есть список товаров. У каж-
// -дого товара есть своя кнопка "Купить". Мы должны реализовать такой функционал,
// чтобы при клике на эту кнопку товар исчезал из общего списка и попадал в кор-
// -зину товаров, которой сейчас на сайте нет. На верстке её, кстати, тоже нет.
// Эту корзину мы будем создавать динамически, при помощи того же JavaScript'а.
// Кроме этого, когда товар будет попадать в корзину, у него будет исчезать его
// кнопка, ведь товар УЖЕ находится в корзинке и попадать туда повторно не надо :)
// Каждую эту задачу мы будем постепенно реализовывать в коде. Начинаем!

// Первое, с чего чаще всего начинают свой скрипт программисты, это получение той
// информации со страницы, с которой они и будут работать. Здесь подразумевается,
// что мы будем работать с "продуктами" - это те же самые карточки с товарами, у
// каждого этого товара есть свой определенный класс (общий) - product. Дальше,
// мы точно будем работать с кнопкой "Купить!" внутри каждого продукта. Почему
// именно "внутри"? потому, что кнопка находится ВНУТРИ элемента с этим классом.
// А также, мы точно будем работать с кнопкой "Открыть корзину", которая нахо-
// -дится выше всех остальных элементов на сайте. Для того, чтобы получить эти
// элементы, мы воспользуемся переменными и современным методом querySelectorAll.
// Первая переменная у нас будет называться products, в ней будут храниться все
// товары с сайта. Пользоваться мы будем именно методом querySelectorALL, который
// возвращает псевдо-массив, ведь элементов на сайте у нас много и получать каждый
// элемент по отдельности.. плохо. Вторая переменная будет называться buttons, и
// уже из названия становится предельно ясно, что в ней будут храниться кнопки
// "Купить!", находящиеся внутри каждого товара. Третяя переменная будет назы-
// -ваться openBtn, но использовать мы будем метод querySelector, без All в конце,
// потому что кнопка "Открыть корзину" у нас на сайте находится в единственном
// экземпляре. И вот названия классов, по которым мы будем искать эти элементы:
// "product" у товаров, у кнопок нет класса - просто тег "button", а у кнопки
// класс "open" соответственно:

// let products = document.querySelectorAll(".product"),
// 	buttons = document.querySelectorAll("button"),
// 	openBtn = document.querySelector(".open");

// Превосходно, теперь мы получили переменные с элементами со страницы. Теперь,
// перед тем как начать работу с корзиной, я расскажу вам, читатель, о том как
// происходит отрисовка страницы в браузере. Я уверен на 99%, что вы из прошлых
// знаете уроков знаете о том, что когда HTML-документ попадает в браузер, он
// начинает грузится сверху вниз. Но этим всё не ограничивается. Что значит
// сверху вниз? это значит, что сначала подгружаеся его title, затем стили, они
// считываются и рассматриваются, затем идёт верстка, а после, к ней применяются
// сами стили. На нашем сайте есть блоки, и всё это дерево тегов можно представить
// как обычный документ, который можно записать в Word'е, только он у нас со своей
// специфической разметкой. А далее, когда уже загрузилась вся страница и рендер
// (отрисовка) почти кончена, браузер доходит до тега script. Подгружается наш
// JS-скрипт и.. на этом всё заканчивается, после него идут закрывающие теги и всё.
// Но здесь есть один важный момент, про который мы могли не подумать или забыли,
// а именно - картинки. На нашем рабочем сайте, каждый товар имеет свою картинку,
// которая показывает то, за какой товар отвечает тот или иной блок. Если у юзера
// (или даже у вас) слабый интернет, а картинка весит много (10-15 мегабайт), то
// она просто-напросто повиснет. Таким образом, наша страница может быть не до
// конца построена! но наш скрипт уже начинает прогрузку, и если вдруг какой-то
// скрипт начинает взаимодействовать с элементами на странице, а их еще нет, в
// таком случае наш скрипт может сломаться. В этой ситуации мы должны знать, что
// мы должны запускать наш скрипт тогда, когда страница уже готова ко всем дейст-
// -виям, которые может провести пользователь. В JS есть такое событие, а вернее
// даже два события, которые помогут нам "отловить" такие моменты и спасти наш
// скрипт от поломки. Какие это события? сейчас и узнаем!

// Первое событие называется просто load. Оно срабатывает тогда, когда наш сайт 
// был полностью прогружен, когда наше дерево тегов простроилось, картинки были
// загружены и шрифты из интернета были применены - полная готовность сайта. Но
// есть и событие попроще, которое на практике чаще всего и применяется. Сраба-
// -тывает он тогда, когда дерево тегов уже построено и тег, к которому что-то
// применяется уже есть. Ему не важно, что картинка не загружена или что стили
// еще не до конца прогружены - тег есть? есть, значит уже можно приступать к
// работе. Пусть там всякие стили, шрифты и прочее-прочее займутся прогрузкой,
// а нас, как JS-разработчиков волнуют лишь теги. Именно это событие в реальных
// проектах мы будем отлавливать. Пока что название события я говорить не буду,
// так как есть кое что, о чем очень важно поговорить. На практике, вы очень
// часто будете слышать такую аббревиатуру, как DOM, сокращение от Document
// Object Model. Если рассказывать про него вкратце и по простому, то ДОМ это
// то же самое древо тегов, которое есть на странице, с ним мы и работаем. Как
// я уже сказал, мы хотим, чтобы наш скрипт запускался только тогда, когда наша
// страница будет готова его обработать. Поэтому нам понадобится такой объект
// как window, обработчик событий addEventListener и само событие, при котором
// уже загружены все теги на странице. Называется оно DOMContentLoaded. Это
// событие срабатывает тогда, когда всё древо тегов уже загружено, а стили с
// картинками - нет. После этого мы создаем функцию, и уже внутрь неё переме-
// -щаем все наши переменные. Но, поскольку добавлять код мы будем исключительно
// внутрь функции обработчика событий, код я буду писать на 1-ой строчке этого
// файла и туда вносить поправки, так как менять код внутри обработчика событий
// невозможно. Но я буду повторять код внутри многострочных комментариев, чтобы
// вам, читатель, не приходилось каждый раз заглядывать в самый верх файла. На
// данный момент там, на первой строке файла хранится следующий код:

/*

window.addEventListener('DOMContentLoaded', function() {
	let products = document.querySelectorAll('.product'),
		buttons = document.querySelectorAll('button'),
		openBtn = document.querySelector('.open');
});

*/

// Начнем с того, что же такое window - если вкратце, то это окно браузера у
// нашего пользователя, содеражщее в себе всё дерево DOM. Это самый верховный,
// глобальный объект, то есть самый главный. Хорошо, про window узнали, движем
// вперёд. Дальше мы создадим корзину, которая будет у нас работать на сайте.
// Да, мы действительно можем СОЗДАВАТЬ HTML-теги на сайте и делать это дина-
// -мически, из JS-файла. Но чтобы ограничить блок кода, который будет только
// заниматься созданием корзины, мы создадим функцию и будем писать код для
// создания корзины исключительно в нём, а называться она будет очень просто:
// "createCart". Чтобы создать более-менее приличную и.. нормальную корзину,
// нам понадобятся всего четыре элемента, во первых - надо создать саму
// корзину, куда будут помещаться все товары со страницы, а также понадобится
// определенный участок в этой корзине, куда и будут складываться все эти товары.
// Также понадобится небольшой заголовок и кнопка для закрытия корзины, и всё
// это мы можем создать при помощи JavaScript'а. 

// Первую переменную, куда мы поместим первый созданный нами элемент, назовем
// мы cart - сама корзина. В качестве значения мы присваивем ей создаваемый
// элемент. Но и тут вы зададите вопрос: как создавать элементы на странице
// через JS? а я отвечу, что для этого может использоваться специальный метод
// createElement, у которого из названия уже понятно, что он создает элементы,
// теги на странице, ну или по крайней мере позволяет нам это сделать. После
// написания названия метода ставим круглые скобки, затем кавычки и внутри само
// название тега, в нашем случае это div. После того как мы прописали название
// тега, внутри переменной появится наш элемент div. Ставим запятую, создаем
// следующую переменную, называться она будет field. В неё мы записываем то же
// самое, что и в cart, но не волнуйтесь - эти дивы чуть позже мы сделаем разными.
// Ставим запятую и создаем еще одну переменную, называться она будет heading и в
// неё мы опять таки записываем то же самое, но вместо div'а мы создаём элемент h2
// после этого ставим запятую. И последняя переменная - это кнопка, которая будет
// закрывать корзину. Назовём мы её тоже по простому, closeBtn. Вот что появилось
// в коде наверху:

/*

function createCart() {
	let cart = document.createElement('div'),
	field = document.createElement('div'),
	heading = document.createElement('h2'),
	closeBtn = document.createElement('button');
}

*/

// Пока что на странице этих элементов нет, и никаких стилей и наполнения у этих
// элементов тоже нет, и мы будем это исправлять! первое, что нам надо сделать,
// это как-то стилизовать нашу корзину, так что обратимся к переменной cart (но
// внутри той же самой функции, ибо и создание и стилизация будут динамическими).
// Мы должны добавить к ней какой-то класс, ибо понятное дело, что если мы хотим
// изменить несколько стилистических правил у этого элемента, то намного проще
// просто добавить класс, чем постоянно менять стили через свойство style. Но
// на самом деле свойство style - очень хороший инструмент для изменения стилей,
// но только на один раз. Для управления классами, в JavaScript'е есть свойство
// classList, и из названия понятно, что это список классов, которые есть у эле-
// -мента. Это свойство прекрасно тем, что с ним можно удалять, добавлять и даже
// ПРОВЕРЯТЬ классы, в смысле их наличие. Свойство classList используется в JS
// чаще, чем другое свойство - className, подробнее о нём можно узнать в интернете.
// Вкратце - это сильно устаревший и неудобный инструмент для работы с классами,
// поэтому к cart применяется свойство classList:

/*

function createCart() {
	...

	cart.classList
}

*/

// Далее, как я и говорил, мы должны добавить к корзине класс, и делается это
// через специальный метод add, который есть у свойства classList. Класс будет
// называться cart, всё логично! -

/*

function createCart() {
	...

	cart.classList.add('cart');
}

*/

// И всё, класс добавился! это можно проверить, выведя элемент в консоль, но
// делать так я не буду - я и без того уверен, что у элемента появился класс!
// А теперь нам надо добавить классы КО ВСЕМ элементам, кроме тега h2, он в
// классе не нуждается: это будут классы cart-field у элемента field и close
// у элемента closeBtn соответственно -

/*

function createCart() {
	...

	cart.classList.add('cart');
	field.classList.add('cart-field');
	closeBtn.classList.add('close');
}

*/

// Готово! теперь у наших элементов, с которыми мы будем работать, есть свои
// собственные классы. Таким образом, мы сделали наш первый шаг в сторону стили-
// -зации корзины. Далее, нам необходимо заполнить наш тег h2, и сделаем мы это
// внутри функции, обратившись к элементу heading и применив к нему свойство
// textContent. Это свойство нам уже знакомо: оно используется для того, чтобы
// поместить текст внутрь элемента. Мы заполним наш тег h2 текстом, а написано 
// там будет следующее -"В нашей корзине:". Следом за этим, мы также заполним 
// нашу кнопку closeBtn, чтобы было сразу понятно для чего эта кнопка, текст там
// будет следующий - "Закрыть":

/*

function createCart() {
	...
	
	heading.textContent = "В нашей корзине:";
	closeBtn.textContent = "Закрыть";
}

*/

// Отлично, теперь у нас уже есть готовый каркас. Далее, нам необходимо ДОБАВИТЬ
// эти элементы на нашу страницу. Сделаем мы это через команду "appendChild". 
// Эта команда позволяет добавить элемент, который был создан в JS-файле в
// любой другой элемент. Что это значит? предлагаю для начала обратиться к
// самому документу, одному из высших объектов - document. document это
// то же самое, что и весь наш документ, так что разъяснять ничего не надо.
// Стоит лишь добавить, что как раз таки ОН содержит ВСЕ теги на странице
// как другие объекты и как свои свойства, а это значит, что мы можем обратиться
// к body! это мы и сделаем, в итоге получится вот такая запись:

// document.body

// Мы обращаемся к объекту body, который находится в объекте document, всё просто.
// Далее, к объетку body применяется команда, метод appendChild. В круглых
// скобках мы вписываем переменную cart, таким образом на странице должен появится
// div с классом cart:

/*

function createCart() {
	...
	document.body.appendChild(cart);
}

*/

// Прекрасно, теперь на нашей странице появился элемент, который мы создали
// в JS-файле! этот элемент хранится в переменной cart, а какой именно элемент
// хранится в этой переменной, мы уже знаем - div с классом "cart", то есть сама
// наша корзина (точнее её каркас, потому что это всего лишь пустой div). А теперь
// пришла пора заполнять нашу корзину! но как мы это сделаем? очень просто:
// сделаем мы это используя тот же метод, то есть appendChild, обратившись к самой
// переменной cart. Внутрь неё мы мы поместим всё то, что создавалось для неё же,
// а именно: heading, field и closeBtn. После того как мы добавим эти элементы в
// саму корзину, то есть заполним её, нам понадобится вызвать эту функцию, чтобы
// она сработала, но вызывать её мы будем ЗА пределами функции:

/*

function (createCart) {
	...
	cart.appendChild(heading);
	cart.appendChild(field);
	cart.appendChild(closeBtn);

}

createCart();

*/

// Замечательно, теперь наш элемент cart должен добавиться на страницу. В самом
// HTML-коде его так-то и нет, поэтому используем DevTools и убеждаемся, что наш
// элемент в самом деле появился! раскрыв его мы увидим, что внутри него также
// находятся div с классом cart-field, то есть наш элемент field и button со своим
// классом close, то есть наш элемент closeBtn. Чтобы увидеть эти элементы будучи
// отображенными на странице, достаточно взглянуть на столбец "Styles" в том же
// DevTools (причём в том же разделе Elements), заранее нажав на элемент cart: мы
// увидим, что у него по умолчанию стоит display: none. Для того, чтобы убрать (ну
// или отключить) какие-то стили у элемента в DevTools, достаточно нажать на одну
// кнопку, которая находится слева от самого CSS-правила. Отключаем стили, которые
// применяют к элементу display: none и видим, что наши элементы таки добавлены на
// страницу и отображаются, если их показать! всё потому, что у этих элементов уже
// заранее были готовые стили, оставалось только их создать и добавить на страницу,
// что мы с вами и сделали. Отлично, идём дальше