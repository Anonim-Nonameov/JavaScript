// ДЛЯ К.В (копировать-вставить)
// Скобки для выделения цитат, обрывков текста: «» « »

// Условия

// if, else if, else

// Итак, вот мы и подобрались к 5 уроку, в котором будем говорить об условиях.
// Но для начала, я хотел бы чтобы вы, читатель, задали себе один важный вопрос:
// как часто вы что-то выбираете в течении дня? выпить чай или выпить кофе?
// посмотреть фильм или почитать книгу? и так далее.
// В течении дня мы принимаем множество решений, и в зависимости от нашего выбора
// у нас происходят различные ситуации. Или, некоторые ситуации "диктуют" нам
// это поведение. Например - мы стоим на улице, у перекрестка, и видим светофор.
// На нём в данный момент горит красный цвет, и у нас в голове воспроизводится
// такое условие: «пока горит красный цвет, мы никуда не идем и не будем идти!
// Мы останавливаемся и не идем на красный цвет, так как мы боимся что нас
// собьет машина. В этот момент наше условие дополняется: «как только загорается
// зеленый цвет, мы переходим дорогу!»
// Так и в программах! при нажатии на красную кнопку, то программа ведет себя
// определенным образом (запускает ядерную ракету?..). Если же мы нажали
// на зеленую кнопку, то происходит абсолютно другое действие.
// То, как работает программа, зависит от множества условий. И, соответственно,
// условие - это тот самый следующий принцип, который мы и рассмотрим.

// Теперь давайте рассмотрим ситуацию с условием, с позиции кода.
// В первую очередь нам необходима какая нибудь информация, которую
// мы будем проверять. Например, переменная age со значением 14:

let age = 14;

// И теперь я хотел бы проверить, что если вдруг этот возраст, эта переменная
// age больше чем 18 - то я буду выполнять одни действия, если нет - то другие.
// Для того чтобы создать такую условную конструкцию, мы используем ключ.
// слово if (if с англ. языка значит "если" - всё логично!), после него ставим
// круглые скобки, и внутри мы должны написать то условие, которое мы будем
// проверять. После круглых скобок ставим фигурные скобки, и здесь записываем
// те действия, если заданное условие пройдет.
// Пример кода:

/*

if (;) {
	...
}

*/

// Представим, что у нас есть такое условие: «age больше 18», и что у нас
// есть код, который выводит диалог. окно с надписью "Вы можете войти".
// Что со всем этим делать не трудно догадаться. Пишем условие внутри
// круглых скобок, а код с выводом диалог. окна внутри фигурных скобок:

// if (age > 18) {
// 	alert("Вы можете войти");
// }

// Заходим в браузер, а там... ничего нет.
// Почему так? - всё потому что наше условие НЕ ПРОШЛО. 14 не может быть
// больше 18. Но если мы изменим 14 на 24, всё получится!
// Для начала изменим значение переменной age:

// age = 24;

// А затем повторяем наш код (после того как мы изменили значение переменной):

// if (age > 18) {
// 	alert("Вы можете войти");
// }

// Повторно заходим в браузер и... всё получилось, диалоговое окно выведено.
// Но это еще не всё! Допустим, что наш код с условием НЕ выполнились, т.е
// код не прошел по условию. В таком случае, мы можем ПРОДОЛЖИТЬ выполнение
// кода, или же по другому - "дополнить". Для этого мы используем ключ. слово
// else (else на англ. переводится как "еще", но в случае с JS - как "иначе".),
// которое ставится после закрывающей фиг. скобки. После этого "else" ставятся
// такие же фигурные скобки, а внутри них код, который выполнится если код выше
// не прошел по условию. Например, если у пользователя age равен 17,
// то по условию он не проходит. В таком случае срабатывает код, находящийся
// внутри else, и всё работает как надо!
// Однако, есть одна важная деталь - мы внутри else должны вписывать такой код,
// который является полной противоположностью кода в if (логично, ведь
// слово else переводится как "иначе").
// P.S - else работает ИСКЛЮЧИТЕЛЬНО с if!!!

// Опробуем наш "else" - если по условию юзер не прошел, то выведется диалог. окно
// с надписью "Рановато еще!". -

// Делаем значение age равным 14-ти, таким образом по условию он не пройдет:
// age = 14

// А теперь пишем весь код с if (;) {...} else {...}:

// if (age > 18) {
// 	alert("Вы можете войти");
// } else {
// 	alert("Рановато еще!");
// }

// Заходим в браузер и видим, что нам вывелось два сообщения. Первое - "вы можете
// войти", это с нашего прошлого кода c if (где мы еще не использовали else).
// Нас интересует именно второе, где нам вывело "Рановато еще" - это именно те
// слова, которые мы должны были увидеть! это результат выполнения кода в кон-
// -струкции else. Кстати, мы можем "скомбинировать" полученные нами знания и не
// задавать переменной age значение так "жёстко", а вместо этого "спросить" юзера
// о его возрасте - значением age будет ответ пользователя! а после того, как в
// переменную попадет значение, произойдет проверка условия - если возраст юзера
// меньшее 18-ти, ему выдаст сообщение с надписью "Рановато еще!", а если юзеру
// больше 18-ти, то ему выдаст сообщение с надписью "Вы можете войти".
// P.S - коды выше я закомментирую, так как они будут мешать (постоянно придётся
// нажимать на "ок").

// age = prompt("Сколько вам лет?", '');

// if (age > 18) {
// 	alert("Вы можете войти");
// } else {
// 	alert("Рановато еще!");
// }

// Заходим в браузер - нам выдаёт вопрос, мы на него и отвечаем и затем видим
// след. сообщение, где нам выдаст либо "Вы можете войти", либо "Рановато еще!".
// Главное, чтобы значение age было БОЛЬШЕ 18-ти, т.е если мы впишем 18 - нас "не
// пропустит". А если же мы напишем 19, и больше - пустит! :)
// Кстати, попробуйте как нибудь ввести "18.1" и посмотрите, интересный результат!

// Это всё хорошо, мы научиились создавать такие условные конструкции и продолжать
// их выполнение даже в том случае, если условие не будет оправдываться.
// Но это же еще не всё! мы можем еще и "расширять" такие условия, выстроить
// целую цепочку таких условий. Что я имею ввиду? ну, допустим, у нас есть
// какое-то одно условие. Мы его проверили, и если оно не прошло, мы хотим
// проверить следующее условие. Если и оно не прошло - проверяем еще одно, другое.
// Как это сделать? для этого, после блока if устроим небольшой отступ, ибо после
// блока else ничего выполняться не будет (else это конец выполнения условия,
// которое срабатывает в самом конце, если все условия не прошли), а затем
// пишем: else if (;) {...}. Выглядит это странно, ибо мы поставили после "else"
// слово if, но если эти два слова перевести, получится "или если", ну или "или
// же если". Вот как всё это будет выглядеть в коде:

/*

if (;) {
	...
} else if (;) {
	...
} else (;) {
	...
}

*/

// При этом, подобных "else if" может быть огромное количество - да хоть 100!
// В общем - штука очень полезная, значит будем применять. Для этого нам
// необходимо изменить наш код внутри условных-блоков - у первого if'а будет всё
// по старому, но у alert'а измениться текст - с "Вы можете пройти" на "Рановато
// еще!", а второе условие (у else if) будет таким: "или если age больше ста",
// а внутри фиг. скобок будет alert, выводящий текст "Поздновато уже!".
// Если и оно не сработает (не пройдет) - сработает else, а внутри else'а наш
// любимый и знакомый нам alert с текстом "Вы можете войти".
// P.S: а наш старый код, где мы уже использовали if и else - закомментируем,
// так как будет мешать (постоянные диалог. окна.. надоедает).

// age = prompt("Сколько вам лет?", '');

// if (age < 18) {
// 	alert("Рановато еще!")
// } else if (age > 100) {
// 	alert("Поздновато уже!")
// } else {
// 	alert("Вы можете войти")
// }

// Итак.. заходим в браузер, а нас там ждем диалог. окно, с вопросом и полем
// для ввода ответа. Всё также, как и обычно. Если вводить числа от 0 до 18,
// выдаст "Рановато еще!", если вводить числа от 19 до 100 - выдаст "Вы можете
// войти", а если от 101 и больше - "Поздновато уже!".
// Сейчас мы рассмотрели самый простой и, наверное, примитивный пример, но и
// такие примеры встречаются на РЕАЛЬНЫХ сайтах. Представим себе сайт, на
// котором есть интерактивная JS-карта а также, что у нас есть скрипт, который
// будет проверять нашу карту - если у неё есть уникальный идентификатор (ID)
// map, то карта будет рендериться, а если нету, то и карта рендериться не будет.
// Или, скажем, у нас есть форма с полями для ввода которые обязательно надо
// как-то заполнять, а еще у нас есть скрипт, который будет проверять, заполнены
// ли они или нет. Если они заполнены - форма отправляется, если нет, то будет
// выведено диалог. окно с надписью "Форма не отправлена: заполните все поля!".
// А если у нас еще и сервера упали, или еще что-то произошло и форма не
// отправляется - под ней будет выводиться сообщение: "Ой, что-то пошло не так!
// попробуйте, пожалуйста, позже!". А если все пройдет успешно и форма отправится,
// то у нас под формой будет выводиться сообщение: "Форма успешно отправлена!".
// Так что вот - примеры использования условий ПОВСЮДУ, как в реальной жизни
// так и в программировании (в частности в JS).

// switch & case

// Ну а перед тем, как заканчивать всю эту писанину и закрыть урок - мы поговорим
// о switch-case. По простому, это конструкция которая позволяет нам не прописывать
// цепочки условий как сверху, а писать условные конструкции более "элегантно".
// Чтобы её записать, нам понадобится команда switch и круглые скобки после неё.
// Внутри круглых скобок, как не трудно догадаться, будет располагаться наше
// условие. К сожалению, конструкция switch-case НЕ МОЖЕТ проверять условия, типа
// "age больше 100" и "age меньше 18", то есть - конструкция switch-case не
// способна проверять условные конструкции типа "если больше", или "если меньше"
// и так далее. Здесь (внутри круглых скобок switch) мы должны проверять на строгое
// соответствие, поэтому внутрь круглых скобок будет помещена переменная age.
// Далее, открываются фигурные скобки и в них мы пропишем те действия, которые
// выполняются если совпадают условия. Первым делом пишется слово case (переводится
// оно как "случай"), после него пишется число 18 и затем, после числа, ставится
// двоеточие. Уже ниже пишется код, выводящий диалог. окно с надписью "Вы можете
// войти", а после него ставится команда break, которая означает, что наш код
// "тут остановиться", то есть это такая точка остановки. А вот как это всё
// будет выглядеть в виде JS кода:

/*

switch (age) {
	case 18:
		alert("Вы можете войти");
		break;
}

*/

// Этот клочок кода внутри switch и есть тот самый "случай", случай когда age
// равна 18-ти. "case" это своеобразный "if", а число напротив него - условие,
// к примеру - "если age === 18 - выводи диалог. окно с такой-то напдисью".
// После break'а можно поставить еще 1 case, где age уже будет равен 100,
// а текст внутри alert'а будет таким: "Поздновато уже!", а после alert'а
// будет идти уже знакомый нам break, наша точка остановки:

/*

switch (age) {
	case 18:
		alert("Вы можете войти");
		break;
	case 100:
		alert("Поздновато уже!");
		break;
}

*/ 


// Здесь важно ключ. слово break, да оно вообще везде важно (в switch'е),
// иначе код не будет останавливаться и отработает лишь последнее условие!
// А всё потому, что наш код "не знает" где ему остановиться, на каком
// уровне - где age равен 18, где age равен 100 или еще где-нибудь,
// он будет просто идти и идти, без остановки до последнего случая.
// Ну, всё это очень хорошо, про switch и case мы узнали, но что если age
// у нас ни с чем не совпадает, ни с 18, ни с 100? поэтому мы должны
// предусмотреть подобный случай и написать в конце switch'а ключ. слово default,
// которое определяет дефолтное поведение нашего кода. Так, а после default идет
// всё то же двоеточие, а после него какой-то код, который отработает если
// другие case'ы не сработают. К примеру - нам выведет диалог. окно с такой
// надписью: "А значение не известно...". То есть - default это else у switch. :)
// А теперь мы проверим наш switch, одновременно закомментировав код с if наверху:

// age = prompt("Сколько вам лет?", '');	

// switch (age) {
// 	case 18:
// 		alert("Вы можете войти")
// 		break;
// 	case 100:
// 		alert("Поздновато уже!")
// 		break;
// 	default:
// 		alert("А значение не известно...")
// }

// Заходим в браузер, видим диалог. окно с вопросом и полем для ввода ответа снизу,
// вводим ответ "18" и получаем: "А значение не известно...".
// Так, стоп - это как это не известно?! хорошо, а если ввести "100"? - ответ
// тот же! Почему так происходит? - дело в том, что та информация, которую мы
// получили в переменную age вводится чётко пользователем. Есть одно очень важное
// и четкое правило, которое нам необходимо узнать и запомнить раз и навсегда,
// если мы хотим и дальше заниматься JavaScript'ом - вся информация, вводимая
// пользователем (не важно откуда - из prompt'а, из поля для ввода), исключительно
// строковая. Т.е тип данных - строка, даже если введенная информация была числовой.
// Мы ответили на вопрос, написав туда число 100 - а отправилось в age оно не как
// 100, а как "100". При проверке строгим равенством (===) также проверяются и типы
// данных, а от нас ожидалась числовая информация, не строковая. Вот они и сравни-
// ваются, а на сравнении у нас 100 и "100" - у первого тип данных number, у
// второго тип данных string! Вот и получаем мы тот алерт, в дефолтном случае.
// Вот и запоминаем - вся информация, исходящая от пользователя - строковая,
// а switch-case проверят на строгое равенство.

// На этом наш урок зак..
// Нет, погодите! мы еще не закончили. Как же нам исправить ту ошибку, где нам
// постоянно выдает тот алерт, который находится внутри default?
// Мы у case'ов должны числа заменить на строки, т.е из 100 сделать "100".
// Вот и готовый код (старый закомментировал):

// age = prompt("Сколько вам лет?", '');	

// switch (age) {
// 	case "18":
// 		alert("Вы можете войти")
// 		break;
// 	case "100":
// 		alert("Поздновато уже!")
// 		break;
// 	default:
// 		alert("А значение не известно...")
// }

// Функции

// A.S: старый код с switch-case закомментировал, чтобы не мешало.

// Итак, сегодня мы будем говорить (а точнее я, буду писать) о еще одной очень
// важной теме в программировании - о функциях. Команды, которые мы использовали
// ранее для работы с пользователем - уже встроенные действия. А какие нибудь
// действия программ и называются функциями. Функция - самый маленький, фунда-
// ментальный кирпичик любой программы. Внутри неё может быть что угодно: цикл,
// условие, определенная команда или даже другая функция. Буквально всё, что угодно.
// Почти любая техника, окружающая нас - самый настоящий сборник функций.
// Пылесос мы уже приводили как пример, но приведем еще раз. У пылесоса абсолютно
// ограниченное количество возможностей. Он умеет пылесосить пол, а также иногда
// его мыть (зависит от модели). А теперь приведем как пример... холодильник!
// В холодильник уже заложены некоторые функции, к примеру - он умеет хранить
// продукты свежими, умеет замораживать их, а еще умеет просто хранить продукты
// (да, как шкаф - в современных холодосах такая функция тоже есть). Но все эти
// примеры слишком простые, нам нужен более сложный пример, более сложная
// конструкция... например - человек! У человека огроооомное кол-во функций:
// он умеет писать, читать, ходить, есть, спать, сидеть за компьютером/сидеть
// в телефоне, играть, кушать и еще много-много чего! В том числе СОБИРАТЬ эти
// пылесосы и холодосы! так что это уже более сложная конструкция. Но самое
// главное, что эти действия - функция, которые может выполнять как определенный
// человек, так и определенная техника (ну там робота, например). В нашем случае
// выполнять какие-то действия, то бишь функции, будет и не человек и не робот -
// функции у нас будет выполнять самый настоящий код!

// Синтаксис

// Для начала разберем синтаксис функций, узнаем как создавать функции.
// Как по классике, мы должны использовать какую-то определенную команду, ключ.
// слово, которое будет определять функцию. В нашем случае это слово function
// (как ни странно), и прописывая в коде слово function (дальше буду писать это
// слово на русском, чтобы не менять раскладку клавы на английский), мы сразу
// говорим коду, что у нас сейчас будет создаваться (определяться) функция.
// Дальше мы должны её как-то назвать, чтобы в дальнейшем с ней взаимодействовать.
// А называть функции надо по аналогии с  переменными. Наша функция будет
// называться "humanSayHello". После того как мы придумали название и записали
// его, мы открывает круглые скобки, а затем фигурные. Вот так всё будет выглядеть:

/*

function humanSayHello() {
	
}

*/

// Внутри круглых скобок будут передаваться параметры, или же по другому - аргументы.
// О аргументах мы поговорим чуточку позже, а пока продолжим. Внутри фигурных скобок
// мы записываем те действия, которые функция будет выполнять. Например, запишем
// внутрь фиг. скобок команду console.log(), а выводить в консоль будем всем
// известную фразу - "Hello World!".

/*

function humanSayHello() {
	console.log("Hello World!");
}

*/

// Отлично, наша функция готова! но есть одна проблема.. если мы запустим такой
// код, абсолютно ничего не произойдет. Почему? всё просто - мы просто "сказали",
// что теперь такая функция существует, что такая функция появилась. И да,
// действительно, если её запустить то она что-то выполнит. Но пока она просто
// существует в своей ячейке памяти, просто лежит там себе уютно и ничего не
// делает. Это всё хорошо, но как её запустить то? для этого, необходимо ниже
// нашего кода написать название функции и обязательно поставить круглые скобки
// (без них никак, уж прАстите):

/*

function humanSayHello() {
	console.log("Hello World!");
}

humanSayHello();

*/

// Таким образом, наша функция заработает и выведет в консоль фразу "Hello World!".
// У новичков часто бывают ошибки, связанные с запуском функций. Довольно часто
// новички создают функции, но не вызывают их! а потом еще жалуются, что ничего
// не работает и код внутри функции не выполняется. Так что надо быть внимательней!
// А мы тем временем идем дальше. Я говорил (писал) о том, что наши функции
// способны принимать у себя аргументы, как раз для этого служат круглые скобки.
// Сначала разберемся на примере, как это работает. Допустим, при обявлении функции
// мы внутри круглых скобок пишем слово "user": "function humanSayHello(user) ...",
// а внутри фиг. скобок меняем наш код на вот такой, с конкатенацией (странное слово):
// "console.log("Hello " + user + "!");" -

/*

function humanSayHello(user) {
	console.log("Hello " + user + "!");
}

*/

// А теперь что? а теперь мы можем передать в функцию любой аргумент! не важно
// что это будет, самое главное что сейчас туда можно что-то передать, и это
// "что-то" будет использовано во время работы функции. Как не трудно заметить,
// наша функция будет выводить предложение, состоящее из 3-х кусочков: фразы
// Hello и пробела (чтобы "огородитть" первую фразу от второй), переменной user
// (о том, почему это переменная - позже), и еще восклицательного знака.
// Теперь я хочу скопировать закомментированный код (который выше, на 399
// строке) и добавить его, объявляя таким образом функцию:

function humanSayHello(user) {
	console.log("Hello " + user + "!");
}

// Отлично, а теперь осталось вызвать её. При вызове мы, внутри круглых скобок,
// добавим какое нибудь слово.. user означает пользователь, значит мы должны
// вписать в круглые скобки какое нибудь имя или ник! например.. Alex:

humanSayHello("Alex");
// => "Hello Alex!"

// Открываем консоль, а там какому-то Алексу привет передают!
// Как не трудно заметить, имя Alex подставилось под user в нашем коде, а это
// значит, что наш аргумент сработал! это хорошо, но что если запустить код
// не передав туда никакого имени (аргумента)? сейчас проверим! -

humanSayHello();
// => "Hello undefined!"

// Открыли консоль, а там undefined'у привет передали.. что-то странное творится.
// Теперь вспоминаем классификацию типов данных, которую мы проходили: если
// существует переменная, но значения она не имеет - её значением будет undefined!
// Как раз это мы и видим в предложении, выданным в консоль. Конечно, новичку
// понять всю эту механику аргументов с 1 раза сложно, а освоить еще труднее!
// У новичков сразу возникают вопросы: "а какие аргументы здесь могут быть?
// а как их правильно называть? сколько их должно быть?" и т.д.
// Именно поэтому мы разберем еще 1 наглядный пример - представьте себе
// калькулятор, самый обычный. Мы можем вводить в него самые разные числа, затем
// складывать их, перемножать друг на друга и проводить другие математические
// операции! по факту, калькулятор это один большой сборник функций.
// И мы с вами сейчас реализуем свой собственный калькулятор - функцию, которая
// будет называться "calc", от англ. слова "calculator" (калькулятор).

// Начинаем мы всё с того же ключевого слова function, после него ставим вписываем
// имя функции (calc) и открываем круглые скобки. Внутри них будет располагаться
// сразу несколько аргументов, и чтобы их разделить используется самая обычная
// запятая. Аргументы мы назовем просто - "a" и "b", и в этих двух аргументах
// раскрывается первый постулат - то, что мы можем называть аргументы как угодно.
// Если это маленькая функция, мы можем назвать аргументы просто - "a" и "b", или
// "c" и "d" и так далее, если же функция масштабная, которая выполняет много
// действий, то аргументы лучше называть так, как вы хотите их использовать.
// Например - передаете имя пользователя - называете аргумент "username",
// передаете возраст пользователя - называете userage и так далее.
// Кстати, несколько слов о нескольких аргументах - да, их может быть сразу
// несколько у одной функции, может быть 2, может быть 3 - а может быть и 100!
// Количество аргументов зависит от того, сколько их будет использовать функция
// внутри - если ей нужна 3, то мы прописываем 3 аргумента! вот и всё.
// После круглых скобок открываются фигурные скобки.
// Вот и прототип нашего кода, его "скелет", так сказать:

/*

function calc(a, b) {
	...
}

*/

// Хорошо, но как мы будем складывать передаваемые в виде аргументов числа,
// затем как-то выводить сумму в консоль? очень просто:

function calc(a, b) {
	console.log(a + b);
}

// Готово! код выглядит тупеньким (так оно и есть), но это не шутка - таким он
// и должен быть, наипростейший калькулятор. Мы выводим в консоль сумму a и b.
// Пример работы функции:

calc(4, 5);
// => 9

// Как мы видим, функция работает вполне исправно и без перебоев.
// А теперь пришла пора использовать функции на полную!
// Скопируем код выше, заменив передаваемые числа на другие:

calc(4, 8);
// => 12

calc(14, 5);
// => 19

// Здесь мы каждый раз будем получать разный результат, и в этом основное пред-
// назначение функций! то, что мы теперь можем не дублировать код - мы просто
// задали несколько аргументов, и теперь просто переиспользуем эту функцию,
// получая разный результат, в зависимости от каких-то входящих данных.
// При этом, какие это данные будут - мы заранее абсолютно не знаем.
// Такой подход можно прекрасно использовать в наших веб-продуктах: например, на
// веб-сайте есть несколько модальных окон, и в зависимости от того какую вы
// кнопку нажали, соответственно открывается и другое модальное окно. Точно
// также мы можем создать функцию, openModal например - она будет принимать
// 1 аргумент, и в этот аргумент будет попадать название того модального окна,
// которое мы хотим открыть. Представим, что в правом нижнем углу нашего сайта
// находится мини-блок, который "преследует" нас по всему сайту. В этом мини-блоке
// написано: "Есть вопросы? напишите нам!", и ниже этого текста есть кнопка с
// надписью "НАПИСАТЬ" - при клике на эту кнопку открывается модальное окно с не-
// сколькими полями ввода, для того чтобы мы могли написать наш вопрос и отправить
// его модераторам на рассмотрение. Так вот - при клике на кнопку "НАПИСАТЬ" в
// функцию подставляется именно то самое модальное окно, о котором я написал
// немного выше, и выводится пользователю. Точно такой же функционал можно
// провернуть и с закрытием мод. окна -  мы кликаем на крестик определенного
// мод. окна, у нас срабатывает функция closeModal с соответствубщим аргументом,
// а аргументом будет то модальное окно, которое мы только что закрыли!
// Так что вот.. так что всё вот так. Напоминаю, что функции - самый маленький
// фундаментальный кирпичик любой программы. Но нам этом мы с вами еще не закон-
// чили, это еще не всё о синтаксисе функций. Дальше мы будем говорить о синтаксисе
// функций, и постепенно будем углубляться в них!

// Синтаксис (часть вторая)

// А говорить о синтаксисе и дальше, мы будем чуть позже!