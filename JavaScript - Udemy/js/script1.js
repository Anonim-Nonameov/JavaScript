// Что такое JavaScript.

// Когда создается веб-продукт (будь-то сайт, интернет-магазин, или веб-приложение) в нем
// учавствуют сразу несколько технологий. В любом случае, там будет HTML. Это язык разметки, т.е
// скелет нашего сайта. Потом, мы на этом скелете наращиваем "мясо" - добавляем стилистики.
// Это могут быть шрифты, цвета, расположение элементов и прочее. За всё это отвечает CSS - 
// это язык стилей. И дальше, всю эту конструкцию необходимо заставить работать. Для этого
// уже нужны языка программирования, в том числе и JS, PHP, базы данных и прочее.
// Но мы остановимся именно на JS.

// Вопрос:

// Для чего используется этот язык?

// Ответ: он используется для придания сайту интерактивности. В далекие 95-ые годы, сайты делались
// на таблицах, и грузились крайне медленно. Было принято решение ускорить их, и сделать так,
// чтобы реагировали на действия user'а. Тогда, кучка программистов закрылась у себя в комнате
// и принялись они создавать новый язык. Управились они за пару недель (быстро ж они), так как
// сроки уже поджимали.

// Вопрос:

// Почему язык называется JavaScript?

// Ответ: всё дело в популярности и желании хайпануть. Раньше, был популярен язык Java, и чтобы
// придать языку популярности было принято решение назвать его JavaScript. Сам язык никак не связан
// с Джавой, так что путать их - нельзя.

// Вопрос: что значит скрипт?

// Ответ: скрипты это как раз инструкции, которые должен выполнить браузер к моему сайту.
// Скрипты пишутся в отдельном .js файле, так и внутри index.html файлика, в теге script. Но,
// писать js код внутри html файла - плохая практика. Внутри html файла пишут только маленькие
// скрипты, всё остальное - внутри отдельного файла.

// Вопрос: как подключить скриптовый файл?

// Ответ: в html файле, у тега script прописываем атрибут src, а внутри кавычек пишем
// путь к файлу.

// Переменные: что это такое и как их применять.

// И первое с чего мы начнем наше изучение JS - с информации.
// В мире программирования всё состоит из информации.
// Это всякие теги на странице, файлы, и даже действия пользователя на странице.
// Всё это - информация, и для того чтобы в дальнейшем её использовать, нам
// необходимо её как-то сохранить и куда-то поместить. Для этого в программировании
// существуют переменные. Допустим, у нас есть какая-то информация - например, яблоко.
// Мы её хотим сохранить чтобы в дальнейшем её использовать. Но как?
// А мы берем коробку (наша переменная) и ложим яблоко в..
// А, нет! Перед этим нашу коробку надо как-то назвать, иначе мы потеряемся,
// если таких коробок будет множество. Наклеим на неё наклейку c надписью "apples",
// создавая  таким образом нашу переменную, нашу коробочку. И теперь, когда мы создали
// переменную, мы можем эту информацию использовать. Причем использовать её мы можем
// разными способами: можем как достать это значение (значение - информация, лежащая
// внутри нашей переменной), чтобы потом съесть его, например, или что-то другое сделать,
// или поменять это наше значение. Ну например мне надоело хранить в коробке яблоко,
// которое я так и не съел, и поместил туда апельсин. Всё, старого значения теперь нет,
// там теперь апельсин, другая информация.
// Именно так всё и работает. Теперь посмотрим на всё это в коде.

// Создать коробку, переменную, очень просто: для этого используются ключевые слова
// var, let и const. Что такое ключевое слово? это спец. слова, внесенные прямо
// в ядре языка, и используемые по умолчанию. var означает variable (англ. переменная),
// но использовать var - не рекомендуется т.к он уже устарел (старичок работает уже с 1995 года!),
// но мы сейчас его заиспользуем в качестве примера того, как создать переменную.
// let - аналог var. А const - условная константа, которую никак нельзя изменить.

// Придумываем наше название. Мы хотим, чтобы в нашей коробке хранилась числовая информация,
// значит имя коробки должно быть "number". Чтобы присвоить переменной значение, надо после
// её названия поставить знак равенства = (в js он выступает в роли присваивалки значений), и после
// этого знака написать значение и поставить точку с запятой, это очень важно (почему так -
// я объясню, но чуть позже):

var number = 5;

// var - ключевое слово для создания переменной.
// number - название нашей коробки, переменной.
// = - этот знак присваивает значение нашей переменной.
// 5 - сама информация, лежащая внутри переменой.
// ; - спец. символ, обозначающий то, что наша "команда" - завершилась тут, это точка остановки.

// Таким образом, у нас есть готовая переменная с некой информацией. Круто!
// Но прежде чем её использовать я скажу, что то что мы сделали - называется не "создание"
// переменной, а "объявление". Технически мы её создали, но почему-то это принято называть
// "объявление переменной". Т.е мы объявляем в нашем файле, что теперь у нас есть такая-то
// переменная с таким-то значением.
// Теперь мы можем её использовать. В этом нам поможет команда "alert()", которая
// выводит в браузере диалоговое окно с какой-то информацией.
// Внутри скобок мы напишем название нашей переменной - "number", таким образом
// мы дадим понять нашей функции, что она должна вывести значение нашей переменной на страницу.

// UPD:  13.09 / 7:57 - закомменитировал вызов впл. окна, т.к консоль node такое
// поддерживает, и всё ломается.
// alert(number);

// Если мы сейчас зайдем на нашу страничку в браузере, нам покажется диалоговое окошко
// с надписью "5" (а это, собственно, значение переменной number). Значит всё работает!)

// Теперь мы напишем то же самое, только в современном виде:

let num = 10;

// Ничего не произошло, бомба не взорвалась. Отличается разве что ключевое слово и название
// переменной, да и значение тоже.
// И вот, теперь мы попробуем изменить наше значение. Я помню, что значение переменной num
// равно десяти, но я замению его на 7. Для этого достаточно написать название переменной,
// поставить знак равенства и написать НОВОЕ значение для нашей переменной. Делается всё это
// без ключ. слова let, т.к оно отвечает  именно за создание переменной, а она у нас уже
// объявлена.

num = 7;

// Всё, теперь num равен не 10, а равен 7.
// Таким образом, мы "прогнали" значение 10 из переменной (бедная десятка..) и присвоили другое.
// То же самое и с константами:

const pi = 3.14;
// pi = 5; - выдаст ошибку!

// Вся соль в константах заключается в неизменяемости значений.
// Менять их - нельзя, строго запрещено! Да и + ко всему - это разрушит нашу программу
// и остановит её выдав ошибку, что мы пытаемся изменить значение неизменяемой переменной.
// На самом деле, в JS как таковых констант НЕТ, и изменить значение константы МОЖНО,
// но очень сложно и это займет много-много времени.

// Ну а теперь  мы ближе посмотрим на var и let, и поймем, почему не рекомендуется
// использовать устаревший var, а рекомендуется использовать современные let и const.
// У var есть одна интересная особенность - по англ. она называется hoisting, а по Русски
// "всплытие". Что это значит?
// Если я сейчас объявлю переменную, присвою ей значение, то потом я могу его изменить:

var example = 10;
example = 15;

// В принципе всё нормально, так и должно быть, мы создали переменную а потом
// её поменияли (точнее значение переменной).
// Но, если я захочу изменить значение переменной ДО её создания - это сработает!

example2 = 15;
var example2 = 10;

// Это может показаться странным, ведь мы еще не создали такую переменную, её еще нет..
// но тем не менее так и должно быть, это нормально.
// А по простому - всё дело в том, что var переменная создается еще до того, как наш
// скрипт начал работать. Происходит это так:

// Когда браузер начинает запускать файл script1.js, он начинает ооочень быстро его просматривать.
// Находит переменную, объявленную через var (т.е - ищет такую переменную).
// Он их сначала создает, т.е коробка уже есть, но в ней ничего нет.
// После этого запускается скрипт, начиная с первой строки.
// Он идет по файлу, идет.. и вдруг видит - тут переменная начинает
// использоваться! (строка 137) в неё присваивается переменная три, и затем присваивается
// переменная пять. Это поведение и называется "всплытие" (hoisting), и конечно, когда
// кода намного намного больше, и конструкции сложнее - могут начать появляться ошибки.
// Поэтому куда очевиднее поведение, когда мы сначала создали переменную, и только
// потом мы можем её использовать.
// Но в случае с let - всплытие не произойдет, это поддерживает только var, а с let
// мы создаем переменную и только потом можем её использовать, и с const то же самое.
// Вообще, у var есть еще кое какие особенности по "области видимости", но об этом -
// в следующих уроках. Но сейчас нам (мне) необходимо понять, что в современном JavaScript'е
// используются let и const, var - устаревший формат, который канул в лету.

// Точка с запятой

// Новички в JS часто задаются вопросом: когда ставить точки с запятой?
// Как не трудно заметить, они у меня в коде стоят везде, в конце каждой строки.
// Их можно не ставить (я, например, раньше не ставил их), JS это простит, но всё
// таки их лучше СТАВИТЬ. Например, когда логическое утверждение завершено (например,
// когда мы объявили переменную) - не будет лишним поставить ; :)

// А теперь о ошибках, которые могут случиться если ; не ставить.
// Допустим, мы хотим вывести в браузер диалоговое окно с цифрой пять,
// и после этого мы делаем еще какие-то сложные действия:

// Закомментировал, чтоб ошибок не было.
// alert(5)
// [].push('a'));

// Нам выдаст ошибку, типа "что это за символ ]?"
// Всё из-за того, что мы не указали где наше логическое утверждение кончается.
// Браузер не знает, где кончается команда "alert(5)", и начинает "паниковать".
// Чтобы это не происходило - ставим ;

// alert(5); закомментировал, раздражает при загрузе страницы
[].push('a');

// Но чтобы ошибку увидеть, надо убрать комментарии с кода на 177 и 178 строке
// и потом зайти в браузер, нажав ctrl + shift + i.
// Таким образом, откроется консоль разработчика. Консоль разраба это "помощник"
// верстальщика, где на первой вкладке можно увидеть весь HTML и CSS код, где стоят
// отступы и какие, стили примененные к элементам и т.д.
// Но нас интересует вторая вкладка - "Console"!
// Там мы можем отслеживать ошибки кода, писать туда что-то важное и т.д.
// Подробнее можно прочитать в гугле :)

// Хорошо, теперь мы разобрались с точкой с запятой, узнали об ошибках и консоли,
// узнали что такое переменная и как с ней работать.
// Но мы не знаем какой тип данных туда можно отправить, т.е какая информация там
// может располагаться? а об этом - в след. уроке!

// Типы данных и взаимодействие с пользователем

// Что такое типы данных?
// Типы данных - это та информация, которую мы можем использовать в своих скриптах.
// Это может быть что угодно, и у них есть своя классификация, с которой мы ознакомимся (в
// текстовом виде, конечно).
// Типы данных разделяются на две большие группы - простые и сложные (комплексные), а по
// другому - объекты.
// Начнем с простых типов данных.

// Первым типом данных из простых идут числа.
// Это один из самых легких и простых типов данных, и с ним мы можем обозначать цифры
// по порядку - 1 2 3, или считать сумму зарплаты за месяц - 1000, 2000, 3000 и т.д, или
// считать кол-во пользователей посетивших наш сайт. Всё это отображается в числовом виде.

// Следующих тип данных - строки.
// Ни для кого не секрет, что если записать какое нибудь выражение, например "Иван",
// это уже не будет числом. Это будет какое-то описание, т.е то что мы можем написать как
// обычную строку. Так что если мы что-то пишем в виде текста - это строка.
// Попробуем записать какую нибудь информацию в переменную, например ту же строку -

let myName = "Alex";

// Ну вот, теперь наша переменная содержит в себе строку, текстовую информацию.
// Важно знать - текстовая информация ВСЕГДА содержится в кавычках, и в JavaScript'е
// неважно какие мы используем - одинарные, двойные или обратные (``).


// Кстати, мы написали "My name" как "myName". Что это значит?
// Это такой стиль написания названия переменных, camelCase (верблюжий регистр).
// Допустим, название нашей переменной состоит из двух, трех и более слов, и как нам создать
// переменную с таким названием? ведь пробелы в названии переменных не допустимы!
// Разделять всё это при помощи тире "-", или нижнего подчеркивания "_" - не красиво,
// и люди придумали специальные стили для написания имен переменных. Самым популярным
// считается camelCase. При использовании этого стиля, первое слово в переменной пишется с
// маленькой буквы, все остальные - с большой, заглавной.
// Ну, например слова "My name" мы запишем
// как "myName", или "My apple" как "myApple", или "My personal computer" как
// "myPersonalComputer" и т.д.

// Следующий тип данных - логический (булевый).
// Он содержит в себе либо правду, либо ложь (true & false).
// Создаем реальную конструкцию. Если вы читаете это с компьютера - то вы отвечаете "да,
// это правда", или по другому - true. А если с телефона - то это ложь (false).
// Соответственно, вот такие вот логические утверждения будут содержаться в нашем коде и мы
// будем их использовать. Например, в коде мы можем проверить - открыто ли модальное окно.
// Если вдруг окно открыто, мы получаем булевое значение - true, ну и в зависимости от этого
// ответа мы можем уже какие-то действия выполнить, или наоборот - запретить.
// Например - если открыто модальное окно, пользователь не может скроллить страницу.
// А теперь создадим переменную с булевым значением:

let bool = true;

// Ну вот, теперь в нашей переменной содержится логическая информация (true).

// Следующие два типа данных - null и undefined.
// Различать их довольно просто, главное ПОНЯТЬ как они работают.
// null - это когда чего-то просто НЕ СУЩЕСТВУЕТ, его нету.
// undefined - это когда что-то есть, что-то существует, но у него нет значения.
// А теперь разберем на простых примерах.

// Изменим значение несуществующей переменной "modal":

modal = 'игзампл оф код ин жс';

// Попытаемся вызвать диалоговое окно с несуществующей переменной "a":

// alert(a); (закомментировал, т.к это вызывает ошибку)

// Если мы попытаемся вызвать диалоговое окно с переменной modal - это выдаст
// нам ошибку, что перем. modal - не объявлена (такой переменной нет!), это undefined.
// А что касается несуществующей переменной "a", с которой мы хотим вызвать диалог. окно
// на 269 строке, то её НЕТУ, вообще нету, а это - undefined.
// Если мы раскомментируем код на 269 строке и откроем, перезагрузим наш
// браузер, в консоли нам выдаст оишбку - "a is not defined" и код выполняться дальше
// не будет (как раз по этому я его закомментировал).

// Еще один пример - создадим переменную modal2, но не зададим ей никакого значения:

let modal2;

// Мы взяли коробку, наклеили на неё наклейку с названием, но внутрь ничего
// не поставили, она пустая - это и есть значение undefined, "неопределённое".
// Чуть позже мы узнаем, как получить такое значение в консоль, а сейчас идем ко следующему
// типу данных.

// Следующие типы данных - symbol & bigint.

// Symbol и bigint появились совсем недавно.
// symbol - это технический тип данных (не понял что это значит, ну да ладно),
// который появился в стандарте ES6. По факту верстальщики редко с ним сталкиваются,
// так что пока надо просто знать что он есть.
// А вот bigint появился совсем недавно - летом 2019, в самом последнем ES
// стандарте (на момент создания урока). Если говорить о bigint'е совсем по простому,
// то это ОЧЕНЬ большие числа, которые не влазеют ни в какой диапазон.
// bigint (расшифровывается также как big integer) это числа, которые больше чем
// 2 в 53 степени. Дело в том, что у обычного типа данных number есть, так
// скажем, свой собственный лимит. Если мы запишем число в типе данных number,
// которое больше чем 2 в 53 степени - у нас могут появиться ошибки с
// обработкой таких чисел. Именно поэтому был создан отдельный тип данных, bigint,
// как раз туда включаются все числа из этого диапазона. Т.е, это такое
// хранилище таких огроооооомных чисел :D

// А теперь пора бы на простых примерах поговорить о массивах и о объектах.

// Сначала возьмем какую-то информацию, например апельсин.
// Мы же можем его как-то описать, верно? верно!

// Скажем, что: категория - фрукт.
// Форма: круглая.
// Цвет: оранжевый.
// Вес: 300 грамм.

// И сейчас мы описали какую-то конструкцию, информацию - в деталях, и то же самое
// мы можем сделать в коде. Т.е, в коде мы можем что-то описать при помощи такой
// же конструкции, объекта.
// Объекты состоят из двух внутренних "категорий", свойства и метода (не понял,
// почему не "значения"). И вот, на примере апельсина мы описали все его 
// свойства: категория, форма и так далее, т.е что он может в себя включать, или
// как нам его можно описать.
// И не трудно заметить, что объект как комплексный тип данных может включать
// в себя различные типы данных. Это значит, то что мы описали апельсин как "фрукт",
// это строка, string. Описали то, что он весит 300 грамм - а 300 это число, number.
// И, соответственно, свойтва могут содержать ЛЮБЫЕ типы данных.
// И даже можно создать объект в объекте, который находится в объекте, который
// находится в объекте и так далее, это возможно. (:D)
// И я еще сверху написал про "методы". Любая конструкция может не просто
// существовать, она также может что-то делать. Ну, апельсин вряд-ли может что-то
// делать - максимум сгнить :D Поэтому, возьмем другой пример - пылесосъ.
// Пылесос, как объект, можно описать:
// 1. - опишем его модель
// 2. - его вес
// 3. - его МООООЩНОСТЬ!!!;
// И, соответственно, он может что-то делать. Например - пылесосить пыль (блин,
// как же странно и глупо это звучит.. :D) на нашем полу.

// Собственно, объекты служат нам чтобы мы могли описывать какие-то сущности.
// Эти сущности могут быть на нашем сайте - например модальное окно.
// Мы можем описать его ширину, высоту, что он умеет делать (закрывать что-то,
// отправлять формы и т.д), как открывается и прочее-прочее.
// Таким образом, при помощи объекта как комплексного типа данных мы можем
// всё это красиво и опрятно описать.
// Ну вот, с объектами разобрались - теперь о массивах.

// Для начала скажем, что массив - "детище" объекта, это не отдельный тип данных.
// А теперь: что же такое массив? Массив - конструкция, позволяющая нам записать
// какие-то данные ПО ПОРЯДКУ, строго по порядку. Что это значит? например, если
// мы хотим создать массив из каких-то вещей, то мы берем одну вещь, ставим запятую и
// следом за ней ставим другую вещь, и таким же образом ставим третий предмет.
// Таким образом у нас получается строгий порядок в массиве. И так же как в объектах,
// нам не важно какие элементы хранятся в массиве. Это могут быть числа, строки,
// объекты, другие массивы и функции. Так что массивы служат для расположения
// элементов (вообще любой информации) строго по порядку, и это их основное
// предназначение. Как реальный пример, мы можем взять и написать список ссылок
// на каике-то картинки (ЧЕРЕЗ ЗАПЯТУЮ), и потом их использовать. Или список
// заголовков и т.д.

// В коде объекты создаются просто: также через ключ. слово let, названия, знака
// равно (присваивания в JS), фигурных скобок и ;. Внутри фиг. скобок как раз и будут
// располагаться наши свойства. Объект можно создать, но внутрь ничего не записывать!
// Т.е, мы создаем объект, пишем фиг. скобки - но внутри их никак не заполняем.
// Таким образом объект создается, но не используется.
// Создадим наш первый объект, а первым свойством будет dog со значением "Puppey" и
// свойство cat, со значением "Murrr":
 
let obj = {
	dog: "Puppey",
	cat: "Murrr"
};

// Если нам в объекте нужно больше 1 свойства, то мы ставим запятую и прописываем
// следующее. Желательно ставить запятую даже на самом последнем свойстве, чтобы
// мы могли перемещать свойства как хотим - самое последнее в самое начало, самое
// первое свойство на место самого последнего и так далее.
// И да - свойствами объекта может быть что угодно: массивы, строки, числа, и даже
// другой объект может быть свойством.

// А как нам создать массив? всё очень просто - используем ключ. слово let,
// придумываем название и пишем его, ставим знак равно и пишем квадратные скобки,
// а в конце как обычно стоит ;.
// Опять же - мы можем оставить массив пустым, т.е просто создать его и всё, его
// необязательно заполнять. Но мы таки заполним его:

let arr = [1, "str", false];

// Ну вот - массив создан, теперь мы можем его использовать.
// Кроме того, мы можем "взять" элемент из массива - для этого мы записываем имя
// нашего массива, ставим квадратные скобки и указываем его позицию, индекс.
// Позиции элементов в JS начинаются с 0, т.е - в нашем массиве элемент "1"
// занимает нулевую позицию, а элемент "str" занимает первую позицию. А какую
// позицию занимает элемент "false" - не трудно догадаться :)
// А чтобы узнать кол-во индексов в массиве, достаточно знать его длину: кол-во
// индексов в массиве равно его длина - 1. Т.е, если его длина равна 5 (5 элементов
// внутри массива), то кол-во индексов - 4.

arr[0];

// А еще мы можем ИЗМЕНЯТЬ элементы массива. Для этого опять же прописываем его имя,
// ставим квадратные скобки, но на этот раз после квад. скобок ставим знак равно (=)
// и после него записываем новое значение:

arr[0] = 2;

// Теперь в нашем массиве элемент "1" заменен на "2".
// Было: [1 "str" false]
// Стало: [2 "str" false]

// А теперь пора бы научиться работать с консолью. О том что такое консоль я уже писал,
// так что сразу про команду которая будет что-то выводить в консоль: console.log().
// console.log() выводит значения в консоль, неважно какие - значения переменных,
// массивов, свойств объекта и т.д. Также в скобках можно написать простую строку:

// console.log("Hello World!") (закомментировал, лишнее - просто как пример) 

// Код выше выведет в консоль всем известную фразу, Hello world :D
// Значит так: эта команда может выводить не только значения переменных, массивов
// и объектов - она может выводить и простые строки, числа и булевые значения
// (True/False). Вообще, console.log() самая простая команда для проверки нашего
// кода, а именно: проверка на существование переменной, есть ли такой-то элемент
// в массиве (или объекте) и т.д. Это то мы сейчас и будем делать.
// Не так давно я создавал переменную modal2, но не задал ей значение. Сейчас то
// мы и проверим, что находится внутри неё:

console.log(modal2);
// => undefined

// Если мы сейчас зайдем в консоль браузера, то заметим, что в консоли появилась
// надпись "undefined" - это и есть значение нашей переменной.
// Об этом типе данных мы не так давно говорили - это когда что-то существует,
// но значения никакого оно не имеет.
// Но, мы создавали переменную "myName", а у неё есть значение - его то мы и
// выведем в нашу консоль:

console.log(myName);
// => "Alex"

// И опять же - JS "прощает" некоторые ошибки, которые мы можем допустить в нашем
// коде, ибо JS и был для этого создан - для "не программистов" (это из разряда
// "верстальщики - не программисты").
// Ну так вот - попробуем выполнить какую нибудь неочевидную операцию, например -
// будем делить 4 на 0 и результат выведем в консоль:

console.log(4 / 0);
// => Infinity

// Ну вот - даже если произошла не математическая операция, то что сделать действительно
// нельзя - у нас не вылезет ошибка, а специальное значение - Infinity, бесконечность.
// Оно выдается тогда, когда мы делаем ошибку в математическом выражении. Это значение
// не крашит код, но всё же означает ошибку.
// Кстати, можно даже получить "минус бесконечность" - -Infinity:

console.log(-4 / 0);
// => -Infinity

// Кстати - значение "Бесконечность" входит в тип данных "числа".
// И да - есть еще один не логичный момент - выдача значения NaN.
// NaN означает "not a number", не число. Его выдает в том случае, когда мы хотим
// сделать ту мат. операцию, которая выходит за рамки всех законов - например,
// умножаем строку на число:

console.log("string" * 9);
// => NaN

// NaN также как и Infinity входит в тип данных "числа".
// Вы скажете - "как же так? расшифровка слова означает «not a number», а
// перевод «не число»!"
// А я отвечу - "да я без понятия!"
// А если серьезно, то я действительно не знаю почему так. Именно поэтому то я
// выше и написал, что "есть еще один НЕ логичный момент - выдача значения NaN".

// Операторы

// Вы наверняка заметили, что мы в коде выше применили самые обычные математические
// конструкции - что-то делили, складывали и т.д. А как мы это делали? Точнее, с
// помощью чего?  Вы скажете - "при помощи знаков плюс и т.п", а я отвечу - "при
// помощи ОПЕРАТОРОВ!".
// В JS эти знаки называют "операторы", а те элементы к которым они применяются -
// "операнды". Например, в выражении "1 + 2" оператором является "+", а операндами
// являются числа "1" и "2". Большинство операторов знакомы нам со времен школы,
// к примеру - оператор сложения: "+"; оператор присвоения: "=" (математическое
// равно); оператор деления: "/".

// Ну вообще, знаки присваивания не так интересны как инкремент и декремент - но
// о них позже. А сейчас мы поговорим о знаках присваивания. Если вы, читатель,
// помните, я выше писал что знак "=" не означает равенство, это оператор
// присваивания значения. Если же я хочу написать в консоль, что "2 + 2 = 4", таким
// образом: console.log(2 + 2 = 4) - выдаст ошибку. Оператором равенства является
// знак "==" (два знака равно). Если мы запустим такой код, то увидим, что нам
// выдаст "true" - 2 + 2 равно 4, это истина! 

console.log(2 + 2 == 4);
// => true

// Если же мы поставим не два, а три знака равенства - нам также выдаст true:

console.log(2 + 2 === 4);

// Если мы поставили три знака равно, это не просто оператор сравнения - это
// оператор СТРОГОГО сравнения. Чем же он отличается от обычного?
// А тем, что обычный оператор сравнения НЕ сравнивает типы данных, а строгое
// сравнение - наоборот, сравнивает. Что это значит? приведу пример:

console.log(2 + "2" == 4);
// => false

// Если мы зайдем в консоль то увидим, что нам выдало false. Оно и верно, числа
// и строки - два разных типа данных, но при сложении числа со строкой у нас вышло
// число: 2 + "2" дало 22, а 22 не равно 4 - но об этом позже.
// А теперь пример полегче:

console.log("4" == 4);
// => true

// Снова заходим в консоль и наблюдаем такую картину: true.
// Почему? всё это произошло потому что в JS оператор сравнения берет и приводит два
// операнда к единому типу данных - т.е, он строку "4" привел к числу: из "4" в 4.
// А дальше дело логики: 4 == 4? Ответ: true.
// НО, оператор строгого сравнения не приводит типы данных - он сразу их проверяет!

console.log("4" === 4);
// => false

// Ну вот, оператр строг. сравнения выдал false. Оператор строг. сравнения увидел,
// что в нашем примере есть и строка и чсило, и выдал false: "это два разных типа
// данных, ложь!" - сказал он.
// Как по мне, лучше всгео использовать оператор строгого сравнения, т.к он дает
// более точный ответ на наш вопрос.

// А теперь подробнее про сложение строки и числа.
// Помните код выше, когда мы сложили 2 + "2"? - это называется КОНКАТЕНАЦИЯ.
// Конкатенация - это сложение строк между собой. Например: "кото" + "пёс" -
// получится "котопёс". То же самое было и в коде выше - всё, что мы складываем со
// строкой - превращается в строку, т.е число 4 превратилась в "4", а "4" + "4"
// получается "44"! Всё, в принципе, просто.
// Повторю. Какой бы тип данных мы не складывали со строкой - всё будет превращаться
// в строку и никак иначе.
// И выше я упомянул про инкремент и декремент. Посмотрим что же это такое, на примере:

// Допустим, у нас есть переменная x со значением 5:

let x = 5;

// И мы хотим его увеличить на 1:

x = x + 1; // теперь x равен шести

// Что значит наша запись? простыми словами, мы говорим нашей переменной: "переменная
// x равна самой себе + 1", т.е шести.
// Но, программисты - люди ленивые (это правда :D), и они не хотели писать такую
// длинную запись лишь для того, чтобы увеличивать переменную на 1.
// Они решили придумать запись короче:

x += 1; // теперь x равен семи

// Эта запись ничем не отличается от записи длинее: x = x + 1, т.е:
// x += 1 равно x = x + 1.
// Но программисты пошли еще дальше, и еще больше укоротили запись:

x++; // а теперь и вовсе равен восьми!

// Знак "++" означает инкремент. Инкремент увеличивает значение переменной на 1, т.е:
// x++ равно x += 1, что в свою очередь равно x = x + 1.
// То есть разницы нет, x++ или x += 1, везде будет тот же результат.

// Чтобы убедиться в этом, я обратно верну значение x на 5 (т.к оно сейчас равно 8, мы
// постоянно его увеличивали) и применю инкремент:

x = 5;
x++; // x = x + 1

console.log(x);
// => 6

// Выдало 6, как мы и ожидали.
// Но нам этом не все - инкремент работает и в обратную сторону: встречайте, декремент! -

x--;

console.log(x);
// => 5

// Декремент работает также как и его старший брат, инкремент - но он не увеличивает на 1,
// а наоборот - уменьшает на 1. Т.е: запись x-- равна записи x = x - 1.
// И кстати, помните запись x += 1? Ну так вот, есть такая же - только вместо
// плюса - минус: x -= 1. Ну а теперь о нашем коде выше - раньше, мы увеличивали x (5)
// на 1, получалось 6. А потом мы уменьшили 6 на 1, опять получилось 5 - его то
// нам и выдало в консоли. Короче - всё просто!

// Взаимодействие с пользователем

// JS был создан для работы пользователей с ним, так как это язык который добавляет
// интерактивность на наш сайт.

// Мы научились выводить что-то в консоль и это хорошо, но JS этим не ограничивается!
// Да и пользователь нашего сайта вряд-ли будет лезть в консоль и взаимодействовать
// с нашим сайтом именно оттуда :) Поэтому, мы должны скорее научиться работать с
// пользователями на нашем сайте. Для работы с пользователями в JS есть различные
// методы, и первый из таких методов, с которым мы уже познакомились - команда console.log().
// Но напоминаю, что пользователи не станут лезть в консоль лишь для того, чтобы
// вызвать модальное окно (хотя, я где-то видел такой сайт - в консоли пишешь команду,
// а там что-то вылазеет, мод. окно например). Следующий взаимодействия с пользователем -
// команда alert(), с которой мы уже знакомы.
// Эта команда выводит диалаговое окошко пользователю, не более. В общем - скукота.

// Следующая, третья команда для взаимодействия с пользователями - confirm().
// Она выводит такое же диалоговое окно, но уже с двумя вариантами ответа:
// 1. - "Отмена"
// 2. - "ОК".

	// confirm("Вам есть 18 лет?"); (посмотрел как она работает и закомментировал, мешает - если что уберите комментарий)

// На самом деле - это тоже бесполезная команда, от обычного alert почти
// нет отличий.. всего-то кнопку другую добавили.
// Но с этой командой можно сделать одну интересную вещь, а именно - сохранить
// переданное значение в переменную! Например, мы нажали "ОК" - и в переменную
// сохранилась надпись "true", истина.
// Сделать это довольно просто - мы просто присваиваем переменной значение "confirm(...)",
// а затем выводим значение переменной в консоль:

	// let answer = confirm("Вам есть 18 лет?");
	// console.log(answer);
// => true при нажатии "ОК", false при нажатии "Отмена".
// P.S - закомментировал после того как посмотрел на работу, мешает.

// Когда мы выбираем один из вариантов ответа, значение сохраняется в переменную.
// true будет если мы нажмем на "ОК", соответственно false будет если нажмем на "Отмена".

// Следующая, четвертая команда - prompt().
// Эта команда также создает диалог. окно, но уже с полем ввода - мы можем вводить
// туда какой нибудь текст, число или ответ на вопрос.
// P.S - значение, получаемое prompt, можно записать в переменную также как и в случае
// с командой confirm().

	// let answer = prompt("Вам есть 18 лет?", "");
	// console.log(answer);
// => null, если ничего не было введено и нажата "Отмена"/введенное юзером значение
// P.S - закомментировал после того как посмотрел на работу, мешает.

// Здесь происходит то же самое, что и в случае с confirm() - введенное значение
// записывается прямиком в переменную, а далее - выводится в консоль.
// И да - вы наверняка заметили, что после предложения (в prompt()) идут пустые
// кавычки? ну так вот - это специально оставляется для IE (Internet Explorer),
// ибо без него могут произойти ошибки в работе команды.
// P.S - я сам не проверял, т.к у меня IE на компьютере НЕТ.

// А теперь немного практики!
// Мы с вами недавно изучили типы данных, и теперь знаем что такое "массив".
// Вспоминаем: массив по классификации относится к отдельному типу данных, основан
// на объектах, создается при помощи квадратных скобок и служит для хранения данных
// по порядку. Всё это мы знаем, всё вспомнили и теперь пора приступать!
// Мы научились хоть как-то взаимодействовать с пользователем на странице, и теперь
// давайте "пытать" нашего юзера вопросами и записывать ответы в массив данных.
// Чтобы сразу немного поработать со страницей, мы выведем какую-нибудь информацию на экран.
// Для этого есть самая простая команда - document.write(), но используется она - крайне
// редко, по одной простой причине - она заменяет ВСЁ на странице.
// Буквально всё. Если у нас был красивый-красивый сайт, с различными блоками/формами -
// он исчезнет, а точнее его содержиме - будет показана лишь та информация, которую
// мы передаем в качестве параметра (о параметрах и аргументах позже) в document.write.
// Поэтому, мы будем использовать эту команду лишь в целях обучения, не более. Использовать
// её в реальных проектах крайне не рекомендуется по выше указанной (написанной) причине.

// Итак, создаем массив "answers" НО никак не наполняем его.

let answers = [];

// P.S:
// Напоминаю, что в нем данные будут храниться ПО ПОРЯДКУ, т.е - первый элемент, второй
// элемент и т.д. И данные в нем (вообще в массивах) могут быть самыми разными - строки,
// числа, такие же массивы или объекты.

// Отлично, массив создан! А теперь приступим к его наполнению.
// Для этого, мы должны обратиться к массиву и указать в скобках цифру 0 (так как в JS,
// как и во многих других ЯП нумерация идет с нуля, а не с единицы как мы привыкли),
// а затем поставить оператор присваивания (=) и указать команду, например prompt - введенное
// значение будет записано в массив, и будет сам первым элементом:

answers[0] = prompt("Как ваше имя?", "");

// Отлично, теперь первым элементом массива будет результат ответа на вопрос "Как
// ваше имя?", а кавычки справа были поставлены для совместимости с IE.
// Дальше мы создаем еще две таких же конструкции, просто меняем вопросы!

answers[1] = prompt("Как ваша фамилия?", "");
answers[2] = prompt("Сколько вам лет?", "");

// А теперь мы выводим значения на экран:

document.write(answers);
// => "Ответ,Ответ,Ответ"

// Ну вот и всё, осталось лишь зайти в браузер и ответить на несколько вопросов,
// а результат будет виден на экране.

// P.S - при использовании document.write текст на сайте (заголовок второго
// уровня с текстом "Hello World") не стёрся. Странно, потому что у лектора
// весь сайт был "стёрт", в буквальном смысле этого слова.

// Циклы

// Теперь, когда мы научились взаимодействовать с пользователем и узнали, что такое
// объекты, массивы и прочее - пора бы поговорить о одной из самых важных тем в
// JavaScript'е, а именно - о циклах.

// Циклы есть практически во всех (ну, по крайней мере во многих) ЯП.
// Они позволяют выполнять код вместо нас, при этом мы можем указывать,
// сколько раз цикл может повторяться. Но не будем забегать вперед и начнем с
// "житейских" примеров, т.е из реальной жизни. Самый простейший цикл, который
// мы наблюдаем КАЖДЫЙ ДЕНЬ - дневной цикл. Но что это значит? что это за цикл
// такой, "дневной"? а сейчас поймете, всё очень просто:
// По утрам мы просыпаемся и идем в ванную, завтракаем, идем на работу (или
// в школу/универ), работаем/учимся, возвращаемся домой и дома занимаемся
// какими-то домашними делами, отдыхаем и затем ложимся спать, соответсвенно
// ночью мы спим. И на утро наш цикл повторяется: просыпаемся, идем в ванную,
// завтракаем и так далее. Наш цикл постоянно повторяется, без конца (ну или до
// тех пор пока мы не умрем, как бы печально и грустно это не звучало).
// Более сложный пример: годичный цикл. Его тоже мы наблюдаем каждый.. год.
// Например, каждую осень (начиная с 1/15 сентября) дети идут в школу,
// зимой (начиная с 31 декабря) стартует новый год (не, не тот что праздник,
// а реально новый, другой год.. ну вы поняли :D) или начинаются зимние каникулы.
// Каждый год у нас что-то да повторяется, соответственно цикл тоже.
// Если опять брать более житейские примеры, можем взять инструкцию по применению
// того же шампуня (как бы странно это не звучало, хахаха): мы берем и намыливаем
// голову шампунем (предварительно смочив их водой), затем смываем и повторяем
// процедуру второй раз (я обычно делаю один раз за всю водную процедуру, но не суть) -
// это тоже цикл. То есть цикл это то, что повторяется один и более раз, а по другому - это
// действия, доведенные до автомата (Калашников лучший, imho) и выполняющиеся каждый раз.

// В программировании всё то же самое, и непосредственно такой механизм (циклы) позволяет
// нам оптимизировать многие задачи. И как это реализуется - мы сейчас узнаем!
// В JS есть три вида циклов, но мы пока что расммотрим первый и простейший из них,
// самый популярный и используемый в 99% случаев. Важно запомнить, что циклов как таковых
// всего три, все остальные структуры (какое странное слово..) с которыми мы будем в дальнейшем
// встречаться - НЕ циклы. А теперь переходим к самим циклам, и как я уже выше сказал (написал) -
// начнем с самого популярного, с цикла for. Цикл for создается, как ни странно, при помощи
// ключ. слова "for" и круглых скобок. Внутри круглых скобок мы должны настроить наш цикл,
// как он будет работать и т.д. После периода настройки мы открываем фиг. скобки. Этот участок
// кода (с фиг. скобками) служит тем, что здесь выполняются те команды, которые будут
// выполнять какие-то действия внутри цикла.
// А вот как наш цикл будет выглядеть, его прототип:

/*
for (  аргументы ) {
	команды для цикла 
};
*/

// Внутри круглых скобок обычно присутствуют 3 аргумента, они конечно необязательные
// и задавать их тоже необязательно, но почти всегда мы будем их использовать и они
// будут нам помогать, а также в какой-то мере сокращать код:

// ПЕРВЫЙ АРГУМЕНТ - это задание начальной точки, т.е с чего наш цикл будет начинаться, и для создания
// такой начальной точки нам понадобится переменная (да, прямо внутри кругл. скобок!). Обычно
// такую переменную в циклах называют просто 'i', от слова "итератор" (он же "счетчик цикла"),
// и ставят значение равное нулю (не удивительно, цикл всегда должен начинаться с нуля), затем
// ставится точка с запятой (чтобы разделять аргументы). Выглядит всё это так: for (let i = 0;).
// Т.е, мы просто создаем некую "коробочку" (i) внутри цикла и кладем в неё значение "0". 

// ВТОРОЙ АРГУМЕНТ - отвечает за то, до какого периода наш цикл будет работать, или когда он
// должен остановиться. Например, если мы просто хотим вывести в столбик десять цифр, к примеру
// от нуля до девяти. Что мы можем сделать для этого? ну, мы можем сказать что наш цикл будет
// повторяться каждый раз, пока не достигнет определенного условия. Например, то что наша переменная
// i будет меньше чем десять: for (let i = 10; i < 10). Здесь условия могут быть разными, позже я
// покажу (расскажу) как это работает на реальном примере, но сейчас не об этом. Допустим что у
// нас есть 10 карточек с товарами на какой-то страничке, и мы можем пройтись по ним циклом, и
// сказать что пока у нас не закончатся эти карточки товаров, мы будем выполнять какое-то
// действие - например подкрашивать их в какой-то другой цвет. Ну и после того как мы указали
// условие, второй аргумент - ОБЯЗАТЕЛЬНО ставим точку с запятой, так как у нас следом за ним
// идет другой, третий аргумент!

// ТРЕТИЙ АРГУМЕНТ - отвечает за то, какое действие будет выполняться в теченни каждой итерации цикла,
// т.е каждый раз когда цикл будет повторяться. Например, если мы хотим вывести просто цифры подряд,
// столбиком, то каждую итерацию мы должны УВЕЛИЧИВАТЬ переменную i (он же наш счетчик, он же итератор)
// на 1 единичку: for (let i = 0; i < 10; i++).
// Отлично, теперь наш счетчик каждую итерацию будет увеличиваться на 1.
// Но мы можем сделать так, чтобы он наоборот уменьшался - i--, или чтобы он увеличивался не на 1,
// а сразу на два (а чего мелочиться? можем себе позволить!): i + 2.

// Отлично! с аргументами мы разобрались, но что же нам со всем этим добром делать? у нас же
// есть фигурные скобки, но они пустуют!
// К примеру, можем вывести все числа которые пересчитал счетчик в консоль:

for (let i = 0; i < 10; i++) {
	console.log(i);
}

// => 0, 1 (с новой строки), 2, 3, 4... (так далее, до 9)