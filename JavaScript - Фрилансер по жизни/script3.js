// Числа

// В JS существуют 2 типа чисел - это обычные числа в 64-х битном
// формате (с которыми мы и будем чаще всего работать) и bigInt, числа которые
// позволяют работать с целыми числами приозвольной длины (или же просто ОГРООООМНЫЕ
// числа :-D). Но в этом уроке про числа, ФПЖ будет говорить только о простых числах.

// Записать простые числа в JS можно следующим образом -
// создать переменную с числовым значением и работать с ней дальше.
// Но мы выведем значение переменной в консоль:

// Число
let someNum = 458
console.log( )
console.log(someNum)

// Или же просто в console.log() написать интересующее нас число:

console.log( )
console.log(854)

// А десятичные числа пишутся ОБЯЗАТЕЛЬНО через точку, но выводятся
// в консоль они так же легко как и простые:

// Десятичные числа
let someNums = 4.58
console.log( )
console.log(someNums)

// А вот мы вызываем это же число просто через console.log():

console.log( )
console.log(8.54)

// А в ситуации, когда нам надо работать с крупными числами (или наоборот,
// оооооочень маленькими), к примеру миллион -
// мы можем написать это число простым способом:

let someBigNum = 1000000
console.log( )
console.log(someBigNum)

let someLittleNum = 0.000001
console.log( )
console.log(someLittleNum)

// Или же, мы можем сократить эту запись чтобы не прописывать целых 6 нулей.
// После цифры 1 надо добавить латинскую "e", и поставить после "e" цифру 6.
// Она будет значить, что мы хотим вызвать в консоль/записать в переменную миллион,
// ибо в миллионе - 6 нулей.

someBigNum = 1e6
console.log( )
console.log(someBigNum)

// Фактически, единичка умножается на миллион, на единицу с шестью нолями.
// Или, это 1 умножить на 10 в шестой степени - 1 * 10^6


// А мааааааленькие числа как записывать?
// Синтаксис схож с записью "1e6", т.е такие малюсенькие числа вкратце
// записывают почти так же, как и миллион, но после латинской "e"
// ставится знак минуса "-". Т.е "e" минус количество нулей - e-6.

someLittleNum = 1e-6;
console.log( )
console.log(someLittleNum)

// Фактически, единица делится на миллион, единицу с шестью нолями.
// Или, это 1 умножить на 10 в минус шестой степени - 1 * 10^-6

// Шестнадцатеричные, двоичные и восьмеричные числа

// Шестнадцатеричные числа широко используются в JS для представления цветов,
// кодировки символов и многого другого.

// Как записать число в шестнад. системе?
// Ну, пока что возьмем число 255. Синтаксис написания простой, но непонятный.
// Пишется всё вот так:

console.log( )
console.log(0xFF, '- 0xFF') // => 0xff => 255, шест. система счисления

// 0x - указывает на то, что это шестнадцатеричная система счисления.
// FF - указывает на кодировку/код числа.

// Причем регистр не имеет значения - написали мы 0xff или 0xFF.

// Реже используются двоичные и восьмеричные числа:

console.log( )
console.log(0b11111111, '- 0b11111111') // => 255, двоичная система счисления

console.log( )
console.log(0o377, '- 0o377') // => 255, восьмеричная система счисления

// 0b11111111 - из двоичной системы исчисления.

// 0b - указывает на то, что это двоичная система счисления.
// 11111111 - указывает на кодировку/код числа.

// 0o377 - из восьмеричной системы исчисления.

// 0o - указывает на то, что это восьмеричная система счисления.
// 377 - указывает на кодировку/код числа.

// Метод toString(base)

// Метод num.toString(base) возвращает строковое представление числа в той
// или иной системе счисления (base).
// base может принимать значения от 2 до 36 (да-да, это всё системы счисления).

let num = 255
console.log( )
console.log(num.toString(16), "- код числа \'255\' в шест. системе счисления") // => "ff"
console.log( )
console.log(num.toString(8), "- код числа \'255\' в восьмеричной системе счисления") // => "377"
console.log( )
console.log(num.toString(2), "- код числа \'255\' в двоичной. системе счисления") // => "11111111"

// Округление чисел

// Отлично, с вариантами записи чисел разобрались.
// Теперь посмотрим, что можно с ними делать! (на такие операторы, как умножение,
// деление, сложение, взятие остатка от деления и т.д смотреть не будем, ибо
// дурак поймет что с ними надо делать и как надо использовать.)

// В JS встроен объект Math, который содержит несколько функций для работы с числами:

// Math.floor - округляет число в меньшую сторону

let numOne = Math.floor(5.8), numTwo = Math.floor(2.2), numThree = Math.floor(-2.2)

console.log( )
console.log(numOne) // => 5
console.log( )
console.log(numTwo) // => 2
console.log( )
console.log(numThree) // => -3

// Math.ceil - округление в большую сторону

numOne = Math.ceil(5.8), numTwo = Math.ceil(2.2), numThree = Math.ceil(-2.2)

console.log( )
console.log(numOne) // => 6
console.log( )
console.log(numTwo) // => 3
console.log( )
console.log(numThree) // => -2

// Math.round - округление до ближайшего целого

numOne = Math.round(5.8), numTwo = Math.round(2.2), numThree = Math.round(-2.2)

console.log( )
console.log(numOne) // => 6
console.log( )
console.log(numTwo) // => 6
console.log( )
console.log(numThree) // => 2

// И всё бы ничего, но Math.round округляет до целого числа.
// Например, число 5.845 (5 целых 845 тысячных) округлит до 6.
// Это ладно, но как получить 5.8 или 5.85?

// Одним из вариантов будет способ умножения и деления.
// Мы умножаем нужное число на 10 (в случае если дробная часть нужна как десятая),
// или умножаем на 100 (если дробная часть нужна как сотая).
// Далее, делим полученное число на 10 или 100 (в зависимости от того, на сколько умножили).
// Пример:

numOne = Math.round(5.845 * 10) / 10 // => 58.45 => 58 => 5.8
// Умножаем 5.845 на 10 = 58.45; Округляем 58.45 до целого числа с Math.Round = 58; Делим 58 на 10 = 5.8
console.log( )
console.log(numOne)

numTwo = Math.round(5.845 * 100) / 100 // => 584.5 => 585 => 5.85
// Умножаем 5.845 на 100 = 584.5; Округляем 584.5 до целого числа с Math.round = 585; Делим 585 на 100 = 5.85
console.log( )
console.log(numTwo)

numThree = Math.round(5.8449 * 100) / 100 // => 584.49 => 584 => 5.84
// Умножаем 5.8449 на 100 = 584.49; Округляем 584.49 до целого числа с Math.round = 584; Делим 584 на 100 = 5.84 
console.log( )
console.log(numThree)

// Второй вариант.
// Метод toFixed(n) - округляет число до n знаков после запятой и возвращает
// строковое представление результата.

numOne = 5.845
console.log( )
console.log(numOne.toFixed(1)) // => '5.8'

// А теперь преобразуем всю эту кашу в число:

// Метод унарного оператора сложения -

console.log( )
console.log(+numOne.toFixed(1)) // => 5.8

// Специальная функция Number -

console.log( )
console.log(Number(numOne.toFixed(1))) // => 5.8

// Проблемы неточных вычислений

// И так, у нас есть число 1.0005, мы хотим округлить его до 1.01 при помощи умножения и деления -

numOne = Math.round(1.005 * 100) / 100

// Ожидаем на выходе 1.01 -

console.log( )
console.log(numOne) // => 1

// Но, нам вывелось 1! почему так?
// А об этом - позже)

// Вот ещё пример: у нас есть число 12.35, мы хотим округлить его до 12.4 при помощи toFixed() -

numTwo = 12.35

// Ожидаем на выходе 12.4

console.log( )
console.log(numTwo.toFixed(1)) // => 12.3

// Почему так? в первом примере вывелось 1, а во втором - 12.3 (а так логично, ибо
// после точки идёт 35, а не 45)!

// Понять, почему же так происходит, можно по такому примеру (или просто понять что это JS :-D):

let problem = 0.1 + 0.2 === 0.3 // => создали некое условие

// Ожидаем на выходе true -

console.log( )
console.log(problem) // => false

// Опять! но как же так? 0.1 + 0.2 = 0.3, это как 1 + 2 = 3!
// Но если мы возьмем, и пропишем в консоли вот такую запись, без условия ... -

console.log( )
console.log(0.1 + 0.2) // => 0.3000000....4

// ...выйдет какой-то кошмар!
// А почему так? - всё дело в неточных вычислениях в программировании (или это
// так только в JS, я так и не понял).

// Подробнее об этом тут - https://habr.com/ru/post/112953/
// А что до меня - я вообще ничего из этой статьи не понял, ни капли, ни одного слова :D

// Решение с помощью Number.EPSILON

// А сейчас пора бы задуматся над тем, как нам решить эту проблему!
// Посмотрим на пример:

let sourceNum = 1.005
let numFour = Math.round(sourceNum * 100) / 100

console.log( )
console.log(numFour) // => 1, ожидалось 1.01

// У нас есть исходное чсило - одна целая, ноль ноль пять тысячных.
// И мы пытаемся его округлить, умножить и поделить, но когда мы выводим
// результат в консоль - облом! вместо одной целой, 1.01 нам выдает 1!

// Сейчас мы разберемся, что там происходит.. под капотом!

console.log( )
console.log(sourceNum * 100) // => 100.49999999999999
console.log( )
console.log(Math.round(sourceNum * 100)) // => 100

// Вкратце - у нас есть число, 1.005.
// Мы должны его умножить, получить 100.5.
// Потом округлить, получить 101.
// А потом делить - получим 1.01.

// Но, при умножении мы получаем не совсем то, что мы хотим - какое-то кошмарное
// число получается!
// Потом округляем, получаем 100.
// А при делении числа на само себя - получается 1, и тут тоже самое!

// И как же нам решить эту проблему?

// Нам поможет Number.EPSILON!
// Намбр Эпсилон это оооочень маленькое число, равное ".01".
// Нам всего лишь надо взять и, собственно, добавить его к переменной.
// Добавляется он через оператор сложения - "+":

sourceNum = 1.005 + Number.EPSILON

// Теперь вызываем в консоль значение переменной!

numFour = Math.round(sourceNum * 100) / 100

console.log( )
console.log(numFour, "- всё работает!") // => 1.01

// А теперь посмотрим что же под капотом -

console.log( )
console.log(sourceNum * 100) // => 100.500000...1
console.log( )
console.log(Math.round(sourceNum * 100)) // => 101

// Надо только поделить, и получится 1.01:
// 101 / 100 = 1.01

// Вообще-то, есть функция которая решает эту проблему - но она очень большая и очень сложная.
// Найти её можно в документации (я не стал искать :-))

// P.S - на решение этой задачи своими мозгами, у меня ушло 30 минут.
// Без математики действительно трудно!

// Проверки: isFinite и isNaN

/*

PRE:

Вспомним, что в JS существуют специальные числовые значения, такие как:
Infinity - бесконечность,
и NaN - ошибка вычисления.
Эти значения так же являются типом данных number, но НЕ являются обычными числами!
для проверки таких значений существуют СПЕЦИАЛЬНЫЕ функции.

*/

// Проверка isNaN'ом

// Представим, что у нас есть такое выражение: «25 + "Привет!"»
// Мы попытаемся преобразовать его в числовое значение:

console.log( )
console.log(Number(25 + "Привет!")) // => NaN

// Но, как мы видим, выводится NaN (not a number - не число).
// И то правда - число складывать со строкой?.. м-да.
// Но как же нам определить, вернет ли это выражение NaN?

// Существует проверка "isNaN()" (..это NaN?), которая помогает нам определить,
// выдаст ли выражение NaN или нет.
// Оно способно выдавать только 2 значения - true и false.

// Проверим на деле:

console.log( )
console.log(Number(25 + "Привет!")) // => NaN

// Нам выдало NaN, так как НЕЛЬЗЯ складывать строку с числом, это НЕ ЧИСЛО.
// Теперь проверим это же выражение через isNaN:

console.log( )
console.log(isNaN(25 + "Привет!")) // => true

// Вполне ожидаемо.

// isNaN естественно проверил бы выражение на выдачу нам NaN, но так как числа
// никак не могут складываться - он выдал нам true, это выражение в любом случае
// бы выдало нам NaN, так как (повторюсь) число со строкой складывать нельзя.

// Но всё же, зачем нам нужен этот isNaN?
// Мы же можем проверить через if, зачем нам isNaN?
// Всё дело в том, что NaN никогда не равен самому себе... -

if (25 + "Привет!" !== NaN) {
    console.log( )
    console.log("Э, я не NaN!")
}

// => "Э, я не NaN!"

// Или

console.log( )
console.log(NaN === NaN) // => false

// ... потому, что NaN - уникальное значение. Оно никогда и ни при каких
// обстоятельствах не может быть равно чему либо, даже себе.

// Поэтому то нам и нужен этот "isNaN", чтобы проверять выражения на наличие
// этого спец. значения, NaN.

// Проверка isFinite

/*

Преобразует аргумент в число и возвращает true, если оно
является обычным числом.

Если же аргумент строка - то оно преобразуется в число, а
это NaN (не число), значит проверка вернет нам false.
Но если это число представленное в виде строки, то будет true,
ибо "строковое" число превратится в обычное, а это true.
А вот если аргумент infinity, то это так же false.

*/

console.log( )
console.log(isFinite("25")) // => "25" => 25 => true
console.log( )
console.log(isFinite("Привет!")) // => "Привет!" => NaN (попытка превратить str в num) => false
console.log( )
console.log(10/ 0) // => 10/ 0 => Infinity => false

// parseInt и parseFloat

/*

Как мы уже знаем, преобразовать строку в число можно с помощью
унарного оператора сложения, либо с помощью специальной функции Number.

P.S - преобразовать строку в число можно только при условии,
что в строке находится число представленное в текстовом, строковом виде.
Т.е - преобразовать можно такие числа:

Было: "25"
Стало: 25

Было: "146"
Стало: 146

А если это уже "натуральная" (как я такие строки называю) строка, то будет NaN:

Было: "Семечки"
Стало: NaN (not a number, не число)

Было: "Пулеметчик гангстер"
Стало: NaN

*/

let valueOne = +"150" // => "150" => 150

console.log( )
console.log(valueOne) // => 150
console.log( )
console.log(typeof valueOne) // => "number"

/*

Но, программисты очень часто сталкиваются со значениями у которых
есть единица измерения (мне тоже скоро придется, походу..), например:

*/

let valueTwo = +"150px" // => "150px" => NaN (попытка преобразовать строку в число)

console.log( )
console.log(valueTwo) // => NaN
console.log( )
console.log(typeof valueTwo) // => "number"

// И что делать? (ждать чего-то :-D)

// Для решения таких проблем существуют (Супермен и Супергёрл) parseInt и parseFloat.

/*

Для получения чисел из такой строки существуют parseInt и parseFloat.
Если в процессе чтения возникает ошибка (NaN), они возвращают полученное
ДО ошибки число.

Функция parseInt возвращает целое число, если нам было передано
число с плавающей точкой.
А функция parseFloat возвращает число с плавающей точкой (т.е,
возвращает число "как есть"):

*/

valueOne = parseInt("150.58px")

console.log( )
console.log(valueOne) // => 150 (вернул просто целое число, .58 отбросил)
console.log( )
console.log(typeof valueOne) // => "number"

valueTwo = parseFloat("150.58px")

console.log( )
console.log(valueTwo) // => 150.58 (вернул число с плав. точкой, "сохранил" .58)
console.log( )
console.log(typeof valueTwo) // => "number"

// И как не странно - тип данных number.
// Но почему так? - всё дело в том, что parseInt/Float() возвращают ЧИСЛО
// до того, как в процессе чтения кода возникла ошибка.

// Итог:
// Если в процессе чтения кода возникает ошибка, то parseInt и parseFloat
// возвращают получившееся число до возникновения ошибки.

// Но, стоит отметить, что если первым символом будет буква, а не число (т.е
// сразу будет ошибка) то нам выдаст NaN:

let valueThree = parseFloat('a150.58px')

console.log( )
console.log(valueThree) // => NaN, т.к никакого числа из этой строки достать мы не можем
console.log( )
console.log(typeof valueThree) // => "number" (почему так - я не знаю :-D)

// Дополнительный аргумент

/*

У функции parseInt есть дополнительный параметр.
Он определяет систему счисления, таким образом parseInt может
также читать строки с шестнадцатеричными числами, двоичными
числами и так далее. -

*/

console.log( )
console.log(parseInt('0xff'), 16) // => 255
console.log( )
console.log(parseInt('ff'), 16) // => 255

// В первом выражении "0x" можно пропустить, т.к после "ff" мы пишем "16",
// и функция понимает что нужное число из шестнадцатеричной системы счисления.

// Другие возможности

// Уже знакомый нам объект Math, содержит различные математические
// функции и константы.
// Вот некоторые из них:

// Math.random()
// => Возвращает псевдослучайно случайное число в диапазоне
// от 0 (включительно) до 1 (не включая 1)

console.log( )
console.log(Math.random()) // => ?
console.log( )
console.log(Math.random()) // => ?
console.log( )
console.log(Math.random()) // => ?

// P.S - поставил знаки вопроса потому, что числа абсолютно рандомные
// и угадать что нам будет возвращено - невозможно.

// Math.max
// => Возвращает наибольшее число из переданных аргументов.
// => Аргументов может быть сколь угодно.

console.log( )
console.log(Math.max(5, 4, 89, 145, -2, 7)) // => 145
console.log( )
console.log(Math.max(0.1, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 50, 600, 7000)) // => 7000

// Math.min
// => Возвращает наименьшее число из переданных аргументов.
// => Аргументов может быть сколь угодно.

console.log( )
console.log(Math.min(5, 4, 89, 145, -2, 7)) // => -7
console.log( )
console.log(Math.min(0.1, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 50, 600, 7000)) // => 0.1

// Math.abs
// => Возвращает абсолютное значение (модуль) числа.

num = -58

console.log( )
console.log(Math.abs(num)) // => 58 

// Math.pow
// => Возвращает число n, возведенное в степень power.

// P.S - Простыми словами, она берет первый аргумент (число), и возводит
// его в степень второго переданного аргумента (тоже числа).
// Т.е, если мы передадим 2 аргумента - 5 и 8, то она возведет 5 в 8-ую степень.

console.log( )
console.log(Math.pow(5, 8)) // => 390625

// Конечно, можно было использовать оператор ** (возведения в степень)
// а не придумывать функцию для этого.. но да ладно.

// Домашка!!!

// 1) Изучить теорию
// 2) Решить задачи:

/*

Задача №1 (получить верное значение округления)

let num = Math.round(1.005 * 100) / 100
console.log(num) => выводит 1, что не верно.

Решение:

let sourceNum = 1.005 + Number.EPSILON
let num = Math.round(sourceNum * 100) / 100
console.log(num)

Задача №2 (получить число 135.58 из строки)

let value = "135.58px"
console.log(value) // => NaN

Решение:

let value = "135.58px"
console.log(parseFloat(value)) // => 135.58

Задача №3 (построить верное условное ветвление)

let value = 58 + "Фрилансер"
if (написать тут ответ) {
    console.log("Результат выражения NaN")
}

Решение:

let value = 58 + "Фрилансер"
if (value !== NaN) {
    console.log("Результат выражения NaN")
}

(а задача то, с подвохом!))

Задача №4 (найти макс. число из - 10, 58, 39, -150, 0)

Решение:

console.log(Math.max(10, 58, 39, -150, 0)) => 58

Решение наоборот:

let numbers = "10, 58, 39, -150, 0"
let num = numbers[12] + numbers[13] + numbers[14] + numbers[15]
num = Math.abs(num)

console.log(Math.max(10, 58, 39, num, 0))

Задача №5 (округлить число 58.858 до числа 58)

console.log(Math.floor(58.858))

(задача на самом деле и не была сложной, что-ж..)

*/

// Строки

// Запись строк: кавычки

// Строку можно создать с помощью одинарных, двойных либо обратных кавычек.

let someStringOne = 'Привет! Я строка!' // => Одинарные
let someStringTwo = "Привет! Я строка!" // => Двойные
let someStringThree = `Привет! Я строка!` // => Обратные

console.log( )
console.log(someStringOne)
console.log( )
console.log(someStringTwo)
console.log( )
console.log(someStringThree)

/*

Одинарные и двойные кавычки работают, по сути, одинаково,
а если использовать обратные кавычки, то в такую строку мы сможем вставлять
произвольные выражения, обернув их в ${...}:

*/

let textHi = "Привет!"
let textAll = `${textHi} Я строка!`

console.log( )
console.log(textAll) // => "Привет! Я строка!"

function someSum(a, b) {
    return a + b
}

console.log( )
console.log(`Сумма: ${someSum(4, 7)}`) // => Сумма: 11

// Многострочная запись

// С помощью обратных кавычек мы можем делать многострочные записи,
// чего бы мы не смогли сделать с одинарными/двойными:

let text = `Привет!
Вы на канале
Ученик по жизни!
`

console.log( )
console.log(text)

// "Всё что в кавычках - строка!", или строка - строкой.

let someString = "158"
let someNum2 = 158

console.log( )
console.log(someString)
console.log( )
console.log(typeof someString) // => "string"

console.log( )
console.log(someNum2)
console.log( )
console.log(typeof someNum2) // => "number"

// Если сложить строку с числом - они "соединятся" (именно соединятся,
// сложение не произойдет):

console.log( )
console.log(someString + someNum) // => "158158"

// Спецсимволы

/*

Внутри строк можно использовать ряд спецсимволов.
Все спецсимволы наичнаются с обратного слэша,
\ - так называемого «символа экранирования».

Вот несколько из спецсмиволов:

*/

// Перевод строки - \n

// Мы уже знаем, что можно сделать многострочную запись через обратные кавычки.

let textOne = `Привет!
Вы на канале
Ученик по жизни!
`

console.log( )
console.log(textOne) // =>

/*

Привет!
Вы на канале
Ученик по жизни!

*/

// Но что если нам нужны именно одинарные, ну или может двойные? как тогда быть?
// Нам в этом случае поможет спецсимвол "переноса строк" -

let textTwo = "Привет!\nВы на канале\nУченик по жизни!"

console.log( )
console.log(textTwo) // =>

/*

Привет!
Вы на канале
Ученик по жизни!

*/

// Табуляция, отступ - \t

// Разукрасим нашу надпись - добавим отступов, чтобы текст не "липнул" -

text = "Привет!\n\tВы на канале\n\t\tУченик по жизни!"

console.log( )
console.log(text) // =>

/*

Привет!
    Вы на канале
        Ученик по жизни!

*/

// Обратный слэш - \\

// У нас в тексте появилось немного больше текста:
// "Привет! Вы на канале Ученик по жизни IT и фриланс"

// Всё бы ничего, но между словами "...жизни" и "IT" должен
// стоять хотя-бы СЛЭШ, но как его туда добавить?
// Если мы напишем так:

text = "Привет! Вы на канале Ученик по жизни \ IT и фриланс"

console.log( )
console.log(text)

// ...никакого слэша мы не увидим.
// Всё потому, что JS увидев знак "обратный слэш" - ожидал спецсимвол, но так как
// мы никакой спецсимвол не прописали - ничего не вывело.
// А как быть?
// Существует спецсимвол обратного слэша - пишется он как два обратных слэша -

text = "Привет! Вы на канале Ученик по жизни \\ IT и фриланс"

console.log( )
console.log(text) // => "Привет! Вы на канале Ученик по жизни \\ IT и фриланс"

// Вуаля, все готово.

// Кавычки - \' & \"

// Часто бывает так, что внутри строки должна быть кавычка -

text = "Привет! Вы на канале 'Ученик по жизни!'"

console.log( )
console.log(text) // => "Привет! Вы на канале 'Ученик по жизни!'"

// А что если нам нужна именно ДВОЙНАЯ кавычка?
// Тогда мы можем строку обернуть в одинарные кавычки, а нужный отрывок текста -
// в двойные кавычки.
// А что если у нас в тексте должно быть мнооого кавычек?
// Так же и поступим!

// text = 'Привет! Вы на канале "Ученик по жизни!", на этом канале вы сможете обучиться "HTML & CSS" и научиться верстать сайты!'

// console.log( )
// console.log(text)

// ..но нет. Будет ошибка - "SyntaxError: unexpected identifier"

// В таком случае, нам поможет спецсимвол кавычек.
// На самом деле таких спецсимволов два:
// Для одинарных - \'
// Для двойных - \"

// Используем:


text = 'Привет! Вы на канале \"Ученик по жизни!\", на этом канале вы сможете обучиться \"HTML & CSS\" и научиться верстать сайты!'

console.log( )
console.log(text)

// Иконки и символы

// Мало кто знает, но в JS можно использовать СИМВОЛЫ и даже СМАЙЛИКИ.
// Для этого пригодятся utf-16 и utf-32.
// Для написания символов\смайлкиов нужно знать их код, и знать команду '\u'.
// После \u пишется код смайлика\символа в таблице, вот так:

// console.log("всякая ерунда... \uКОД")
// Или
// console.log("всякая ерунда... \u{КОД}")

// Используем:

text = "Живи, а работай в свободное время! \u00A9 \u{1F60D}"

console.log( )
console.log(text)

// Со спецсимволами разобрались, на этом всё.

// Длина строки. Свойство length.

// Часто бывает так, что нам нужно узнать длину нашей строки.
// Мы же не будем сидеть и считать все символы по одному, это займет
// кучу времени!.. но а что делать? как быть?
// Для этого существует свойство length.
// Оно считает ВСЕ символы от начала до конца строки и выводит их количество
// в консоль. Т.е, если символов 7 - выведет число 7 в консоль.

textOne = "Привет!" // => Символов: 7

console.log( )
console.log(textOne.length) // => 7

// Или

textTwo = "жвачкаконфетысериалсырводамногоэтажкачеловекноскартошкасмехбукваалфавитбукваы" // => Символов: ..?

console.log( )
console.log(textTwo.length) // => 77

// Получаем символы из строки

// Ну вот, мы молодцы, научились получать длину строки.
// Ну а что если нам надо получить один определенный символ из строки?
// Для этого тоже существует специальная команда (а точнее символ) - [].
// Внутри скобок вставляется ИНДЕКС символа (место, где стоит символ) в строке.
// Например, нам из строки "Привет!" надо получить букву П, а индекс буквы П равен
// нулю (в JS индексы символов в строке начинаются с нуля), поэтому внутри квад.
// скобок пишем цифру 0 -

text = "Привет!"
let firstSymbol = text[0] // => "П"

console.log( )
console.log(firstSymbol) // => "П"

// А для получения последнего символа, можно взять и использовать свойство length,
// затем у полученного числа отнять единицу (пушто индексы начинаются с нуля, а
// не с единицы) и полученное число записать в квад. скобки:

let lastSymbol = text[text.length - 1]

console.log( )
console.log(lastSymbol) // => !

// Еще можно "пройтись" по строке при помощи for..of, т.е, "перебрать" все символы из строки
// и вызвать их в консоль:

console.log( )
for (const char of text) {
    console.log(char)
}

// => "П" (разрыв) "Р" (разрыв) "И" (разрыв) "В" (разрыв) "Е" (разрыв) "Т" (разрыв) "!"

// Изменение строки

// В JS  невозможно изменить строку при помощи квад. скобок:

text = "Привет!"
text[6] = "." // => Вместо ! по идее должно быть .

console.log( )
console.log(text) // => "Привет!"

// Изменение регистра

// В JS можно с легкостью менять регистр строки.
// Для этого существуют методы toUpperCase() для увеличения регистра и toLowerCase()
// для уменьшения регистра соответственно.

text = "ПрИвЕт!"

console.log( ) // => "ПрИвЕт"
console.log(text)
console.log( )
console.log(text.toUpperCase()) // => "ПРИВЕТ!"
console.log( )
console.log(text.toLowerCase()) // => "привет!"

// Поиск подстроки

// А что если нам нужно в строке что нибудь найти?
// Для этого существуют несколько методов.
// Первый: .indexOf().

/*

Метод indexOf() ищет подстроку (substr) в строке (str), начиная с позиции (pos),
и возвращает позицию, на которой располагается совпадение, либо -1 при отсутствии совпадений. 

*/

// Допустим нам из строки "Привет!" надо взять подстроку "рив".
// Для этого мы используем метод indexOf - он принимает 2 аргумента - саму
// подстроку и позицию, где она лежит (причем последний аргумент необязателен)

text = "Привет!"

console.log( )
console.log(text.indexOf("рив"))
// => 1 (Буква "П" - нулевой индекс, буква "р" - первый индекс - его то нам и выводит, ибо "рив" начинается с "р")

// В случае, если мы указали позицию, но на ней нет данной подстроки - выдаст -1.

console.log( )
console.log(text.indexOf("рив", 3))
// => -1 (Буква "П" - 0-ой индекс, буква "р" - 1-ый, буква "и" - 2-ой, буква "в" - 3-ий.) 

// Т.е, если совпадение в слове найдено - метод берет ту подстроку, которую мы искали,
// и "вытаскивает" оттуда первый символ (у "рив" первый символ это "р"), и ищет этот
// символ по индеку в строке - "р" тут с индексом "1".
// Или вкратце - то число, которое нам будет выводить - индекс первого символа
// нашей подстроки.

text = "Теврип!"

console.log( )
console.log(text.indexOf("рип")) // => 3
console.log( )
console.log(text.indexOf("рип", 4)) // => -1

// Методы includes, startsWith, endsWith

/*

Существует более современный метод - str.includer(substr, pos) (последний аргумент
необязателен и его можно пропустить).
Возвращает true, если в строке есть искомая подстрока, либо false, если нет.

*/

text = "Привет!"

console.log( )
console.log(text.includes("рив")) // => true
console.log( )
console.log(text.includes("рив", 3)) // => false

// Так же есть метод str.startsWith(substr), который определяет, начинается ли
// строка с определенной подстроки.
// Т.е, он может определить - начинается ли "Привет!" с подстроки "рив", и выдаст true
// если да и выдаст false, если нет.

console.log( )
console.log(text.startsWith("рив")) // => false

// И есть еще один метод, endsWith - он работает точно так же как и startsWith, но
// он не ищет подстроку в самом начале строки - а в её конце, и определяет - кончается
// ли строка с ней или нет.
// Т.е, он может определить - кончается ли "Привет!" с подстроки "!", и выдаст true
// если да и выдаст false, если нет.

console.log( )
console.log(text.endsWith("!")) // => true

// Регистр имеет значение!

// Представим, что у нас есть две переменные - строка и искомая подстрока.
// Но они у нас разных регистров:

text = "Привет!"
let searchText = "пР"

// И что делаеть? ни text.includes(searchText), ни text.indexOf(searchText), ни
// text.startsWith(searchText) не помогут.
// Зато тут поможет цепочка из toLowerCase() и includes -

console.log( )
console.log(text.toLowerCase().includes(searchText.toLowerCase())) // => true

// Итоги: что и когда использовать?

/*

В итоге indexOf стоит использовать тогда когда нам нужна позиция найденой подстроки.
В остальных случаях удобнее использовать includes

*/

// Полученне части строки (подстроки)

/*

В JS существует ряд методов получения подстроки.
Но достаточно пользоваться одним.

*/

/*

Метод str.slice(start [, end]) - возвращает часть строки от start до end (при этом не включая end)

*/

text = "Привет!"

console.log( )
console.log(text.slice(1,2)) // => "р" (от 1 - "р", до 2 - "и" (буквы нету в составе подстроки, именно ДО а не включая)

// В случае если в качествве аргументов переданы отрицательные числа, то отсчет
// идет с самого конца строки (наоборот).

console.log( )
console.log(text.slice(-2, -1)) // => "т" (-2 - "т", -1 - "!" (символа нету в составе подстроки)

// Если был передан лишь 1 аргумент (одно число) вырезается вся строка начиная
// с этого числа (например, если было передано число 4 - будет вырезана подстрока
// начиная с символа с 4-ым индексом)

console.log( )
console.log(text.slice(1)) // => "ривет!"  (1 - "р", и далее)

// Заметка: лично я никогда не пользуюсь slice, я с ним постоянно путаюсь...
// Особенно с отрицательными числами. Посчитать что-где находится - невозможно (или
// очень сложно, по крайней мере для меня).
// Если мне нужно вырезать подстроку:
// 1) str[i]
// 2) `${}`
// 3) str[i] + `${}`
// 4) Profit!

// Сравнение строк

/*

Алгоритм сравнения двух строк довольно прост:

1) Сначала сравниваются первые символы строк.

2) Если символ первой строки больше(меньше), чем первый символ второй, то первая строка
больше(меньше) второй. Сравнение завершено.

3) Если первые символы равны, то таким же образом сравниваются уже вторые символы строк.

4) Сравнение продолжается, пока не кончится одна из строк.

5) Если обе строки заканчиваются одновременно, то они равны. Иначе, большей считается
более длинная строка.

*/

// Алфавитный порядок:

console.log( )
console.log("А" > "Б") // => false (Б в алфавите идет второй, она больше)

console.log( )
console.log("а" > "Б") // => true (а меньше Б, она больше (как бы странно это не звучало)

console.log( )
console.log("Скрипт" > "Скрипка") // => true (буква "т" в слове "Скрипт" идет дальше чем
// буква "к" в слове "Скрипка", поэтому эта строка больше чем слово "Скрипка", хоть последнее
// большее по кол-ву символов.)

// Кол-во символов

console.log( )
console.log("Слайдер" > "Слайд") //  => true ("Слайдер" больше чем "Слайд" по кол-ву символов)
// P.S - и по алф. порядку тоже, ибо после "д" идет "е", а после "е", идет "р".

// Регистр

console.log( )
console.log("Ученик" > "ученик") // => false ("Ученик" написано с большой буквы,
// следовательно, "ученик" больше)

// Домашка!!!

// 1) Изучить теорию
// 2) Решить задачи:

/*

Задача №1 (верна ли запись?)

let fls = "Фрилансер"
let text = "Привет! Я ${fls}"

=> Ожидаем получить "Привет! Я фрилансер"
console.log(text)

Ответ: F, получится "Привет! Я ${fls}"

Задача №2 (получить символ н из строки)

let text = "фрилансер"

Ответ: console.log(text[5])

Задача №3 (верно?)

let text = 123 + "456"

=> Ожидаем 579
console.log(text)

Ответ: F, неверно, получится "123456"

Задача №4 (получить строку в верхнем регистре)

let text = "фрилансер"

Ответ: console.log(text.toUpperCase())

Задача №5 (получить подстроку "лан")

let text = "фрилансер"

Ответ: console.log(text.slice(3, 6))

Задача №6 (true или false?)

let text = "фрилансер"
console.log(text.includes('лан', 4))

Ответ: F, подстрока "лан" начинается с 3 индекса, а не с 4.

*/

// Массивы

// Массивы - это отдельный подвид объектов, он позволяет нам хранить данные.
// Но в отличии от объектов, управлять этими данными мы можем гораздо гибче!

// Создание массива

let arr = new Array(); // Так создают массив редко и используются он тоже редко
arr = [];

// Значения массива

// Массивы заполняются также как и объекты, и отделять один элемент массива
// от другого надо через запятую.
// Лучше всего, если у последнего элемента массива тоже будет запятая, "висячая".
// Благодаря ней мы сможем с легкостью последний элемент сдвинуть
// в начало или в середину, и наоборот.
// Заполним наш первый массив -

let arrOne = [
    "Ваня",
    "Иштван",
    "Оля", // Висячая запятая
];

// Можно еще сократить нашу запись:

arrOne = ["Ваня", "Иштван", "Оля", /* Висячая запятая */ ];

// Различные типы значений

// В массивах может храниться саааамая разная информация.
// Простая строка, объект, булевое значение, и даже функция!

let arrTwo = [
    "Коля",
    {
        type: "JS",
        age: 36,
    },
    true,
    function () {
        console.log( );
        console.log("Привет, я Коля");
    }
];

// Многомерные массивы

// Многомерный массив - массив, где у него в роли элемента выступает
// другой массив, но уже со своими собственныи значениями.
// Причем таких "дочерних" массивов может быть сколь угодно, хоть 10.

let matrix = [
    [1, 2, 3],
    [4, 5 ,6],
    [7, 8, 9]
]

// Получение значений

// Получать значения из массива очень просто, также просто как и создать его.
// Для этого мы используем квадратные скобки и индексацию элементов (первый
// элемент массива = нулевой, второй = первый, и т.д)

arrOne = [
    "Ваня", // 0-я позциия
    "Иштван", // 1-я позиция
    "Оля", // 2-я позиция
];

console.log( );
console.log(arrOne[1]); // => "Иштван"

// Если мы будем вызывать несуществующий элемент массива, нам конечно же
// выдаст undefined.

console.log( )
console.log(arrOne[5]); // => undefined

// Кошмарный ко.. кхм, получение значений из огромных массивов

// Рассмотрим еще ряд примеров, но уже с более сложными массивами.

// Допустим, у нас есть массив со строкой, объектом, бул. значением, функцией:

arrTwo = [
    "Коля",
    {
        type: "JS",
        age: 36,
    },
    true,
    function () {
        console.log( );
        console.log("Привет, я Коля");
    }
];

// Мы хотим вызвать ВСЕ его значения одним лишь разом.
// Что делать? надо в console.log() просто записать "arrTwo":

console.log( );
console.log(arrTwo);
// => [ "Коля", {type : 'JS', age: 36}, true, [Function (anonymous)] ] (node)
// => (4) ["Коля", {...}, true, f] (chrome)

// А если мы хотим вывести определенный элемент в консоль?
// Скажем, строку?
// Тогда всё как обычно - название массива, квадратные скобки, индекс :)

console.log( );
console.log(arrTwo[0]); // => "Коля"

// Теперь выведем значение ключа type, в объекте внутри массива.
// для этого мы должны прописать название массива:
// arrTwo
// Индекс элемента-объекта:
// arrTwo[1]
// Точку и ключ "type":
// arrTwo[1].type
// Вот и всё.

console.log( );
console.log(arrTwo[1].type); // => "JS"

// Теперь выведем бул. значение, true.
// Для этого опять берем индекс:
// "Коля" - 0
// Объект {} - 1
// бул. значение: true - 2

console.log( );
console.log(arrTwo[2]); // => true

// А для вызова функции лежащей внутри массива не нужен console.log().
// Вместо этого, просто пишем назв. массива, квад. скобки, индекс и круглые скобки -

arrTwo[3](); // => "Привет, я Коля"

// А теперь возьмем многомерный массив.
// Напоминаю, что мм. массив - массив, у которого в качестве элементов другие массивы.
// Таких массивов может быть много, очень много - хоть 100.

// Для возврата элемента из мм. массива нужно два индекса (первый - найдет первый
// элемент внутри род. массива, а второй - элемент, лежащий внутри дочернего массива)
// и две квадратные скобки.

// Но для начала - нужен сам массив.
// У нас такой уже есть, называется он matrix - его значения можно подсмотреть сверху.
// Ну а я просто тут сделаю таблицу:

/*

matrix (parent) =>
1element (daughter (or son) = 123,
2element (daughter (or son) = 456,
3element (daughter (or son) = 789

*/

// Напишем в консоль все элементы нашего массива -

console.log( );
console.log(matrix);

// => [ [1, 2 ,3], [4, 5, 6], [7, 8 ,9] ] (node)
// => (3) [Array(3), Array(3), Array(3)] (chrome)

// А теперь вызовем каждый его элемент по отдельности -

console.log( );
console.log(matrix[0]); // [ 1, 2 ,3 ]

console.log( );
console.log(matrix[1]); // [ 4, 5, 6 ]

console.log( )
console.log(matrix[2]); // [ 7, 8, 9 ]

// Ну и на последок вызовем цифру 2 из первого дочернего массива -

console.log( );
console.log(matrix[0][1]); // 2

// P.S:
// [0] - первый дочерний массив у matrix, в нем лежат цифры 1 2 3
// [1] - индекс цифры 2 в первом дочернем массиве у matrix (1 = 0, 2 = 1)

// Длина массива. Свойство length.

// У массивов всё же есть кое какие отличия от объектов.
// К примеру - метод length (мы его уже знаем из урока про строки), который
// может показать нам длину массива (и даже не в индексах, что круто)

arrOne = ["Ваня", "Иштван", "Оля",];

console.log( );
console.log(arrOne);
// => [ "Ваня", "Иштван", "Оля" ] (node)

console.log( );
console.log(arrOne.length); // => 3

// Доступ к массиву

// Напоминалка:

// Массив - объект, следовательно, ведет себя как объект.
// Например - копируется по ссылке:

arr = ["Ваня", "Иштван", "Оля",];
console.log( );
console.log(arr, "- массив до изменения ссылкой");
// => [ "Ваня", "Иштван", "Оля" ] (node)

let arrNew = arr;

arrNew.length = 2;

console.log( );
console.log(arr, "- массив после изменения ссылкой");
// => [ "Ваня", "Иштван" ] (node)

// Как мы видим изменился первый массив, потому что arrNew - его "зеркало", ссылка.
// Что весьма интересно - удалился элемент массива "Оля", хотя мы просто изменили его длину..
// хотя - что делать, если от нас просят изменить длину массива? укоротить!

// Изменение значений

// Меняются значения в массиве почти также как и у объекта - нужны кв. скобки и индекс.

arr = ["Ваня", "Иштван", "Оля",];
console.log( );
console.log(arr, "- массив до изменения первого элемента");
// => [ "Ваня", "Иштван", "Оля" ]

// Меняем существующее:

arr[0] = "Коля";
console.log( );
console.log(arr, "- массив после изменения первого элемента");
// => [ "Коля", "Иштван", "Оля" ]

// Ну вот, значение поменяли. А как же добавить новое?
// У нас по индексам только "0", "1", "2" (0 - Коля, 1 - Иштван, 2 - Оля),
// следовательно - следующий элемент массива будет третим по индексам!
// Так вот - для этого надо сделать то же самое, что и при изменении строки, но вместо
// индекса уже существуюшего значения поставить несуществующее:

arr[3] = "Ваня";
console.log( );
console.log(arr, "- массив после добавления нового элемента");
// => [ "Коля", "Иштван", "Оля", "Ваня" ]

// Методы массивов

/*

С простеньким разобрались, теперь перейдем к методам массивов.
Но, перед этим стоит поговорить о вариантах применения для массивов.

Первый из них это очередь или упорядоченная коллекция элементов.
Очередь поддерживает два вида операций:

1) - Добавление элемента в конец очереди
2) - Удаление элемента в начале, сдвигая очередь, так что второй элемент становится первым.

Другой вариант применения массивов - структура данных, называемая стек.
Стек поддерживает два вида операций:

1) - Добавление элемента в конец
2) - Удаление последнего элемента

Массивы в JS могут работать и как очередь, и как стек.
Мы можем и удалять, и добавлять элементы массива как в начало, так и в конец.
И в этом нам помогут следующие методы (ой что щас будет, ой-ой-ой..):

*/

// Метод push - добавляет элемент в конец массива.

arr = ["Ваня", "Иштван", "Оля",];
console.log( );
console.log(arr);
// => [ "Ваня", "Иштван", "Оля" ] (node)

arr.push("Вася");

console.log( );
console.log(arr, "- push");
// => [ "Ваня", "Иштван", "Оля", "Вася" ] (node)

// В конец массива мы можем добавлять сразу по два, а то и три элемента:

arr.push("Дима", "Катя");
console.log( );
console.log(arr, "- push");
// => [ "Ваня", "Иштван", "Оля", Вася, "Дима", "Катя" ] (node)

// Метод shift - удаляет элемент массива в начале (первый эелмент), так что второй
// элемент становится первым, третий - вторым, четвертый - третим и т.д.

arr = ["Ваня", "Иштван", "Оля",];

console.log( );
console.log(arr);
// => [ "Ваня", "Иштван", "Оля" ] (node)

arr.shift();

console.log( );
console.log(arr, "- shift");
// => [ "Иштван", "Оля" ] (node)

// Метод pop - удаляет последний элемент, но все элементы остаются на своих местах.
// Синтаксис тот же, что и в случае с shift().

arr = ["Ваня", "Иштван", "Оля",];

console.log( );
console.log(arr);
// => [ "Ваня", "Иштван", "Оля" ] (node)

arr.pop();

console.log( );
console.log(arr, "- pop");
// => [ "Ваня", "Иштван" ] (node)

// Метод unshift - добавляет элемент(ы) в начало массива, так что все элементы
// сдвигаются вперед.

arr = ["Ваня", "Иштван", "Оля",];

console.log( );
console.log(arr);
// => [ "Ваня", "Иштван", "Оля" ] (node)

arr.unshift("Вася");

console.log( );
console.log(arr, "- unshift");
// => [ "Вася", "Ваня", "Иштван", "Оля" ] (node)

arr.unshift("Дима", "Катя");

console.log( );
console.log(arr, "- unshift");
// => [ "Дима", "Катя", "Вася", "Ваня", "Иштван", "Оля" ] (node)

// ВажнОя информацЫя!

/*

Методы push/pop выполняются быстро, методы shift/unshift - медленно.
Рассотрим на примере добавления элемента в начало массива (unshift):

Просто взять и добавить элемент с номером 0 - недостаточно.
Нужно также заново пронумеровать остальные элементы.

Операция unshift должна выполнить 3 действия:

1) - Добавить элемент с индексом 0.
2) - Сдвинуть все элементы вправо, пронумеровать их, заменив 0 на 1, 1 на 2, 2 на 3 и т.д.
3) - Обновить свойство length.

Чем больше элементов содержит массив, тем больше времени потребуется для того, чтобы их
переместить, больше операций с памятью.

А вот чтобы добавить элемент в конец массива (метод push) не нужно ничего перемещать.
Также не нужно заново нумеровать элементы. Достаточно увеличить свойство length.

И правда - моя node консоль стала прогружаться медленно, и на то чтобы всё отобразить - ушло секунд 5-6.

*/

// Удаление/добавление/изменение конкретных элементов

// Теперь мы будем пробовать удалять, добавлять и изменять конкретные
// элементы массивов. До этого мы (а точнее я) практиковались на методах
// массивов, а теперь будем пробовать стандартными методами, удаляя элементы
// в середине. Методы (un)shift, pop, push - но они добавляют/удаляют
// элементы в начале или конце массива, но никак не в середине.

// Так как массивы - объекты, у них есть команда (или как это назвать) delete.
// delete'ом можно удалять элементы, при помощи индексов. Мы указываем имя массива,
// индекс через квад. скобки, и готово. Но, при использовании delete к массиву,
// элемент массива удаляется, но заменяется значением "empty" (chrome) или
// "1 empty item" (node), а если мы обратимся к этому элементу по ключу - нам выдаст undefined.
// При этом, длина массива не меняется! всё дело в том, что элемент удалился,
// но заменен другой надписью!

arr = ["Ваня", "Иштван", "Оля"];

// Удаляем элемент
delete arr[1];

// Проверяем массив
console.log( );
console.log(arr);
// => [ "Ваня", <1 empty item>, "Оля" ] (node)

// Обращаемся к элементу
console.log( );
console.log(arr[1]); // => undefined

// Смотрим на длину
console.log( );
console.log(arr.length); // => 3

// Делаем выводы:
// delete, в случае с массивами - бесполезен.

// Метод splice

// "Перестанем лохматить бабушку и перейдем к серьезным инструментам!" (C) - Жека
// Метод splice позволояет добавлять, удалять и заменять элементы.
// Синтаксис: arr.splice(index[, deleteCount, elem1, ... elemN])
// Ничего не понятно, но йа объясню. Мы в круглых скобках задаем первый индекс -
// это откуда начинать удалять, добавлять или заменять элемент. Второй индекс -
// сколько элементов необходимо удалить.
// Попробуем его использовать!

// Удаляем элемент

arOne = ["Ваня", "Иштван", "Оля"];
// Начиная с первой позиции (Иштван - 1), удаляем один элемент
arrOne.splice(1, 1);

console.log( );
console.log(arrOne);
// => [ "Ваня, Оля" ] (node)

// Удаляем элемент, возвращая его в переменную

arrTwo = ["Ваня", "Иштван", "Оля"];
// Теперь удалим элемент и запишем его в переменную
let removed = arrTwo.splice(1, 1);

console.log( )
console.log(removed)
// => [ "Иштван" ] (node)
//  P.S - элемент реально удалился, я проверил.

// Заменяем элементы

let arrThree = ["Ваня", "Иштван", "Оля"];
// Начиная с нулевой позиции (Ваня - 0), заменяем один элемент на элемент "Коля"
arrThree.splice(0, 1, "Коля");

console.log( );
console.log(arrThree);
// => [ "Коля", "Иштван", "Оля" ]

// Добавляем элементы

let arrFour = ["Ваня", "Иштван", "Оля"];
// Начиная с первой позиции (ПЕРЕД (а не после) "Иштван"), добавляем два элемента
arrFour.splice(1, 0, "Коля", "Маша");

console.log( );
console.log(arrFour);
// [ "Ваня", "Коля", "Маша", "Иштван", "Оля" ] (node)

// P.S - второй индекс ОБЯЗАТЕЛЬНО должен быть нулевым, при добавлении элементов.
// В противном случае - элемент с индексом n будет заменен.

// Удаляем элемент (последний)

let arrFive = ["Ваня", "Иштван", "Оля"];
// Начиная с последней позиции (Оля), удаляем один элемент
arrFive.splice(-1, 1);

console.log( );
console.log(arrFive);
// => [ "Ваня", "Иштван" ] (node)

// P.S - мы могли бы написать splice(2, 1), но таким образом Жека показал, что
// можно использовать и отрицательные значения.

// А я допишу всё послезавтра! Уроков мноооого, этот например идет аж 40 минут, а я только на 13!
// Т.е, столько всгео написал - а это лишь 13 минут.. што-ш, работы еще много.