// Метод join

// Метод join действует наоборот, он преобразовывает МАССИВ в строку, а не
// строку в массив, также с заданным разделителем.

let arr;
let arrTwo;
let obj;
let str;

arr = ["Ваня", "Иштван", "Оля",];
str = arr.join(",");

console.log( );
console.log(str);
// => "Ваня,Иштван,Оля"

// А теперь получим строку из массива:

arrTwo = ["Ваня", "Иштван", "Оля",];

console.log( );
console.log(String(arrTwo));
// => "Ваня,Иштван,Оля"

// Проверка массива: Array.isArray()

// -------------------------------------------------------

// Перед началом урока вспоминаем, что массивы - не образуют отдельный тип 
// данных, они основаны на другом типе данных. На объектах.

obj = {};
arr = [];

console.log( );
console.log(typeof obj);
// => object (как и ожидали, ничего удивительно)

console.log( );
console.log(typeof arr);
// => object (т.к массивы основываются на объектах)

// -------------------------------------------------------

// Часто бывает так, что у нас есть огромный код, а в нем куча разных объектв,
// строк, чисел и массивов. Это конечно хорошо, но как же нам узнать где массив
// а где нет? а вот для этого существует проверка Array.isArray(), которая
// нам как раз поможет. Синтаксис довольно прост: 

/*

Array.isArray(массив_на_проверку)

*/

// А теперь попрактикуемся!

if (Array.isArray(arr)) {
	console.log( );
	console.log("Это массив!");
} else {
	console.log( );
	console.log("Это не массив :(");
}

// => "Это массив!"

// Если зайти в консоль (любую, node или браузера) то мы увидим, что код отработал
// правильно, без ошибок.

// Перебор элементов

// С массивами можно сделать много чего, мы это уже поняли. Например, мы можем
// "перебрать" элементы какого нибудь массива.
// Для этого обычно используется цикл for:

arr = ["Ваня", "Иштван", "Оля"];

console.log( );
console.log(arr.length); // Узнаем длину массива
// => 3

for (let i = 0; i < arr.length; i++) {
	console.log( );
	console.log(arr[i], "- выведено при помощи простого цикла for"); // - выводим i элемент массива arr в консоль
}

// => {
/*
	"Ваня"

	"Иштван"

	"Оля"
*/
// }

// Ну вот, каждый элемент массива был выведен в консоль.
// Но мы еще можем использовать цикл FOR ... OF, он тут как раз подойдет:

for (let arrItem of arr) {
	console.log( );
	console.log(arrItem, "- а вот это выведено при помощи цикла for...of");
}

// Метод перебора forEach

// До этого мы перебирали массив при помощи циклов, но для перебора массива есть
// специальный метод - forEach.

// Он выполняет функцию для каждого элемента массива (также как и методы find
// findIndex и filter), а синтаксис у него точно такой же как и у find(Index) и
// filter'a (ну я ж говорил :D):

/*

arr.forEach(function (item, index, array) {
	// ... (делаем что-то крутое и интересное с массивом :>)
});

*/

// Попрактикуемся!

arr = ["Ваня", "Иштван", "Оля"];

arr.forEach(function(item, index, array) {
	console.log( );
	console.log(`Элемент "${item}" находится на ${index}-ой позиции в "${array}"`);
});

// => {
/*

	Элемент "Ваня" находится на 0-ой позиции в "Ваня,Иштван,Оля"

	Элемент "Иштван" находится на 1-ой позиции в "Ваня,Иштван,Оля"

	Элемент "Оля" находится на 2-ой позиции в "Ваня,Иштван,Оля"

*/
// }

// Код получился длинным, но оно того стоило - всё подробно описано, где и какой
// элемент лежит, + его позиция.
// Но мы можем написать то же самое, только при помощи стрелочных функций:

arr.forEach((item, index, array) => {
	console.log( );
	console.log(`Элемент "${item}" находится на ${index}-вой позиции в "${array}" - V2`);
});

// Также, при использовании метода forEach мы можем указывать имя некой ОТДЕЛЬНОЙ
// функции, да-да! т.е, мы создаем какую-то конкретную функцию и говорим forEach:
// "возьми и выполняй эту функцию!"

arr = ["Ваня", "Иштван", "Оля",];
arr.forEach(show);

function show(item) {
	console.log( );
	console.log(item);
};

// => "Ваня", "Иштван," "Оля" (каждый элемент на след. строке)

// Методы reduce/reduceRight

// Мы уже выяснили, что если нам нужно перебрать массив - мы можем использовать
// forEach, for или же for ... of.
// Если же нам нужно перебрать массив и вернуть данные для каждого элемента,
// то мы будем использовать map (он создает новый массив, подробнее в моем
// старом файле - script3.js).	

// Методы arr.reduce и arr.reduceRight похожи на эти методы, но они сложнее
// и используются для вычисления какого нибудь единого значения на основе
// всего массива.

// Синтаксис:

let value = arr.reduce(function(previousValue, item, index, array) {
	// ... (делаем что-то крутое, что-то такое что выходит за рамки реальности, ууу..)
}, ["initial"]);

/*

К привычным нам аргументам item, index и array добавляется previousValue:

previousValue - результат предыдущего вызова этой функции, равен initial при
первом вызове (если передан initial),
item - очередной элемент массива,
index - его индекс,
array - сам массив.

P.S: initial - начальное значение, судя по всему слово initial Жека взял СПЕЦИАЛЬНО,
поскольу initial значит "начальный, первоначальный". И да - Жека слово "initial"
не закрывал в кавычки, это я так сделал т.к выдает ошибку: "initial is not defined".

Функция применяется по очереди ко всем элементам массива и "переносит" свой результат
на следующий вызов.

Лично я - ничего не понял, но будет легче разобраться на примерах!

*/

// Создаем простейший массив чисел:

arrOne = [1, 2, 3, 4,];

// Объявляем новую переменную и присваиваем ей следующее:

// Обращаемся к массиву чисел (arrOne), ставим точку и пишем "reduce", открывая
// круглые скобки и указываем функцию, и в качестве начального значения previousValue
// указываем циферку ноль. Ну а в самом теле функции мы просто возвращаем сумму текущего
// значения массива с предыдущим, с previousValue.

let reduceValueOne = arrOne.reduce(function(previousValue, item, index, array) {
	return item + previousValue;
}, 0);

// А дальше мы выводим результат работы reduce:

console.log( );
console.log(reduceValueOne);
// => 10

// Отлично, получили 10! Но как оно так получилось, что нам вернуло 10? что же
// там внутри происходит? разберем все по-этапно:

/*

Шаг №1, этап первый:

previousValue = 0 (0 указано в функции, стоит на месте initial)
item = 1 (в массиве arrOne 1 первый элемент - логично!)
Их сумма = 1 (результат работы return item + previousValue)

Шаг №2, этап второй:

previousValue = 1 (previousValue равен 1, т.к previousValue - это результат работы пред. шага, а результатом был 1)
item = 2 (в массиве arrOne 2 второй элемент - тоже логично!)
Их сумма = 3 (результат работы return item + previousValue)

Шаг №3, этап третий:

previousValue = 3 (результат пред. шага равен трём, значит previousValue тоже равен трём!)
item = 3 (тут без объяснений, логичнее логичного :D)
Их сумма = 6 (и это тоже результат работы return item + previousValue)

Шаг №4, этап четвертый:

previousValue = 6 (результат пред шага был равен шести, теперь previousValue равен шести.)
item = 4 (тоже лАгичнА)
Их сумма = 10 (конечный результат!!!)

*/

// А что будет, если не указывать нач. значение?
// В таком случае, начальное значение будет равно первому элементу массива, т.е -
// previousValue = "Ваня". А работа самого метода начнется со второго элемента, т.е -
// item = "Иштван".

arrTwo = ["Ваня", "Иштван", "Оля",];

let reduceValueTwo = arrTwo.reduce(function(previousValue, item, index, array) {
	console.log( );
	console.log(previousValue); // => "Ваня"

	console.log( );
	console.log(item); // => "Иштван"

	return `${item}, ${previousValue}` // => "Иштван", "Ваня"
});

console.log( );
console.log(`Пользователи: ${reduceValueTwo}`);
// => "Пользователи: Оля, Иштван, Ваня"

// Метод reduceRight

// Метод reduceRight работает точно также как и reduce, но проходит по массиву
// не слева направо, а справа налево.

// Используем массив как массив или "как использовать массив и не превратить его в объект?"

// Следует раз и навсегда запомнить, что массив является объектом и, следовательно,
// ведёт себя как объект.

arr = ["Ваня", "Иштван", "Оля",];

console.log( );
console.log(typeof arr);
// => object

// Ну вот, объект. Но это еще не все - мы можем добавлять в массив свойства объекта
// точно также, как если бы на месте массив был объект:

// Добавление нечислового свойства

arr.name = "Коля";

console.log( );
console.log(arr);
// => [ "Ваня", "Иштван", "Оля", name: "Коля" ] (node)

// Но то, что действительно делает массивы особенными - это их внутреннее
// представление. Движок JavaScript'а  старается хранить элементы массива
// в непрерывной области памяти, один за другим.
// Существуют и другие способы оптимизации, благодаря которым массивы работают
// очень быстро, и даже быстрее объектов.

// Но все они утратят свою эффективность, если мы перестанем работать с массивом
// как с "упорядоченной коллекцией данных" и начнем использовать его как объект.

// Варианты неправильного применения массива:

/*

1. - Добавление нечислового свойства, например: arr.test = "5".
2. - Создание «дыр», например: добавление arr[0], затем arr[1000] (а между ними ничего нет).
3. - Заполнение массива в обратном порядке, например: arr[1000], arr[999] и так далее.

*/

// Домашка!!!

// 1) Изучить теорию
// 2) Решить задачи:

/*

Задача №1 (какое число, т.е длину мы получим?)

let arr = ["Ваня", "Иштван", "Оля",];
let newArr = arr;
newArr.push("Петя");

console.log(arr.length)

Ответ: 4.

Задача №2:

Создайте массив "users" с элементами "Ваня" и "Иштван".
Добавьте элемент "Оля" в конец.
Замените значение в "Иштван" на "Петя".
Ваш код для поиска значения должен работать для массивов с любой длиной.
Удалите первый элемент массива и покажите его.
Вставьте "Маша" и "Паша" в начало массива.

Решение:

let users = ["Ваня", "Иштван",]; - создаю массив
users.push("Оля"); - добавляю "Олю" в конец 
users[1] = "Петя"; - меняю "Иштвана" на "Петю"

users.shift(); - удаляю первый элемент массива
console.log(users[0]) - показываю его, выдает "Петю"

users.unshift("Маша", "Паша"); - добавляю элементы "Маша" и "Паша" в начало массива

Задача №3 (удалить элемент "Иштван" и возвратить его в другую переменную):

let arr = ["Ваня", "Иштван", "Оля"];

Решение: 

let otherVar = 	arr.splice(1, 1);

Задача №4 (сделать из строки массив):

let str = "Ваня,Иштван,Оля";

Решение:

let arr = str.split(",");

Задача №5 (чему равен previousValue в начале работы метода?)

let arr = [9, 2, 8,];
let reduceValue = arr.reduce(function(previousValue, item, index, array) {
	console.log( );
	console.log(previousValue);
});

Ответ: 9.

Примечание: интересно то, что последующие вызовы в консоль значения previousValue выдадут undefined.

*/