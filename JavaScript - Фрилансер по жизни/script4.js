// Метод join

// Метод join действует наоборот, он преобразовывает МАССИВ в строку, а не
// строку в массив, также с заданным разделителем.

let arr;
let arrTwo;
let obj;
let str;

arr = ["Ваня", "Иштван", "Оля",];
str = arr.join(",");

console.log( );
console.log(str);
// => "Ваня,Иштван,Оля"

// А теперь получим строку из массива:

arrTwo = ["Ваня", "Иштван", "Оля",];

console.log( );
console.log(String(arrTwo));
// => "Ваня,Иштван,Оля"

// Проверка массива: Array.isArray()

// -------------------------------------------------------

// Перед началом урока вспоминаем, что массивы - не образуют отдельный тип 
// данных, они основаны на другом типе данных. На объектах.

obj = {};
arr = [];

console.log( );
console.log(typeof obj);
// => object (как и ожидали, ничего удивительно)

console.log( );
console.log(typeof arr);
// => object (т.к массивы основываются на объектах)

// -------------------------------------------------------

// Часто бывает так, что у нас есть огромный код, а в нем куча разных объектв,
// строк, чисел и массивов. Это конечно хорошо, но как же нам узнать где массив
// а где нет? а вот для этого существует проверка Array.isArray(), которая
// нам как раз поможет. Синтаксис довольно прост: 

/*

Array.isArray(массив_на_проверку)

*/

// А теперь попрактикуемся!

if (Array.isArray(arr)) {
	console.log( );
	console.log("Это массив!");
} else {
	console.log( );
	console.log("Это не массив :(");
}

// => "Это массив!"

// Если зайти в консоль (любую, node или браузера) то мы увидим, что код отработал
// правильно, без ошибок.

// Перебор элементов

// С массивами можно сделать много чего, мы это уже поняли. Например, мы можем
// "перебрать" элементы какого нибудь массива.
// Для этого обычно используется цикл for:

arr = ["Ваня", "Иштван", "Оля"];

console.log( );
console.log(arr.length); // Узнаем длину массива
// => 3

for (let i = 0; i < arr.length; i++) {
	console.log( );
	console.log(arr[i], "- выведено при помощи простого цикла for"); // - выводим i элемент массива arr в консоль
}

// => {
/*
	"Ваня"

	"Иштван"

	"Оля"
*/
// }

// Ну вот, каждый элемент массива был выведен в консоль.
// Но мы еще можем использовать цикл FOR ... OF, он тут как раз подойдет:

for (let arrItem of arr) {
	console.log( );
	console.log(arrItem, "- а вот это выведено при помощи цикла for...of");
}

// Метод перебора forEach

// До этого мы перебирали массив при помощи циклов, но для перебора массива есть
// специальный метод - forEach.

// Он выполняет функцию для каждого элемента массива (также как и методы find
// findIndex и filter), а синтаксис у него точно такой же как и у find(Index) и
// filter'a (ну я ж говорил :D):

/*

arr.forEach(function (item, index, array) {
	// ... (делаем что-то крутое и интересное с массивом :>)
});

*/

// Попрактикуемся!

arr = ["Ваня", "Иштван", "Оля"];

arr.forEach(function(item, index, array) {
	console.log( );
	console.log(`Элемент "${item}" находится на ${index}-ой позиции в "${array}"`);
});

// => {
/*

	Элемент "Ваня" находится на 0-ой позиции в "Ваня,Иштван,Оля"

	Элемент "Иштван" находится на 1-ой позиции в "Ваня,Иштван,Оля"

	Элемент "Оля" находится на 2-ой позиции в "Ваня,Иштван,Оля"

*/
// }

// Код получился длинным, но оно того стоило - всё подробно описано, где и какой
// элемент лежит, + его позиция.
// Но мы можем написать то же самое, только при помощи стрелочных функций:

arr.forEach((item, index, array) => {
	console.log( );
	console.log(`Элемент "${item}" находится на ${index}-вой позиции в "${array}" - V2`);
});

// Также, при использовании метода forEach мы можем указывать имя некой ОТДЕЛЬНОЙ
// функции, да-да! т.е, мы создаем какую-то конкретную функцию и говорим forEach:
// "возьми и выполняй эту функцию!"

arr = ["Ваня", "Иштван", "Оля",];
arr.forEach(show);

function show(item) {
	console.log( );
	console.log(item);
};

// => "Ваня", "Иштван," "Оля" (каждый элемент на след. строке)

// Методы reduce/reduceRight

// Мы уже выяснили, что если нам нужно перебрать массив - мы можем использовать
// forEach, for или же for ... of.
// Если же нам нужно перебрать массив и вернуть данные для каждого элемента,
// то мы будем использовать map (он создает новый массив, подробнее в моем
// старом файле - script3.js).	

// Методы arr.reduce и arr.reduceRight похожи на эти методы, но они сложнее
// и используются для вычисления какого нибудь единого значения на основе
// всего массива.

// Синтаксис:

let value = arr.reduce(function(previousValue, item, index, array) {
	// ... (делаем что-то крутое, что-то такое что выходит за рамки реальности, ууу..)
}, ["initial"]);

/*

К привычным нам аргументам item, index и array добавляется previousValue:

previousValue - результат предыдущего вызова этой функции, равен initial при
первом вызове (если передан initial),
item - очередной элемент массива,
index - его индекс,
array - сам массив.

P.S: initial - начальное значение, судя по всему слово initial Жека взял СПЕЦИАЛЬНО,
поскольу initial значит "начальный, первоначальный". И да - Жека слово "initial"
не закрывал в кавычки, это я так сделал т.к выдает ошибку: "initial is not defined".

Функция применяется по очереди ко всем элементам массива и "переносит" свой результат
на следующий вызов.

Лично я - ничего не понял, но будет легче разобраться на примерах!

*/

// Создаем простейший массив чисел:

arrOne = [1, 2, 3, 4,];

// Объявляем новую переменную и присваиваем ей следующее:

// Обращаемся к массиву чисел (arrOne), ставим точку и пишем "reduce", открывая
// круглые скобки и указываем функцию, и в качестве начального значения previousValue
// указываем циферку ноль. Ну а в самом теле функции мы просто возвращаем сумму текущего
// значения массива с предыдущим, с previousValue.

let reduceValueOne = arrOne.reduce(function(previousValue, item, index, array) {
	return item + previousValue;
}, 0);

// А дальше мы выводим результат работы reduce:

console.log( );
console.log(reduceValueOne);
// => 10

// Отлично, получили 10! Но как оно так получилось, что нам вернуло 10? что же
// там внутри происходит? разберем все по-этапно:

/*

Шаг №1, этап первый:

previousValue = 0 (0 указано в функции, стоит на месте initial)
item = 1 (в массиве arrOne 1 первый элемент - логично!)
Их сумма = 1 (результат работы return item + previousValue)

Шаг №2, этап второй:

previousValue = 1 (previousValue равен 1, т.к previousValue - это результат работы пред. шага, а результатом был 1)
item = 2 (в массиве arrOne 2 второй элемент - тоже логично!)
Их сумма = 3 (результат работы return item + previousValue)

Шаг №3, этап третий:

previousValue = 3 (результат пред. шага равен трём, значит previousValue тоже равен трём!)
item = 3 (тут без объяснений, логичнее логичного :D)
Их сумма = 6 (и это тоже результат работы return item + previousValue)

Шаг №4, этап четвертый:

previousValue = 6 (результат пред шага был равен шести, теперь previousValue равен шести.)
item = 4 (тоже лАгичнА)
Их сумма = 10 (конечный результат!!!)

*/

// А что будет, если не указывать нач. значение?
// В таком случае, начальное значение будет равно первому элементу массива, т.е -
// previousValue = "Ваня". А работа самого метода начнется со второго элемента, т.е -
// item = "Иштван".

arrTwo = ["Ваня", "Иштван", "Оля",];

let reduceValueTwo = arrTwo.reduce(function(previousValue, item, index, array) {
	console.log( );
	console.log(previousValue); // => "Ваня"

	console.log( );
	console.log(item); // => "Иштван"

	return `${item}, ${previousValue}` // => "Иштван", "Ваня"
});

console.log( );
console.log(`Пользователи: ${reduceValueTwo}`);
// => "Пользователи: Оля, Иштван, Ваня"

// Метод reduceRight

// Метод reduceRight работает точно также как и reduce, но проходит по массиву
// не слева направо, а справа налево.

// Используем массив как массив или "как использовать массив и не превратить его в объект?"

// Следует раз и навсегда запомнить, что массив является объектом и, следовательно,
// ведёт себя как объект.

arr = ["Ваня", "Иштван", "Оля",];

console.log( );
console.log(typeof arr);
// => object

// Ну вот, объект. Но это еще не все - мы можем добавлять в массив свойства объекта
// точно также, как если бы на месте массив был объект:

// Добавление нечислового свойства

arr.name = "Коля";

console.log( );
console.log(arr);
// => [ "Ваня", "Иштван", "Оля", name: "Коля" ] (node)

// Но то, что действительно делает массивы особенными - это их внутреннее
// представление. Движок JavaScript'а  старается хранить элементы массива
// в непрерывной области памяти, один за другим.
// Существуют и другие способы оптимизации, благодаря которым массивы работают
// очень быстро, и даже быстрее объектов.

// Но все они утратят свою эффективность, если мы перестанем работать с массивом
// как с "упорядоченной коллекцией данных" и начнем использовать его как объект.

// Варианты неправильного применения массива:

/*

1. - Добавление нечислового свойства, например: arr.test = "5".
2. - Создание «дыр», например: добавление arr[0], затем arr[1000] (а между ними ничего нет).
3. - Заполнение массива в обратном порядке, например: arr[1000], arr[999] и так далее.

*/

// Домашка!!!

// 1) Изучить теорию
// 2) Решить задачи:

/*

Задача №1 (какое число, т.е длину мы получим?)

let arr = ["Ваня", "Иштван", "Оля",];
let newArr = arr;
newArr.push("Петя");

console.log(arr.length)

Ответ: 4.

Задача №2:

Создайте массив "users" с элементами "Ваня" и "Иштван".
Добавьте элемент "Оля" в конец.
Замените значение в "Иштван" на "Петя".
Ваш код для поиска значения должен работать для массивов с любой длиной.
Удалите первый элемент массива и покажите его.
Вставьте "Маша" и "Паша" в начало массива.

Решение:

let users = ["Ваня", "Иштван",]; - создаю массив
users.push("Оля"); - добавляю "Олю" в конец 
users[1] = "Петя"; - меняю "Иштвана" на "Петю"

users.shift(); - удаляю первый элемент массива
console.log(users[0]) - показываю его, выдает "Петю"

users.unshift("Маша", "Паша"); - добавляю элементы "Маша" и "Паша" в начало массива

Задача №3 (удалить элемент "Иштван" и возвратить его в другую переменную):

let arr = ["Ваня", "Иштван", "Оля"];

Решение: 

let otherVar = 	arr.splice(1, 1);

Задача №4 (сделать из строки массив):

let str = "Ваня,Иштван,Оля";

Решение:

let arr = str.split(",");

Задача №5 (чему равен previousValue в начале работы метода?)

let arr = [9, 2, 8,];
let reduceValue = arr.reduce(function(previousValue, item, index, array) {
	console.log( );
	console.log(previousValue);
});

Ответ: 9.

Примечание: интересно то, что последующие вызовы в консоль значения previousValue выдадут undefined.

*/

// DOM

// !!!ВАЖНОЯ ИНФАРМАЦЫЯ!!!

// Итак, мы подобрались к предпоследнему уроку по JS от Жеки, и в этом уроке - о
// окружении, DOM (или же "Document Object Model", или "Объектная модель документа").
// Урок ОГРОМНЫЙ - идет он целый час (тема - важная). Но что мы узнаем
// в этом уроке? в этом уроке мы наконец-то поймем, как связать наш JS с версткой (а
// именно - с HTML и CSS!), научимся создавать HTML теги / изменять CSS стили напрямую
// из нашего JavaScript кода и многое другое!
// И да - рекомендую открывать код в браузере (если вы скачали архив с файлами),
// ибо весь последующий код будет напрямую свзяан с HTML и открывать его в node консоли -
// не рекомендуется (возможны вылеты, ошибки).

// ----------------------------------------------------------------------------------------------------------

// Для начала разберемся, что же такое "окружение"! А начнем с того, что 
// JS изначально был создан сугубо для браузеров, но сегодня он является мультиплатформенным
// языком программирования для решения широкого круга задач.
// JS может использоваться в веб-браузере, на веб-сервере или любой другой среде, даже
// в электронных часах (настольных и т.п)!
// Каждая такая среда предоставляет свою функциональность, которую спецификация JavaScript
// и называет "окружением". Окружение предоставляет свои объекты и дополнительные функции,
// в дополнение к базовым возможностям JS. Браузеры, например, предоставляют возможности
// для управления веб-страницами (я думаю, что Жека имел ввиду DevTools и т.п), а nodeJS
// некоторые серверные функции и т.д.
// Но нас, как верстальщиков, интересует именно БРАУЗЕРНОЕ окружение. Ниже таблица того,
// как всё устроено (я старался сделать такую же, как у Жеки :D):

/*

				  Браузерное окружение

		----------------{WINDOW}--------------
		|				   |				 |
		|				   |				 |
		|				   |		 		 |
	  [DOM]			     [BOM]		    [JavaScript]
		|                  |	  	         |
		|                  |			 	 |
		|				   |				 |
		ˇ		    	   ˇ			     ˇ
	 {document}	      {navigator}		  {Object}
	 И прочие...	  {location}		  {Array}
					  {history}			  {Function}
					  И прочие...		  И прочие...
*/

// Вот здесь, на схеме - в общих чертах показано, что доступно JavaScript'у в данном окружении.
// Во главе всего находится объект Window, который помимо того что является ГЛОБАЛЬНЫМ объектом,
// также представляет собой окно браузера и обладает методами для управления им.

// Например, методом innerWidth мы можем получить ширину нашего окна браузера:

let windowWidth = window.innerWidth;
// Двух console.log()'ов больше не будет - раньше я их добавлял для отступа в консоли node.
console.log(`Ширина окна браузера: ${windowWidth}px`);
// => (результат будет зависить от ширины окна браузера, лично у меня 1214 - не в полноэкранном режиме,
// 1280 - в полноэкранном!)

// Существует гораздо больше свойств и методов для работы с окном браузера, в том числе
// и прокруткой - но обо всём этом позже, а пока продолжим знакомиться с Окружением.
// Итак, после объекта Window у нас сам JavaScript со своими сущностями: объекты, массивы, функции и т.д.
// Мы уже со всеми ними знакомы, поэтому идем дальше. Объектная модель браузера - Browser Object Model,
// он же BOM. Это дополнительные объекты предоставляемые браузером для того, чтобы работать со ВСЕМ,
// КРОМЕ самого документа.

// Например, с помощью объекта navigator мы можем получить инфу о самом браузере и ОС:

// Браузер
console.log(navigator.userAgent);
// => "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36"

if (navigator.userAgent.includes("Chrome")) {
	console.log("Браузер Хром");
} else if (navigator.userAgent.includes("Firefox")) {
	console.log("Браузер Firefox")
}
// => "Браузер Хром" (я любитель Хрома :D)

// Платформа

console.log(navigator.platform);
// => Win32 (понятия не имею почему 32, должно быть 64 - Жека про это ничего не сказал)

// А с помощью объекта location мы можем получить текущий URL или перенаправить браузер по новому адресу:

// Получаем URL
console.log(location.href);
// => (путь к моему index.html файлу)

// Меняем URL
// location.href = "https://google.com"; (закомментировал, реально перенаправляет на другой сайт)

// А объект history позволяет управлять историей браузера, передвигаться по ранее посещенным страницам.

// history.back(); (мешает, закомментировал)
// history.forward(); (мешает, закомментировал)
// P.S - как им пользоваться он не рассказал, но сказал что подробнее об этих объектах надо говорить в отдельном уроке.

// А сейчас пора добавить, что существуют еще полезные методы для коммуникации с пользователем - это
// методы alert(), confirm() и prompt(), которые также являются частью BOM.

// Alert

// Итак - при помощи alert мы можем вызвать простое диалоговое окно с нашим заданным
// в ней текстом, например - "Привет!", при этом будет только одна кнопка на этом окошке - "ОК",
// которая как раз таки и закрывает это окно.

// alert("Привет!"); (я закомментировал, т.к мешает при перезагрузке страницы - постоянно на "ОК" надо нажимать)
// => Выведено диалог. окно с надписью "Привет!"

// Confirm

// А с confirm чуточку сложнее - помимо того что мы выводим в диалоговом окне свой текст (как в случае
// с командой alert), у нас будут две маленькие кнопки: "ОК" и "Отмена" - но вся соль не в этом.
// Мы можем СОХРАНИТЬ полученное значение, результат (от ответа) в переменную! Вот пример:

// let confirmResult = confirm("Хочешь научиться верстать?");
// console.log(confirmResult);
// => true - если нажата кнопка "ОК", false - если нажата кнопка "Отмена".

// Prompt

// А вот с prompt еще сложнее - помимо простого текста и кнопочек, пользователю предоставляется возможность
// еще ввести свой некий текст, который мы можем сохранить в переменную либо в константу! Вот пример:

// let promptResult = prompt("Кто ты по жизни?")
// console.log(promptResult)
// => (в зависимости от того, какой текст был введен в поле ввода).

// И да - если пользователь ничего не ввел в поле ввода и нажал "ОК" - в консоль будет выведена
// простая пустая строка. Если же он, пользователь, нажал на кнопочку "Отмена" - в консоль будет
// выведен "null".
// И еще кое что - в силу того, что эти диалог. окна почти никак нельзя стилизовать - их используют
// довольно редко (хотя можно создать СВОЕ диалоговое окошко, но это трудоемкий процесс).

// Всё это прекрасно, но нас больше всего интересует DOM, Document Object Model.
// DOM представляет собой всё содержимое HTML страницы в виде объектов, которые мы можем менять.
// Кстати, правила CSS стилей структурированы иначе, чем HTML, также существует спецификация
// "CSS Object Model", или же "CSSOM" (сколько же этих BOM'ов, DOM'ов, CSSOM'ов..), которая объсняет,
// как стили должны представляться в виде объектов, как их читать и писать. Подробнее можно
// почитать в интернете, достаточно написать "спецификация CSSOM", а мы дальше идем разбираться
// что же такое Document Object Model.

// Во первых, мы уже знаем, что основой любого HTML документа являются теги,
// и в соответствии с DOM каждый тег явялется объектом. Вложенные теги являются дочерними и потомками
// своего родителя, и даже текст является объектом, и комментарии в этом плане
// тоже никак не хотят отставать - они тоже объекты! абсолютно все эти объекты доступны нам из
// JavaScript и мы можем ими управлять.

// Чтобы лучше визуализировать себе дерево документа мы можем открыть
// панель разработчика, DevTools. Она открывается клавишей F12 (иногда требуется зажать FN), или же CTRL + SHIFT + I,
// при этом мы обязательно должны находиться на какой нибудь страничке.
// Во всей открытой панельке нас интересует лишь "Elements", так как с "Console" мы уже знакомы. Заходим
// во вкладку "Elements", здесь представлены все объекты и мы можем нажимая на треугольник (слева от некоторых
// тегов) разворачивать родительский объект и видеть его дочерние элементы, а также потомков. Тут же
// мы видем и комментарии и текст, которые ТОЖЕ являются частью дерева DOM. Итак, HTML документы
// представлены в браузере в виде дерева DOM, теги становятся узлами-объектами и формируют структуру
// документа, а текст становится текстовым узлом. Всё, что написано в HTML документе, является частью
// DOM-дерева, и даже комментарии.

// Отлично, что такое дерево документа мы поняли, но как
// же с ним взаимодействовать? Все операции с DOM начинаются с объекта document, это основная точка входа
// в DOM, из него мы можем получить доступ К ЛЮБОМУ узлу. Для начала разберем навигацию по DOM-элементам.
// Самые верхние объекты - это теги <html>, <head> и <body>. Почему они "верхние"? а всё потому что
// они располагаются выше всех остальных объектов в дереве DOM, это можно понять зайдя в DevTools в
// браузере - самыми верхними будут html, head, body. Все остальные теги (объекты в DOM) располагаются
// внутри них. Однако, самым-самым верхним является <html>, а <head> с <body> находятся уже внутри него.
// Но тем не менее, они всё также являются верхними объектами.
// А, и да, чуть не забыл - при входе в DTools, первым открытым объектом  может быть открыть объект
// body - это потому что мы находимся на странице, а так достаточно просто его закрыть (слева треугольник)
// и будет видно те самые три верхних объекта :)

// Как сказано выше, объект document является основной точкой входа в DOM, и самые верхние элементы
// дерева DOM доступны нам как его свойства:

const htmlElement = document.documentElement; // => сохраняем в константу весь тег HTML, т.е - весь документ
const headElement = document.head; // => сохраняем в константу тег head
const bodyElement = document.body; // => сохраняем в константу тег body


// Используя константы, мы сохраняем эти теги (объекты) и можем вывести их в консоль
// вместе со всем их содержимым:

console.log(htmlElement); // => { html -> head > ... / body > ... }
console.log(headElement); // => { head -> ... }
console.log(bodyElement); // => { body -> ... }

// Итак, получив объект body в некую константу мы можем использовать именно этот объект
// как "отправную точку" для последующей навигации!
// Например, свойством firstChild мы можем получить первый узел данного объекта, сохранив его
// его в константу:

const firstChildNode = bodyElement.firstChild;

// Кроме firstChild есть также и lastChild, и по названию не трудно догадаться, какой узел
// из объекта он может сохранить либо вывести в консоль - последний (англ. last) узел:

const lastChildNode = bodyElement.lastChild;

// А теперь мы выведем эти два элемента в консоль:

console.log(firstChildNode); // => { #text }
console.log(lastChildNode); // => <script src="js/script4.js"></script>

// Нам вывело два узла из объекта body, а именно первый и последний.
// Рассмотрим сначала последний, дочерний узел. Это тег script, которым мы привязали
// наш скрипт (этот :D) к страничке. Убедиться в этом не трудно, достаточно опять же открыть
// DTools и зайти в "Elements", открыв там объект body - последним узлом в дереве DOM является
// наш тег script. И тут стоит добавить, что после записи "console.log(lastChildNode);" может быть
// еще какой-то HTML код, но он не будет здесь (в консоли) показан, так как он идет ПОСЛЕ
// привязки script файла в документе. Именно поэтому важно добавлять тег script в самый низ
// body (ну не именно ПОЭТОМУ, просто так положено что-ли..).
// Отлично, но первый дочерний элемент у нас какой-то объект "#text", хотя мы своими
// глазами можем увидеть тег h1 в HTML коде! Почему так? что это за "магия"?!
// Всё потому, что мы получаем здесь именно УЗЛЫ, а если мы раскроем этот объект мы увидем (кашу)
// много всякого интересного, но нас интересует 4-ая строка: «data: "\n\n\t"» (\t создает кавычки).
// Если ввести этот код в любом онлайн редакторе или у себя в файле, мы увидим вот такую вот картину:

//	"

//		"

// Но что оно означает? - видите внутри кавычек разрыв строки? ну между открывающей и закрывающей?
// Если да, то значит со зрением у вас всё хорошо.
// А если без шуток, то это означает, что первый элемент на странице - разрыв строки.
// Но как же так?! первый элемент ведь h1! - всё дело в том, что после знака ">" (<h1>) идет разрыв
// строки - это легко проверить, достаточно зайти во вкладку 'Elements' в DTools или открыть index.html.
// Разрыв строки ТОЖЕ является своеобразным узлом в DOM.

// Чтобы стало еще понятнее, воспользуемся свойством childNodes.
// childNodes получает список всех непосредственных "детей" данного объекта, а я напомнию, что в нашем
// случае "данным" объектом является тег body со всем его содержимым - тегами, текстом и т.д.
// Давайте опять создадим константу, а значение присвоим такое: bodyElement.childNodes -

const childNodes = bodyElement.childNodes

// Таким образом, мы присваиваем константе все дочерние элементы body.
// А теперь выведем их всех во всеми любимую консоль:

console.log(childNodes);
// => nodeList(16) [text, h1, text, h3, text, div.lesson, text, comment, text, comment, text, comment, text, comment, text, script]

// Итак.. нам выдало что-то похожее на массив, но это не массив, а кое что другое - коллекция.
// О коллекциях мы поговорим позже, а пока что посмотрим на то что нам выдало: внутри МНООООООООООГО
// всяких элементов "text" - это и есть те самые разрывы строк (Enter'ы), опять же много комментариев,
// h1 и h3, div с классом lesson и тег script. Все эти элементы "дочки" body.

// Ну вот, теперь мы узнали о свойстве childNodes (а именно то, что он выводит ВСЕ дочерние свойства
// у объекта). Но стоит добавить, что если мы хотим проверить, существуют ли дочерние элементы
// у объекта - можно воспользоваться специальной функцией hasChildNodes().
// Она нам может помочь если мы хотим узнать, есть ли у объекта дочерние элементы.
// Выводит она только 2 значения: либо true либо false.
// Пример работы функции:

// Проверяем body на наличие дочерних объектов/элементов
console.log(bodyElement.hasChildNodes());
// => true

// А теперь мы поговорим о коллекциях.
// Итак, как я уже ранее писал, childNodes похож на массив, но на самом деле это не массив - это
// КОЛЛЕКЦИЯ. Особый перебераемый объект, псевдо-массив. Отличия от массива:

// 1. - Для перебора коллекции мы можем использовать for .. of.
// 2. - Методы массивов НЕ БУДУТ РАБОТАТЬ, потому что коллекция - не массив.

// А теперь переберем коллекцию childNodes (константу childNodes, в которую мы сохранили всех "дочек"
// объекта body) при помощи for .. of:

for (let node of childNodes) {
	console.log(node); // покажет все узлы из коллекции
}

// У коллекций есть еще несколько интересных особенностей.

// Во первых: почти все DOM коллекции (за небольшим исключением) "живые". Это значит, что переменная
// либо константа которая содержит коллекцию, будет отражать РЕАЛЬНОЕ текущее состояние дерева DOM.
// Т.е, после того как мы присвоили переменной либо константе коллекцию, а далее тем или иным
// способом изменили дерево DOM, (так вот) в переменной либо константе будет АКТУАЛЬНОЕ состояние
// всего дерева. Мы к этому еще вернемся, только чутка позже.

// Во вторых: DOM коллекции, да и другие навигационные свойства о которых я еще напишу - доступны
// только для чтения. Мы не можем просто взять и заменить тот или иной узел, например, вот так:

// childNodes[i] = "Че-то там очень-очень важное!"

// Такое изменение значений допустимо для массивов, но не для коллекций.
// Для изменения DOM требуются другие методы, о которых я, опять же, напишу позже.
// А пока что продолжим разбираться с навигацией по дереву DOM, и разберем обращение к пред.
// узлу объекта, к след. узлу объекта а также непосредственно к родителю объекта, и для этого
// существуют соответствующие свойства.
// Итак. Для того, чтобы получить предыдущий узел объекта, который находится на том же уровне
// вложенности, мы используем свойство previousSibling.
// Попробуем получить в константу (для объекта body) предыдущий узел и вывести в консоль:

// Получаем предыдущий узел
const previousSiblingNode = bodyElement.previousSibling;

// Выводим в консоль
console.log(previousSiblingNode)
// => #text

// Мы опять получили некий текстовый узел (который мы не увидим в разметке), это или enter или
// пробел, или может еще что-то в этом роде.
// А теперь сохраним в константу СЛЕДУЮЩИЙ узел (опять же, для объекта body):

const nextSiblingNode = bodyElement.nextSibling;

// И опять выведем его в консоль:

console.log(nextSiblingNode);
// => null

// Мы получили null, но почему? - ну, тут может быть два варианта: либо после body ничего нет (за
// исключением закрывающих тегов </body> и </html>), либо наш JS файл НЕ ВИДИТ того, что
// идет после объекта body (ибо мы поставили наш тег script в самый конец). Как по мне,
// вариант №2 более правдоподобный, так как JS действительно может не видеть того, что
// происходит "за пределами" body. В любом случае - получен null.
// Хорошо, а теперь сохраним в константу "папу" body:

const parentNode = bodyElement.parentNode;

// и опять же выведем его в консоль:

console.log(parentNode);
// => { html > head > ... / body > ... }

// Мы получили ВЕСЬ объект html, вместе со всем его содержимым. Логично, ибо
// родитель body и в правду тег html.

// Навигация только по элементам
	
// Навигационные свойства, описанные выше, относятся КО ВСЕМ узлам в документе.
// В частности, в childNodes находятся и текстовые узлы, и узлы-элементы, и узлы-комментарии,
// если они есть. Именно это мы уже и видели:

// console.log(childNodes);
// => nodelist(16) [..]

// Но для большинства задач нам нужны только объекты, т.е только HTML теги, с которыми мы хотим
// проводить некоторые манипуляции. Так вот - для этого существуют отдельные свойства!
// Первое из них - свойство children. Это то же самое что и childNodes, в плане того
// что мы получаем коллекцию всех дочерних элементов, но тут есть одно НО - мы получаем
// все дочерние элементы, НО НЕ УЗЛЫ. Т.е - мы получаем только дочерние HTML теги, а комментарии
// и пробелы с enter'ами получать мы не будем (жалко-печально :c).

const bodyChildren = bodyElement.children;
console.log(bodyChildren, "- коллекция из всех дочерних ЭЛЕМЕНТОВ <body>");
// => HTMLCollection(4) [h1, h3, div.lesson, script]

// Запустили консоль и увидели коллекцию, содеражщую в себе 4 HTML элемента.
// А теперь сравним эту красотень с коллекцией childNodes:

console.log(childNodes, "- коллекция из всех дочерних УЗЛОВ <body>");
// => NodeList(16) [...]

// Запускаем консоль и видим коллекцию childNodes и bodyChildren: childNodes это коллекция,
// которая содержит в себе ВСЕ дочерние узлы у объекта body (это и текстовые узлы, и комментарии
// которые у нас там есть), а вот bodyChildren это тоже коллекция, но которая содержит фактически
// только элементы, только HTML теги.

// Соответственно, для каждого навигационного свойства которые мы разобрали ранее, существуют
// аналоги, но которые возвращают именно элементы, именно HTML теги.
// Например: первый и последний элемент мы можем получить при помощи firstElementChild и
// lastElementChild соответственно:

// Получаем первый и последний ЭЛЕМЕНТ на странице:
const firstChild = bodyElement.firstElementChild;
const lastChild = bodyElement.lastElementChild

// Выводим их в консоль:

console.log(firstChild);
// => <h1>...</h1>
console.log(lastChild);
// => <script src="..."></script>

// Выведя эти элементы в консоль, мы получаем два элемента - первый и последний элементы
// на страничке. Это еще не всё! мы можем сохранить в константу, либо переменную - ссоедние
// и родительский элементы! -

// Сохраяем соседние и родительский элементы в константы:

const previousSibling = bodyElement.previousElementSibling;
const nextSibling = bodyElement.nextElementSibling;
const parentElement = bodyElement.parentElement;

// А теперь выведем эту троицу в консоль:

console.log(previousSibling);
// => <head>...</head>
console.log(nextSibling);
// => null
console.log(parentElement);
// => <html>...</html>

// Итак, предыдущим элементом по отношению к body является head, следующим элементом
// никто не является (опять же тут два варианта почему, о них можно прочитать выше),
// а родительским является тег html со своим содержимым, первый верхний объект в DOM.

// А для лучшего понимания, быстро проговорим основные навигационные свойства по элементам.
// Допустим, у нас есть страница:

/*

Представление нашей index.html страницы в виде DOM

html {

	head {

		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link rel="stylesheet" href="style.css">
		title {
			JS - Фрилансер по жизни
		}

	}

	body {

		h1 {
			span.yellow {
				"JavaScript."
			}

			"Браузерное окружение."
			
			"Работа с" span.yellow {
				"DOM."
			}
		}

		h3 {
			"Урок №13"
		}

		div.lesson {
			div.lesson_text {
				<!-- Комментарий-->
					"Текст"
				}
		}
		
	<script src="script4.js"></script>

	}

}

*/

// Во всём этом дереве нас интересует наш bodyElement, он же объект body, он же тег body.
// Итак, у нас есть объект body, и для того чтобы обратиться к предыдущему элементу (по
// отношению к body) мы должны использовать свойство previousElementSibling, и когда мы
// его заиспользуем нам выдаст объект head со всем его содержимым.
// А если же мы хотим обратиться к следующему элементу (также по отношению к body), то
// мы должны использовать nextElementSibling, и когда мы его заиспользуем нам выдаст null,
// так как после body ничего нет (как оказалось, это основная причина выдачи null). А если
// мы хотим получить родителя, то мы должны использовать свойство parentElement, и когда
// мы его заиспользуем нам выдаст объект html, так как объект body находится внутри него.
// А если мы хотим обратиться ко всем дочерним (непосредственным дочерним) объектам нашего
// body - мы используем children, и при его использовании нам выдаст коллекцию HTML тегов.
// Если мы хотим обратиться к ПЕРВОМУ дочернему элементу у нашего body - мы используем
// firstElementChild, и при его использовании нам выдаст объект h1 со всем его содержимым.
// А если же мы хотим обратиться к ПОСЛЕДНЕМУ доч. элем. у нашего body - мы используем
// не firstElementChild, а lastElementChild, и при его использовании нам выдаст
// простой тег script (не объект, так как внутри него ничего нет).

// Поиск произвольного элемента: querySelectorAll

// Отлично! но эти свойства навигации по DOM-дереву нам очень пригодятся тогда, когда мы
// захотим получить объект который находится рядом! а что если это не так? что если
// мы хотим получить ПРОИЗВОЛЬНЫЙ объект на странице? - для этого есть отдельные методы
// для поиска по дереву DOM, которые мы сейчас и изучим!
// P.S - для этого я добавил некий HTML код на страницу, но он не такой как у Жеки - всё
// дело в том, что я не знаю какие стили он применял для этого кода! но, всё же.

// Итак, первый метод поиска - element.querySelectorAll(CSS.selector).
// Он самый мощный, самый часто используемый. Он ищет и возвращает абсолютно все элементы
// внутри некоего объекта, которые удовлетворяют заданному CSS-селектору.
// Это действительно мощный метод, потому что можно использовать абсолютно любой селектор.
// Что такое селектор мы уже знаем, мы это не так давно уже проходили - поэтому начнем
// изучение этого метода прямо сейчас!

// Поиск по селектору класса

// Для того чтобы найти все селекторы с классом "lesson__list", мы можем создать переменную
// и внутрь неё присвоить такие элементы. После присваивания, в переменную будет сохранена
// коллекция всех узлов с таким классом. Сохраним все элементы с классом lesson__list в
// переменную!... но перед этим стоит добавить, что надо обязательно ставить точку перед
// названием класса (всё прям как в CSS):

let elemsOne = document.querySelectorAll('.lesson__list');

// Отлично, теперь мы можем взаимодействовать с этой переменной!
// К примеру, вывести её значение в консоль:

console.log(elemsOne);
// => NodeList [ul.lesson__list]

// Заходим в консоль, смотрим: нам выдало коллекцию, состоящую из одного элемента.
// Так-то всё правильно, у нас в index.html только 1 элемент с таким классом.

// Поик по селектору тега

// Отлично, с селектором по классу мы разобрались, а теперь попробуем провернуть то же самое,
// но уже с селектором по тегу!

let elemsTwo = document.querySelectorAll('li');

// Так, отлично! сохранили в переменную все теги li, а теперь выведем их в виде
// коллекции в консоль -

console.log(elemsTwo);
// => NodeList (7) [...]

// Ну вот, опять заходим в консоль и смотрим: а там у нас коллекция из 7 элементов,
// и все эти элементы - теги li.
// В общем, я думаю всем кто это читает уже понятно, что это свойство просто берет
// и создает коллекцию из элементов, удовлетворяющих селектору.
// Но, останавливаться на этом было бы глупостью - всё таки надо показать тому, кто
// читает всё это (да и мне тоже), что он может принимать действительно ЛЮБЫЕ
// селекторы, в ЛЮБОМ виде.

// Поиск по смешанному селектору - тега и класса

// Из уроков по CSS мы знаем, что можно "смешивать" селекторы. Например, объединить
// селектор по тегу и по классу: тег.класс
// Давайте сохраним в переменную все элементы li с классом lesson__list-item -

let elemsThree = document.querySelectorAll('li.lesson__list-item');

// А теперь выведем в консоль эту коллекцию элементов:

console.log(elemsThree);
// => NodeList (4) [...]

// Смотрим в консоль - у нас тут коллекция из 4-х элементов, и во всех этих
// элементах есть класс .lesson__list-item.

// Поиск по тегам первого уровня вложенности

// В CSS мы это не проходили, но есть селектор "первого уровня вложенности".
// Он выбирает те элементы, которые являются "дочками", "потомков" он не трогает.
// Давайте сохраним в переменную все теги первого уровня вложенности внутри ul
// с классом .lesson__list (первый ul на странице) -

let elemsFour = document.querySelectorAll('.lesson__list > li');

// Выводим в консоль полученную коллекцию элементов:

console.log(elemsFour);
// NodeList (4) [...]

// Заходим в браузер, открываем консоль - а у нас там всё та же коллекция из 4
// элементов. Всё просто - это и есть те самые li с классом lesson__list-item,
// они самые верхние (дочерние, короче). После третьего идет второй ul, но у его
// li'шек другой класс - .lesson__sub-list-item.

// Поиск по нескольким классам

// В CSS есть селектор по нескольким классам, про него мы знаем - он выбирает
// несколько классов и применяет ко всем заданные стили: класс, класс {...}
// Сохраним в переменную все теги с классами .lesson__list и .lesson__test -

let elemsFive = document.querySelectorAll('.lesson__list, .lesson__text');

// А теперь выведем в консоль полученную коллекцию:

console.log(elemsFive)
// => NodeList (2) [...]

// Итак, в коллекции у нас только два элемента - один div с классом lesson__text,
// другой - ul с классом lesson_list.

// Поиск по вложенным классам

// В CSS существует селектор ВЛОЖЕННЫХ классов/тегов, и если его использовать - то
// он будет применять стили к тем элементам, которые находятся только внутри других.
// Объяснять трудно, легче показать как он выглядит: .lesson__list .lesson__text {...}
// В коде выше, мы ищем все теги с классом. lesson__text внутри тегов с классом
// .lesson_list, и применяем к ним какие нибудь стили, например меняем цвет.
// Сохраним в переменную все теги с классом .lesson_text, находящиеся внутри тегов
// (ну или тега) с классом .lesson__list -

let elemsSix =  document.querySelectorAll('.lesson__list .lesson__text');

// А теперь выводим полученную коллекцию в консоль:

console.log(elemsSix);
// > NodeList []

// В консоли появилась пустая коллекция, абсолютно пустая.
// Всё дело в том, что тегов с классом .lesson__text внутри тегов (тега) с классом
// .lesson__list - нету, вообще нету.

// Поиск по ID

// ID - уникальный атрибут, который может присваиваться любому HTML тегу, но
// использовать его можно лишь для 1 элемента (от того то он и уникальный),
// а не для нескольких, как класс. Селектор записывается через решетку.
// Сохраним в переменную тег (именно тег, я думаю понятно почему) с атрибутом id:

let elemsSeven = document.querySelectorAll('#listItem');

// А теперь выведем коллекцию (из 1 элемента :D) в консоль:

console.log(elemsSeven);
// => NodeList [li#listItem.lesson__list-item]

// Нам выдало в консоль коллекцию, в которой находится всего лишь 1 элемент.
// В принципе, ничего другого ожидать и не нужно было - в любом случае
// бы выдало лишь 1 элемент, так как у нас есть всего лишь 1 элемент с таким
// атрибутом, подобных ему не было, нет и не будет.

// Поиск по атрибуту

// querySelectorAll может искать элементы ПО АТРИБУТУ!
// Представим, что у нас на странице есть элементы с атрибутом name - мы вводим
// его (атрибут) в круглые скобки, и нам в коллекцию сохраняются все элементы
// с таким атрибутом на странице. Но, не всё так просто! - атрибут заключается
// в квадратные скобки, без них никак.
// Сохраним в переменную (то есть коллекцию) все теги с атрибутом name:

let elemsEight = document.querySelectorAll('[name]');

// А теперь выведем полученную коллекцию в консоль:

console.log(elemsEight);
// => NodeList (3) [...]

// Нам вывело в консоль коллекцию, в которой хранятся ВСЕ элементы с таким
// атрибутом, и не важно какое у него значение - всё равно ж будет выведено! :)

// Поиск по атрибуту со значением

// Здесь всё то же самое что и в предыдущем случае, тот же поиск по атрибуту, но
// уже более "улучшенный" - это поиск по тому же атрибуту, но с неким значением.
// Например - мы можем найти все элементы на странице, у которых есть атрибут
// name со значением "arbuz". Короче - поиск по атрибуту версия 2.0 :D
// Как его использовать? всё просто! - просто пишем имя атрибута, знак равно,
// открываем кавычки и пишем искомое значение (будто задаем атрибуту значение).
// Сохраним в переменную элемент, у которого есть атрибут name со значением
// "lesson__list-item-two" (у меня один такой элемент :D):

let elemsNine = document.querySelectorAll('[name="lesson__list-item-two"]');

// А дальше по старинке - выводим в консоль!

console.log(elemsNine);
// NodeList [li#listItem.lesson__list-item]

// Получили мы в консоль, значит, коллекцию.
// А коллекция почти что пустая - всего-то один элемент в ней!
// Всё потому, что у нас на странцие всего лишь 1 элемент с атрибутом name, у
// которого значение равно "lesson__list-item-two".

// Наш разговор о том, какие селекторы может перебирать метод querySelectorAll,
// уже давно подошел к концу. Но сейчас мы будем говорить о том, какие коллекции
// возвращает этот метод! я уже говорил, что он (метод) возвращает коллекцию, но
// она не является "живой", она СТАТИЧНАЯ. И, поскольку это коллекция, а коллекция
// это "псевдо-массив" - мы можем получать из коллекций КОНКРЕТНЫЙ объект!
// Для этого мы также как и у массивов ставим кв. скобки, индекс и.. готово.
// Итак -  получаем в переменную коллекцию из всех элементов li на странице, а
// затем выводим в консоль третий элемент (0 - 1, 1 - 2, 2 - 3):

let elems = document.querySelectorAll('li');
console.log(elems[2]);
// =>  <li class="lesson__list-item">...</li> (объект)

// Итак.. получили мы, собственно, объект. Ничего другого ожидать и не нужно было,
// в любом случае бы объект получили :D
// Кстати! раз уж это коллекция, а коллекции это псевдо-массивы - мы можем
// эту коллекцию ПЕРЕБРАТЬ! используем всё тот же for..of:

for (let item of elems) {
	console.log(item);
}

// => (много li'шек)

// Ну что сказать.. нам вывелись ВСЕ элементы li на странице, буквально ВСЕ.
// В принципе ничего интересного... но будет интересно тогда, когда мы
// заиспользуем метод forEach! несмотря на то что коллекция - не массив,
// мы можем использовать метод forEach, который выполняет функцию колбэк
// один раз для каждого элемента в массиве.

elems.forEach(item => {
	console.log(item, "- выведено через forEach");
});

// => (много li'шек)

// Кстати, искать что-то можно не только в document! вот пример:

const subList = document.querySelectorAll('.lesson__sub-list');
const subListItems = subList[0].querySelectorAll('li');
console.log(subListItems);
// => NodeList (3) [...]

// Что мы делаем в нашем коде? мы создаем константу subList и сохраняем
// в неё ВСЕ элементы на странице, у которых есть класс .lesson__sub-list.
// Затем, мы берем и создаем константу subListItems, сохраняя в неё ВСЕ теги
// li из ПЕРВОГО элемента, объекта с классом .lesson__sub-list, используя
// квадратные скобки и индекс. А в конце мы просто выводим полученную коллекцию,
// в которой хранятся все элементы li из объекта с классом .lesson__sub-list :)

// Но иногда такой подход может вернуть неожиданный результат поиска, или не
// совсем ожидаемый. Почему? сейчас поймете! -

const subListTwo = document.querySelectorAll('.lesson__sub-list');
const listItems = subListTwo[0].querySelectorAll('.lesson__list .lesson__sub-list-item');
console.log(listItems)
// => NodeList (3) [...]

// Здесь у нас по началу всё то же самое, что и в коде выше. Мы создаем константу
// subListTwo (она не ничем не отличается от subList, я её создал чтобы было
// меньше путаницы) и сохраняем в неё все элементы на странице, у которых есть
// класс .lesson__sub-list. На этом этапе, когда вы уже читаете этот текст,
// остановитесь и не читайте текст дальше, потому что вы легко запутаетесь -
// пересмотрите код на 1108-ой строке и зайдите в index.html, затем посмотрите
// на код, дабы понять что и где находится. Внутри третьего li у нас находится
// тот самый "под-список", он же .lesson__sub-list. Если вы посмотрели на код
// и поняли что да как, то идем дальше! После создания константы subListTwo
// и её заполнения мы создаем вторую константу, listItems, и присваиваем ей
// ВСЕ элементы с классом .lesson__sub-list-item, которые находятся внутри
// элементов с классом .lesson__list, которые в свою очередь находятся внутри
// элементов с классом .lesson__sub-list.  А теперь идите обратно в index.html
// и посмотрите внимааааательно на код - вас ничего не смущает? мы ищем элементы
// под-списка, .lesson__sub-list-item, находящиеся внутри основного списка,
// .lesson__list, который в свою очередь находится внутри под-списка!
// По идее, у нас в listItems должна сохраниться пустая коллекция... но как
// бы ни так! посмотрите, нам выводит коллекцию из трёх элементов с классом
// .lesson__sub-list-item, это элементы под-списка!
// Всё дело в том, что querySelectorAll проверяет только последний элемент
// БЕЗ учёта контекста.

// Поиск произвольного элемента: querySelector

// Следующий метод поиска - querySelector! он очень похож на querySelectorAll,
// но они отличаются. Метод querySelectorAll ищет и находит ВСЕ элементы
// с заданным классом, а querySelector находит только ПЕРВЫЙ ПОВАВШИЙСЯ элемент.
// Использовать его просто - синтаксис у него на 100% такой же, как и у пред.
// метода querySelectorAll - в круглых скобках вписывается селектор, по которому
// метод будет искать необходимые нам элементы. Но найдет он лишь 1 элемент (или
// 0, если такого нет), самый первый. Допустим, мы ищем элемент с классом "abc",
// а у нас на сайте их с десяток! он найдет и выдаст нам такой элемент, с таким
// классом, но этот элемент будет первым на странице. Но чтобы было легче
// понять - надо применить! применим его, пытаясь найти элемент с классом
// .lesson__list внутри всего документа:

let lessonList = document.querySelector(".lesson__list");

// Отлично! теперь нам осталось вывести его (этот элемент) в консоль.
// Как это сделать мы уже знаем, не в первый раз работаем с консолью :) -

console.log(lessonList);
// => <ul name="list" class=".lesson__list")>...</ul>

// Получилось! у нас вывелся в консоль тот самый список с классом .lesson__list,
// который мы искали, и обратите внимание - нам не выдало коллекцию из 1
// элемента. Нам выдало просто этот элемент, без всяких коллекций и т.п.
// Это (скорее всего) объясняется тем, что querySelector как раз ДОЛЖЕН возвращать
// лишь ОДИН элемент, не более. По сути он не должен возвращать несколько таких
// элементов, так зачем нам тогда коллекция? querySelectorAll задумывался как
// метод, который будет возвращать ВСЕ (all - все) элементы на странице, удо-
// влетворяющие заданному селектору. А querySelector, я повторю, возвращает
// лишь один элемент, который первым на странице удовлетворяет заданному се-
// лектору. Кстати, методом querySelectorAll также можно искать "один" элемент,
// используя квадратные скобки и индексы:

let lessonListQSA = document.querySelectorAll(".lesson__list")[0];

// Выводим в консоль полученный элемент:

console.log(lessonListQSA);
// => <ul name="list" class=".lesson__list")>...</ul>

// Опять же обратите внимание: нам выдало элемент БЕЗ коллекции! если же мы за-
// используем querySelectorAll без использования квадратных скобок и индексов,
// то нам выдаст коллекцию. На самом деле так и должно быть, ибо мы как-бы
// "ломаем" наш метод. Он должен возвращать коллекцию из нескольких элементов,
// или во всяком случае хотя-бы с одним элементом, но мы сделали так, чтобы он
// вернул нам лишь 1 такой элемент. Кстати да - вы наверняка заметили слово 
// "QSA" в названии переменной, которую я создал выше. Так вот - оно означает
// метод querySelectorAll, всё просто! А на этом всё, больше нечего говорить
// о данном методе.

// Поиск произвольного элемента: getElementById и getElementsBy

// Казалось бы, чего только мы уже не знаем - что еще нужно для счастья? но..
// Но JS и DOM не ограничиваются тем, что мы изучили, есть еще много методов,
// которые мы должны изучать и применять! поэтому, пришла пора ознакомиться
// с еще более интересными методами, которые также помогут нам в поиске конкретных
// элементов. Испольюзуются они конечно реже, потому что querySelector/all может
// с легкостью их заменить, но отличия всё же есть, поэтому нам всё таки необходимо
// их изучить. Первым таким методом будет getElementById. Если у элемента есть id
// (а из уроков по HTML мы знаем, что id это уникальный идентификатор), метод
// getElementById может его найти, где бы он не находился в документе. Здесь
// есть два отличия между querySelector/All и getElementById:

// Во первых: id уникален! т.е при поиске мы в любом случае получим 1 элемент.
// Во вторых: поиск производится только в document, т.е нам обязательно придется
// писать так: document.getElementById('element').

// В принципе, разница небольшая. Правда есть одно но - при написании id'шника
// нельзя ставить знак решетки, он тут не нужен. Пример использования метода:

// Сохраняем в переменную elem элемент с id "listItem"

let elem = document.getElementById('listItem');

// Выводим в консоль этот элемент

console.log(elem);
// => <li id="listItem" ...> ... </li>


// Отлично! метод работает, это главное. А мы движемся дальше, изучая методы поиска.
// Дальше мы изучим целый ряд методов поиска, входящих в группу getElementsBy*.
// Почему "ряд"? - всё дело в том, что методы которые мы будем изучать дальше,
// начинаются со слов getElementsBy. Причем ВСЕ методы будут так начинаться,
// это что-то вроде целого семейства таких методов (звучит, конечно, странно) :)
// Первый метод из этого "семейства" - getElementsByTagName. И на этом моменте я
// сразу же попрошу вас обратить внимание! именно getElementS, а не getElemenT.
// Если вы не поняли - буква "s" обязательна! у новичков часто бывают ошибки при
// изучении этих методов, так как они просто не замечают этой буквы или пропускают.
// Именно по этой причине, те методы, которые мы будем изучать дальше, надо рас-
// сматривать очень внимательно! еще раз повторю: не пропускайте никаких букв в
// названии методов - приведет к ошибке! А мы идем дальше.

// getElementsByTagName ищет по имени тега и возвращает ЖИВУЮ коллекцию (живая
// коллекция это та, которая отражает текущее состояние DOM). Искать он может
// как в объекте document, так и в любом другом объекте. Здесь всё точно также
// как и с предыдущими методами - различий нет. Пример использования метода:

// Ищем все теги li в объекте document, затем сохраняем в коллекцию и отправляем
// в уже существующую переменную "elems"
elems = document.getElementsByTagName('li');

// Выводим полученную коллекцию в консоль
console.log(elems);
// => HTMLCollection(7) [... (тут типа собраны все li'шки на нашей страничке)]

// Прекрасно! полученная коллекция успешно выведена в консоль.
// В этой (живой) коллекции собраны абсолютно ВСЕ элементы "li" со всей нашей
// страницы. Отлично, а мы идем дальше - к следующему методу.

// getElementsByClassName - ищет элементы по их классу и, также как и предыдущий
// метод, возвращает живую коллекцию. Различий между этими двумя методами (я про
// предыдущий и текущий) нет от слова совсем, разве что есть одно но - точку в
// названии класса мы не ставим, как это было в случае с querySelector/all. Всё
// дело в том, что уже и так понятно, что мы будем искать элементы по их классу.
// А вот и пример использования метода:

// Ищем все теги li с классом .lesson__list-item в объекте document, затем
// сохраняем в коллекцию и отправляем в уже существующую переменную elems
elems = document.getElementsByClassName('lesson__list-item');

// Выводим полученную коллекцию в консоль
console.log(elems);
// => HTMLCollection(4) [... (тут типа собраны все li'шки c определенным классом на нашей страничке)]

// Как не трудно заметить, полученная коллекция успешно выведена в консоль.
// В ней присутствуют абсолютно все элементы li с классом lesson__list-item,
// и она также живая. Идем дальше - к следующему и ПОСЛЕДНЕМУ методу из группы
// методов "getElementsBy".

// getElementsByName - ищет элементы с заданным атрибутом name и, как и два
// предыдущих метода, возвращает живую коллекцию. Используется он ну очень редко.
// Собственно, если у нас на странице элемент с атрибутом name, мы можем найти
// его по заданному значению. Повторюсь - используется он редко, но всё же его
// можно и, в некоторых ситуациях, даже нужно использовать (в каких - я и понятия
// не имею). И да - поиск происходит только внутри объекта document, больше нигде.
// А вот и пример использования этого метода:

// Ищем и сохраняем в коллекцию все те элементы, у которых есть атрибут name
// и его значения равно "list", затем отправляем коллекцию в уже существующую
// переменную elems

elems = document.getElementsByName('list');

// Выводим полученную коллекцию в консоль

console.log(elems);
// => NodeList [ul.lesson__list]

// Просто прекрасно, полученная коллекция (как и многие другие) успешно выведена
// в консоль. В ней находится всего 1 элемент, и это никак не удивительно: лишь
// у 1 элемента на странице был атрибут name, и лишь у него было значение "list",
// поэтому то в нашей коллекции, причем живой - всего лишь 1 единственный элемент.

// Кстати, в этом и есть существенное отличие этих методов поиска от ранее нами
// изученного querySelectorAll, который возвращает СТАТИЧНУЮ (не живую) коллекцию.
// Живая коллекция отличается от статичной тем, что при изменении "на лету" дерева
// DOM, она будет содержать в себе АКТУАЛЬНУЮ информацию, в то же время как метод
// querySelectorALl будет содержать информацию, на момент когда мы вызвали этот
// поиск. И сейчас мы наконец таки узнаем, в чем отличие стат. и жив. коллекций!

// Статичная VS живая коллекции: FIGHT!

// Первым делом мы должны создать себе две константы, в одной из которых будет
// хранится статичная коллекция, а у второй будет хранится "живая". Ну так чего
// же нам ждать? давайте так и сделаем:

// Получаем статичную коллекцию
const listStatic = document.querySelectorAll('.lesson__list-item');

// А теперь мы получаем живую коллекцию
const listLive = document.getElementsByClassName('lesson__list-item');

// Всё готово! первая, статичная коллекция как и положено была получена через
// QSAll, вторая же, живая коллекция была получена через getElementsByClassName.
// Внутри каждой коллекции хранятся элементы li с классом lesson__list-item.
// Теперь мы выводим эти две коллекции в консоль:

console.log(' '); // Это типа пробел
console.log(listStatic);
// => NodeList(4) [...]
console.log(listLive);
// => HTMLCollection(4) [...]

// Отлично, ну а теперь начинается самое интересное! мы будем менять наш HTML,
// а точнее DOM-дерево ЧЕРЕЗ JS! на самом деле я понятия не имею как, ведь мы
// еще не изучали методы изменения DOM-дерева, так что про это можно сказать
// так - "забежали чутка вперед" и используем метод, который заиспользовал в
// коде Жека. Первым делом мы должны сохранить в какую нибудь переменную либо
// константу сам список, класс у него также имеется - lesson__list. Но мы это
// уже делали, поэтому я для наглядности просто перезапишу уже существующую
// переменную, так будет меньше путаницы, + будем уверены что всё делаем верно:

lessonList = document.querySelector('.lesson__list');

// Идеально! а теперь применим к этой переменной тот самый (пока что) не изучен-
// ный метод:

lessonList.insertAdjacentHTML(
	"beforeend",
	'<li class="lesson__list-item"><span>Новый пункт!</span></li>'
)

// Теперь заходим в наш браузер и смотрим на нашу страницу, и ооо дааа... мы всё
// таки смогли добавить новый элемент на страницу, изменив древо DOM! но сейчас
// рано этому радоваться, считайте что мы с вами ничего не сделали и это просто
// какой-то фокус. Нам с вами сейчас необходимо "залезть" в консоль и посмотреть,
// что же там изменилось. А изменилось там НИЧЕГО, абсолютно. Но стоит нам всего
// то развернуть две наших коллекций, так разница падает сразу на глаза! в нашей
// статичной коллекции ничего не изменилось, а вот в живой коллекции появился наш
// новый элемент! вот об этом то я и говорил, когда мы разбирали последний метод
// из "семейства" getElementsBy - getElementsByName. А говорил я о том, что ста-
// тичная коллекция содержит ту информацию, которая была получена на момент ис-
// пользования этого метода, а мы создали этот элемент ПОСЛЕ его использования!


// А на этом всё :) файл стал слишком большим, создал новый файлик.