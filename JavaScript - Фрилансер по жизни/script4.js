// Метод join

// Метод join действует наоборот, он преобразовывает МАССИВ в строку, а не
// строку в массив, также с заданным разделителем.

let arr;
let arrTwo;
let obj;
let str;

arr = ["Ваня", "Иштван", "Оля",];
str = arr.join(",");

console.log( );
console.log(str);
// => "Ваня,Иштван,Оля"

// А теперь получим строку из массива:

arrTwo = ["Ваня", "Иштван", "Оля",];

console.log( );
console.log(String(arrTwo));
// => "Ваня,Иштван,Оля"

// Проверка массива: Array.isArray()

// -------------------------------------------------------

// Перед началом урока вспоминаем, что массивы - не образуют отдельный тип 
// данных, они основаны на другом типе данных. На объектах.

obj = {};
arr = [];

console.log( );
console.log(typeof obj);
// => object (как и ожидали, ничего удивительно)

console.log( );
console.log(typeof arr);
// => object (т.к массивы основываются на объектах)

// -------------------------------------------------------

// Часто бывает так, что у нас есть огромный код, а в нем куча разных объектв,
// строк, чисел и массивов. Это конечно хорошо, но как же нам узнать где массив
// а где нет? а вот для этого существует проверка Array.isArray(), которая
// нам как раз поможет. Синтаксис довольно прост: 

/*

Array.isArray(массив_на_проверку)

*/

// А теперь попрактикуемся!

if (Array.isArray(arr)) {
	console.log( );
	console.log("Это массив!");
} else {
	console.log( );
	console.log("Это не массив :(");
}

// => "Это массив!"

// Если зайти в консоль (любую, node или браузера) то мы увидим, что код отработал
// правильно, без ошибок.

// Перебор элементов

// С массивами можно сделать много чего, мы это уже поняли. Например, мы можем
// "перебрать" элементы какого нибудь массива.
// Для этого обычно используется цикл for:

arr = ["Ваня", "Иштван", "Оля"];

console.log( );
console.log(arr.length); // Узнаем длину массива
// => 3

for (let i = 0; i < arr.length; i++) {
	console.log( );
	console.log(arr[i], "- выведено при помощи простого цикла for"); // - выводим i элемент массива arr в консоль
}

// => {
/*
	"Ваня"

	"Иштван"

	"Оля"
*/
// }

// Ну вот, каждый элемент массива был выведен в консоль.
// Но мы еще можем использовать цикл FOR ... OF, он тут как раз подойдет:

for (let arrItem of arr) {
	console.log( );
	console.log(arrItem, "- а вот это выведено при помощи цикла for...of");
}

// Метод перебора forEach

// До этого мы перебирали массив при помощи циклов, но для перебора массива есть
// специальный метод - forEach.

// Он выполняет функцию для каждого элемента массива (также как и методы find
// findIndex и filter), а синтаксис у него точно такой же как и у find(Index) и
// filter'a (ну я ж говорил :D):

/*

arr.forEach(function (item, index, array) {
	// ... (делаем что-то крутое и интересное с массивом :>)
});

*/

// Попрактикуемся!

arr = ["Ваня", "Иштван", "Оля"];

arr.forEach(function(item, index, array) {
	console.log( );
	console.log(`Элемент "${item}" находится на ${index}-ой позиции в "${array}"`);
});

// => {
/*

	Элемент "Ваня" находится на 0-ой позиции в "Ваня,Иштван,Оля"

	Элемент "Иштван" находится на 1-ой позиции в "Ваня,Иштван,Оля"

	Элемент "Оля" находится на 2-ой позиции в "Ваня,Иштван,Оля"

*/
// }

// Код получился длинным, но оно того стоило - всё подробно описано, где и какой
// элемент лежит, + его позиция.
// Но мы можем написать то же самое, только при помощи стрелочных функций:

arr.forEach((item, index, array) => {
	console.log( );
	console.log(`Элемент "${item}" находится на ${index}-вой позиции в "${array}" - V2`);
});

// Также, при использовании метода forEach мы можем указывать имя некой ОТДЕЛЬНОЙ
// функции, да-да! т.е, мы создаем какую-то конкретную функцию и говорим forEach:
// "возьми и выполняй эту функцию!"

arr = ["Ваня", "Иштван", "Оля",];
arr.forEach(show);

function show(item) {
	console.log( );
	console.log(item);
};

// => "Ваня", "Иштван," "Оля" (каждый элемент на след. строке)

// Методы reduce/reduceRight

// Мы уже выяснили, что если нам нужно перебрать массив - мы можем использовать
// forEach, for или же for ... of.
// Если же нам нужно перебрать массив и вернуть данные для каждого элемента,
// то мы будем использовать map (он создает новый массив, подробнее в моем
// старом файле - script3.js).

// Методы arr.reduce и arr.reduceRight похожи на эти методы, но они сложнее
// и используются для вычисления какого нибудь единого значения на основе
// всего массива.

// Синтаксис:

let value = arr.reduce(function(previousValue, item, index, array) {
	// ... (делаем что-то крутое, что-то такое что выходит за рамки реальности, ууу..)
}, ["initial"]);

/*

К привычным нам аргументам item, index и array добавляется previousValue:

previousValue - результат предыдущего вызова этой функции, равен initial при
первом вызове (если передан initial),
item - очередной элемент массива,
index - его индекс,
array - сам массив.

P.S: initial - начальное значение, судя по всему слово initial Жека взял СПЕЦИАЛЬНО,
поскольу initial значит "начальный, первоначальный". И да - Жека слово "initial"
не закрывал в кавычки, это я так сделал т.к выдает ошибку: "initial is not defined".

Функция применяется по очереди ко всем элементам массива и "переносит" свой результат
на следующий вызов.

Лично я - ничего не понял, но будет легче разобраться на примерах!

*/

// Создаем простейший массив чисел:

arrOne = [1, 2, 3, 4,];

// Объявляем новую переменную и присваиваем ей следующее:

// Обращаемся к массиву чисел (arrOne), ставим точку и пишем "reduce", открывая
// круглые скобки и указываем функцию, и в качестве начального значения previousValue
// указываем циферку ноль. Ну а в самом теле функции мы просто возвращаем сумму текущего
// значения массива с предыдущим, с previousValue.

let reduceValueOne = arrOne.reduce(function(previousValue, item, index, array) {
	return item + previousValue;
}, 0);

// А дальше мы выводим результат работы reduce:

console.log( );
console.log(reduceValueOne);
// => 10

// Отлично, получили 10! Но как оно так получилось, что нам вернуло 10? что же
// там внутри происходит? разберем все по-этапно:

/*

Шаг №1, этап первый:

previousValue = 0 (0 указано в функции, стоит на месте initial)
item = 1 (в массиве arrOne 1 первый элемент - логично!)
Их сумма = 1 (результат работы return item + previousValue)

Шаг №2, этап второй:

previousValue = 1 (previousValue равен 1, т.к previousValue - это результат работы пред. шага, а результатом был 1)
item = 2 (в массиве arrOne 2 второй элемент - тоже логично!)
Их сумма = 3 (результат работы return item + previousValue)

Шаг №3, этап третий:

previousValue = 3 (результат пред. шага равен трём, значит previousValue тоже равен трём!)
item = 3 (тут без объяснений, логичнее логичного :D)
Их сумма = 6 (и это тоже результат работы return item + previousValue)

Шаг №4, этап четвертый:

previousValue = 6 (результат пред шага был равен шести, теперь previousValue равен шести.)
item = 4 (тоже лАгичнА)
Их сумма = 10 (конечный результат!!!)

*/

// А что будет, если не указывать нач. значение - узнаем послезавтра!