// Поиск прозивольного элемента: продолжение

// В прошлый раз мы остановились на том, что создали две переменные, которые
// хранят в себе две коллекции: живую и статичную, и мы проверили в чем же их
// разница. Последнее предложение в старом файле было таковым: "А говорил я о
// том, что статичная коллекция содержит ту информацию, которая была получена
// на момент использования этого метода, а мы создали этот элемент ПОСЛЕ его
// использования!". С этого то я и продолжу - после того как мы создали пере-
// менную со статичной коллекции, она собрала в себе все элементы с неким клас-
// сом, НО на этом всё - эта коллекция ни на какие изменения в DOM реагировать
// никак не будет. Живая коллекция наоборот, всегда содержит в себе только
// самую "свежую" информацию. А мы идем дальше!

// querySelectorAll VS другие методы

// На практике, чаще всего используется querySelectorAll, так как мы в него
// можем указать абсолютно любой CSS-селектор. Другие методы поиска юзаются (то
// есть используются) только тогда, когда нам нужны их уникальные возможности,
// например получение одного объекта, или получение живой коллекции. И Жека
// специально для нас составил табличку элементов, где показано, что умеет и
// что делает каждый изученный нами метод поиска. Я же взял и перенес её сюда:


/*

Метод поиска           | Ищет по...           | Возвращает...       |  Ищет внутри элемента/Живая коллекция?
------------------------------------------------------------------------------------------------------------
QuerySelector          | Любому CSS-селектору | Один объект         |   Да - Нет (статичная)
------------------------------------------------------------------------------------------------------------
QuerySelectorAll       | Любому CSS-селектору | Коллекция объектов  |   Да - Нет (статичная)
------------------------------------------------------------------------------------------------------------
getElementById         | ID   				  | Один объект     	|   Нет - Нет (статичная)
------------------------------------------------------------------------------------------------------------
getElementsByTagName   | Тегу или *  		  | Коллекцию объектов  |   Да - Да
------------------------------------------------------------------------------------------------------------
getElementsByClassName | Имени класса		  | Коллекцию объектов  |   Да - Да
------------------------------------------------------------------------------------------------------------
getElementsByName      | Атрибуту name  	  | Коллекцию объектов  |   Нет - Да
------------------------------------------------------------------------------------------------------------

*/

// Ух.. во это я заморочился конечно! на этой таблице представлены все изучен-
// ные нами методы, а также то что они возвращают. Кроме того, на ней показано,
// ищут ли они внутри каких-либо элементов или нет, а еще то, какую коллекцию
// они возвращают (живую или же статичную).

// Метод поиска closest

// Рассмотрим еще один метод поиска - closest! этот метод ищет ближайшего предка,
// который соответствует указанному CSS - селектору. Причем сам элемент также
// включается в поиск, принмимает в нем участие. А я напомню, что предки элемента
// это родитель, родитель родителя, его родитель и так далее. Вместе они образуют
// некое дерево, некую цепочку иерархии от элемента до вершины. Другими словами,
// метод closest поднимается вверх по этому дереву, пока не найдет родителя, кото-
// рый соответствует CSS - селектору. Метод возвращает либо найденного родителя,
// либо null, если такой элемент не найден.

// И еще одно напоминание: parentElement возвращает НЕПОСРЕДСТВЕННОГО родителя
// элемента, в то время как closest ищет поднимаясь вверх по иерархии.
// А теперь пример использования:

let elem = document.querySelector('.lesson__sub-list-item');
let parentList = elem.closest('.lesson__list');
console.log(parentList);

// Первым делом мы получаем в переменную первый (так как qS возвращает именно
// первый элемент, который соот. указ. селектору) элемент под-списка, затем мы
// сохраняем в переменную элемент ".lesson__list" через метод closest, и в конце
// выводим его в консоль. Всё получилось! но осталось добавить, что метод closest
// очень и очень полезен, и он часто испольуется для проверки на существование
// того или иного родителя, либо для изменения родителя конкретного элемента.

// Метод проверки matches

// Сейчас мы изучим следующий метод поиска - matches. На самом деле это даже не
// метод поиска - это метод проверки. Он скорее проверяет, удовлетворяет ли эле-
// мент CSS - селектору и возвращает true или false в зависимости от результата.
// На примере будет намного легче понять, как он работает! -

let elems = document.querySelectorAll('.lesson__list-item');

for (let elem of elems) {
	if (elem.matches('[class$="lesson__list-item_red"]')) {
		console.log("Красный")
	} else if (elem.matches('[class$="lesson__list-item_blue"]')) {
		console.log("Синий")
	}
}

// Готово! теперь объясняю: сначала мы получаем коллекцию ВСЕХ элементов с клас-
// сом .lesson__list-item в переменную elems, далее с помощью цикла for ... of
// мы перебираем найденные коллекции и при помощи условного ветвления проверяем,
// используя matches, есть ли у элемента атрибут class с таким-то классом и спец.
// модификатором (см. методология БЭМ) red. Если есть - выводим в консоль слово
// "Красный", если же ничего не нашлось, то мы при помощи else if и matches ищем
// элемент с атрибутом class с таким-то классом и спец. модификатором blue. Если
// он есть, выводим в консоль слово "Синий". Всё просто! то есть мы через цикл
// for ... of буквально перебираем (как документики) элементы с таким-то классом,
// а дальше мы ищем те элементы, у которых есть класс с опред. модификатором, и в
// зависимости от полученного бул. значения выводим в консоль какое-то слово.

// Осталось еще добавить, что получив объект тем или иным способом, мы можем
// применять свойства навигации о которых говорили ранее. Например - то самое
// свойство nextElementSibling:

let text = document.querySelector('.lesson__text');
let list = text.nextElementSibling;
console.log(list);
// => <ul name="list" class="lesson__list">...</ul>

// Думаю, объяснять, что и где произошло - излишество. Не так ли? :)
// Вкратце - мы получили в переменную text некий элемент по селектору класса,
// а класс у него "lesson__text". Впрочем, оно и не важно - далее мы получаем
// в уже другую переменную list СЛЕДУЮЩИЙ элемент, то есть соседний по отноше-
// нию к "lesson__text". В нашем случае это список с классом "lesson_list", и
// именно его мы и получили в переменную и затем вывели его (элемент) в консоль.
// Это доказывает тот факт, что мы можем применять все, любые свойства навигации
// к элементам, найденным с помощью методов поиска!

// Изменение документа

// Отлично, мы научились передвигаться по дереву DOM, даже находить и получать
// произвольные объекты, НО всё это работает только "для чтения"! а мы же хотим
// не только получать то, что уже есть, но и изменять а также создавать свой
// собственный HTML-код прямо из JS! в этом нам помогут следующие СПЕЦИАЛЬНЫЕ
// методы, как раз таки созданные для этих целей (разве не круто?):
// A.S: у меня в этот момент аж дрожь по телу пробежала от волнения :D

// Содержимое элемента innerHTML

// И так, начнем с получения и изменения СОДЕРЖИМОГО элемента с помощью свойства
// innerHTML. Узнать про то, как он работает, мы можем на практике:

// Первым делом мы получаем объект
let textElement = document.querySelector('.lesson__text');

// А затем получаем содержимое объекта "как есть" вместе с HTML
let textElementContent = textElement.innerHTML;
console.log(textElementContent);
// => "Текст, причем очень важный текст - текстище!"

// Сразу приступаю к объяснению: получаем в переменную textElement некий объект
// с классом "lesson__text", в нем также есть некое содержимое. Дальше, в перем.
// textElementContent мы получаем СОДЕРЖИМОЕ этого объекта следующим образом:
// первым делом мы прописываем название той переменной, которая содержит в себе
// объект с классом "lesson__text", у нас эта перем. называется textElement. А
// дальше мы ставим точку и прописываем свойство innerHTML. Таким образом мы по-
// -лучим содержимое КАК ЕСТЬ, вместе с HTML-тегами (если они там содержатся), а
// дальше мы просто выводим полученную перем. в консоль, всё максимально просто.
// Это всё конечно хорошо, но мы ОПЯТЬ что-то получаем и не изменяем ничего! так
// вот - сейчас мы это исправим!

textElement.innerHTML = 'Ладно, сейчас это не такой уж и <span class="yellow">важный</span> текст.'

// Что мы сделали? при помощи свойства innerHTML мы просто-напросто изменили
// содержимое нашего элемента, что находится в переменной "textElement". Чтобы
// проверить, действительно ли что-то поменялось на странице или нет, достаточно
// просто перезагрузить её - изменения на лицо! но следует отметить, что перем.
// textElementContent своё "оригинальное" содержимое НЕ изменила (возможно это
// потому, что qS возвращает СТАТИЧНУЮ коллекцию). Это позволяет нам не полностью 
// изменять содержимое, а "дописывать" новое.
// P.S: я всё изменю "на обратно", ибо мне.. не очень хочется, чтобы когда я
// через несколько дней зашел на эту страницу, бросалась в глаза эта фраза и я
// бы сидел и думал "а что было до неё?" :)

textElement.innerHTML = 'Текст, причем очень важный текст - <span class="yellow">текстище!</span>'

// Итак.. сейчас я покажу вам, что значит "дописывать" новое содержимое...

// Но не сегодня, а... позже!)