// Поиск прозивольного элемента: продолжение

// В прошлый раз мы остановились на том, что создали две переменные, которые
// хранят в себе две коллекции: живую и статичную, и мы проверили в чем же их
// разница. Последнее предложение в старом файле было таковым: "А говорил я о
// том, что статичная коллекция содержит ту информацию, которая была получена
// на момент использования этого метода, а мы создали этот элемент ПОСЛЕ его
// использования!". С этого то я и продолжу - после того как мы создали пере-
// менную со статичной коллекции, она собрала в себе все элементы с неким клас-
// сом, НО на этом всё - эта коллекция ни на какие изменения в DOM реагировать
// никак не будет. Живая коллекция наоборот, всегда содержит в себе только
// самую "свежую" информацию. А мы идем дальше!

// querySelectorAll VS другие методы

// На практике, чаще всего используется querySelectorAll, так как мы в него
// можем указать абсолютно любой CSS-селектор. Другие методы поиска юзаются (то
// есть используются) только тогда, когда нам нужны их уникальные возможности,
// например получение одного объекта, или получение живой коллекции. И Жека
// специально для нас составил табличку элементов, где показано, что умеет и
// что делает каждый изученный нами метод поиска. Я же взял и перенес её сюда:


/*

Метод поиска           | Ищет по...           | Возвращает...       |  Ищет внутри элемента/Живая коллекция?
------------------------------------------------------------------------------------------------------------
QuerySelector          | Любому CSS-селектору | Один объект         |   Да - Нет (статичная)
------------------------------------------------------------------------------------------------------------
QuerySelectorAll       | Любому CSS-селектору | Коллекция объектов  |   Да - Нет (статичная)
------------------------------------------------------------------------------------------------------------
getElementById         | ID   				  | Один объект     	|   Нет - Нет (статичная)
------------------------------------------------------------------------------------------------------------
getElementsByTagName   | Тегу или *  		  | Коллекцию объектов  |   Да - Да
------------------------------------------------------------------------------------------------------------
getElementsByClassName | Имени класса		  | Коллекцию объектов  |   Да - Да
------------------------------------------------------------------------------------------------------------
getElementsByName      | Атрибуту name  	  | Коллекцию объектов  |   Нет - Да
------------------------------------------------------------------------------------------------------------

*/

// Ух.. во это я заморочился конечно! на этой таблице представлены все изучен-
// ные нами методы, а также то что они возвращают. Кроме того, на ней показано,
// ищут ли они внутри каких-либо элементов или нет, а еще то, какую коллекцию
// они возвращают (живую или же статичную).

// Метод поиска closest

// Рассмотрим еще один метод поиска - closest! этот метод ищет ближайшего предка,
// который соответствует указанному CSS - селектору. Причем сам элемент также
// включается в поиск, принмимает в нем участие. А я напомню, что предки элемента
// это родитель, родитель родителя, его родитель и так далее. Вместе они образуют
// некое дерево, некую цепочку иерархии от элемента до вершины. Другими словами,
// метод closest поднимается вверх по этому дереву, пока не найдет родителя, кото-
// рый соответствует CSS - селектору. Метод возвращает либо найденного родителя,
// либо null, если такой элемент не найден.

// И еще одно напоминание: parentElement возвращает НЕПОСРЕДСТВЕННОГО родителя
// элемента, в то время как closest ищет поднимаясь вверх по иерархии.
// А теперь пример использования:

let elem = document.querySelector('.lesson__sub-list-item');
let parentList = elem.closest('.lesson__list');
console.log(parentList);

// Первым делом мы получаем в переменную первый (так как qS возвращает именно
// первый элемент, который соот. указ. селектору) элемент под-списка, затем мы
// сохраняем в переменную элемент ".lesson__list" через метод closest, и в конце
// выводим его в консоль. Всё получилось! но осталось добавить, что метод closest
// очень и очень полезен, и он часто испольуется для проверки на существование
// того или иного родителя, либо для изменения родителя конкретного элемента.

// Метод проверки matches

// Сейчас мы изучим следующий метод поиска - matches. На самом деле это даже не
// метод поиска - это метод проверки. Он скорее проверяет, удовлетворяет ли эле-
// мент CSS - селектору и возвращает true или false в зависимости от результата.
// На примере будет намного легче понять, как он работает! -

let elems = document.querySelectorAll('.lesson__list-item');

for (let elem of elems) {
	if (elem.matches('[class$="lesson__list-item_red"]')) {
		console.log("Красный")
	} else if (elem.matches('[class$="lesson__list-item_blue"]')) {
		console.log("Синий")
	}
}

// Готово! теперь объясняю: сначала мы получаем коллекцию ВСЕХ элементов с клас-
// сом .lesson__list-item в переменную elems, далее с помощью цикла for ... of
// мы перебираем найденные коллекции и при помощи условного ветвления проверяем,
// используя matches, есть ли у элемента атрибут class с таким-то классом и спец.
// модификатором (см. методология БЭМ) red. Если есть - выводим в консоль слово
// "Красный", если же ничего не нашлось, то мы при помощи else if и matches ищем
// элемент с атрибутом class с таким-то классом и спец. модификатором blue. Если
// он есть, выводим в консоль слово "Синий". Всё просто! то есть мы через цикл
// for ... of буквально перебираем (как документики) элементы с таким-то классом,
// а дальше мы ищем те элементы, у которых есть класс с опред. модификатором, и в
// зависимости от полученного бул. значения выводим в консоль какое-то слово.

// Осталось еще добавить, что получив объект тем или иным способом, мы можем
// применять свойства навигации о которых говорили ранее. Например - то самое
// свойство nextElementSibling:

let text = document.querySelector('.lesson__text');
let list = text.nextElementSibling;
console.log(list);
// => <ul name="list" class="lesson__list">...</ul>

// Думаю, объяснять, что и где произошло - излишество. Не так ли? :)
// Вкратце - мы получили в переменную text некий элемент по селектору класса,
// а класс у него "lesson__text". Впрочем, оно и не важно - далее мы получаем
// в уже другую переменную list СЛЕДУЮЩИЙ элемент, то есть соседний по отноше-
// нию к "lesson__text". В нашем случае это список с классом "lesson_list", и
// именно его мы и получили в переменную и затем вывели его (элемент) в консоль.
// Это доказывает тот факт, что мы можем применять все, любые свойства навигации
// к элементам, найденным с помощью методов поиска!

// Изменение документа

// Отлично, мы научились передвигаться по дереву DOM, даже находить и получать
// произвольные объекты, НО всё это работает только "для чтения"! а мы же хотим
// не только получать то, что уже есть, но и изменять а также создавать свой
// собственный HTML-код прямо из JS! в этом нам помогут следующие СПЕЦИАЛЬНЫЕ
// методы, как раз таки созданные для этих целей (разве не круто?):
// A.S: у меня в этот момент аж дрожь по телу пробежала от волнения :D

// Изменение документа: содержимое элемента - innerHTML

// И так, начнем с получения и изменения СОДЕРЖИМОГО элемента с помощью свойства
// innerHTML. Узнать про то, как он работает, мы можем на практике:

// Первым делом мы получаем объект
let textElement = document.querySelector('.lesson__text');

// А затем получаем содержимое объекта "как есть" вместе с HTML
let textElementContent = textElement.innerHTML;
console.log(textElementContent, "- контент, содержащийся в объекте 'lesson__text'");
// => "Текст, причем очень важный текст - текстище!"

// Сразу приступаю к объяснению: получаем в переменную textElement некий объект
// с классом "lesson__text", в нем также есть некое содержимое. Дальше, в перем.
// textElementContent мы получаем СОДЕРЖИМОЕ этого объекта следующим образом:
// первым делом мы прописываем название той переменной, которая содержит в себе
// объект с классом "lesson__text", у нас эта перем. называется textElement. А
// дальше мы ставим точку и прописываем свойство innerHTML. Таким образом мы по-
// -лучим содержимое КАК ЕСТЬ, вместе с HTML-тегами (если они там содержатся), а
// дальше мы просто выводим полученную перем. в консоль, всё максимально просто.
// Это всё конечно хорошо, но мы ОПЯТЬ что-то получаем и не изменяем ничего! так
// вот - сейчас мы это исправим!

textElement.innerHTML = 'Ладно, сейчас это не такой уж и <span class="yellow">важный</span> текст.'

// Что мы сделали? при помощи свойства innerHTML мы просто-напросто изменили
// содержимое нашего элемента, что находится в переменной "textElement". Чтобы
// проверить, действительно ли что-то поменялось на странице или нет, достаточно
// просто перезагрузить её - изменения на лицо! но следует отметить, что перем.
// textElementContent своё "оригинальное" содержимое НЕ изменила (возможно это
// потому, что qS возвращает СТАТИЧНУЮ коллекцию). Это позволяет нам не полностью 
// изменять содержимое, а "дописывать" новое.

// "Дописывать содержимое" значит добавлять какой-то контент к уже имеющемуся.
// Сделать это можно при помощи обратных кавычек, например:

textElement.innerHTML =
	`${textElementContent} <p>Но кто знает, может быть этот текст
	уже и не такой уж и <span class="yellow">важный</span>?</p>`;

console.log(textElement.innerHTML, "- результат после добавления контента (на странице его нет)")

// Сейчас мы именно ДОБАВИЛИ контент, а не изменили его полностью. Мы сделали
// так, чтобы у textElement вернулся его изначальный контент (делается это ещё
// в самом начале: `${textElementContent} ...`), а затем добавили параграф и
// внутри него некий текст. А всё благодаря тому, что мы ещё до всего этого
// сохранили в переменную textElementContent дефолтную, изначальную информацию.
// Далее мы выводим в консоль текущий контент элемента и сверяем его с преды-
// -дущим - разница есть, хоть и не совсем огромная. И становится понятно, что
// с JavaScript'ом у нас открываются ОГРОМНЫЕ возможности для манипуляций со
// страничкой, ведь то, что мы сделали - лишь капля в море. Идем дальше!

// Изменение документа: outerHTML

// Метод outerHTML получает элемент ЦЕЛИКОМ. Отличия от innerHTML небольшие, я
// бы даже сказал что их и нету: кроме получения содержимого объекта, мы полу-
// -чаем и САМ объект. Легче понять на примере:

// P.S - , но я сразу вам скажу: все манипуляции с outerHTML я закомментировал,
// так как после того, как мы меняем страницу через outerHTML верунть всё обратно
// НЕВОЗМОЖНО, или это только я не смог всё вернуть. В любом случае - если захо-
// -тите, то уберете комментарии, но потом обязательно закомментируйте обратно,
// иначе будет/может произойти путаница.
// P.S.S - я всё таки решил убрать тот добавленный контент :D

// Возвращаем прежний вид страницы, убрав добавленный контент
textElement.innerHTML = textElementContent;

// Получаем содержимое объекта "как есть" вместе с HTML, а также сам элемент
// textElementContent = textElement.outerHTML;
// console.log(textElementContent);
// => <div class="lesson__text">...</div>

// На этот раз в консоль мы получили САМ элемент, включая его содержимое - это
// div с классом "lesson__text", а внутри него текст со span'ом. А здесь уже
// разница на глаз - если через innerHTML мы получали лишь "внутренности" этого
// объекта, то с outerHTML мы получаем уже сам объект, его "оболочку". Но и на
// этом интересности не кончаются - есть еще одна очень интересная особенность!
// Давайте попробуем изменить документ через outerHTML:

// textElement.outerHTML = `<p>Эх... этот текст уже не <span class="yellow">важный</span> :(</p>`;

// Мы обратились к элементу, написали .outerHTML и записали туда абсолютно новый
// объект, вместо div'а с классом "lesson__text". В результате мы получили уже
// полностью измененный документ, хоть и в файле "index.html" ничего не изме-
// -нилось. Однако, разницу можно увидеть через DTools - мы увидим, что на стра-
// -нице ИСЧЕЗ этот div и его заменил тег p. Но что если мы захотим получить
// outerHTML данного объекта?

// console.log(textElement.outerHTML);
// => <div class="lesson__text">...</div>

// В таком случае мы получим старую, оригинальную запись. Ну, идем дальше!

// Изменение документа: просто текст элемента - textContent

// Следующие свойство для изменения документа называется просто, его название по-
// -хоже на название одной из наших переменных - textContent. Это свойство по-
// -хоже на предыдущие, но имеет одно принципиальное отличие. Рассмотрим на при-
// -мере, так будет легче:

let textElement2 = document.querySelector(".lesson__text");
let textElementContent2 = textElement2.textContent;
console.log(textElementContent);
// => "Текст, причем очень важный текст - текстище!"

// Здесь ничего интересного: создаем переменную textElement, присваиваем её в
// качестве значения элемент с классом "lesson__text", далее создаём переменную
// textElementContent2 и даем ей след. значение: "текстовый контент элемента,
// который находится в переменной textElement2". То есть этой переменной мы за-
// -дали самый обычный текстовый контент в качестве значения, а далее мы вывели
// его в консоль, там нам выдало простейший текст, без тегов. Но почему без те-
// -гов? ответ очень прост - это свойство показывает нам исключительно ТЕКСТОВЫЙ
// контент, но его особенность в другом - с ним нельзя добавлять HTML-код на
// страницу:

textElement2.textContent = `Ладно, сейчас это не такой уж и <span class="yellow">важный</span> текст.`;

console.log(textElement2.textContent);
// => "Ладно, сейчас это не такой уж и <span class="yellow">важный</span> текст."

// Как не трудно заметить, все теги преобразовались в простую строку, а не в
// какой нибудь HTML-код. Это и есть основная особенность этого свойства - с ним
// мы можем получить текст или просто его изменить, но HTML с его помощью нам
// не добавить. Это полезная возможность textContent'а  - записывать текст "безо-
// -пасным способом", если мы не хотим чтобы на сайте появился произвольный какой
// нибудь HTML-код. textContent - один из способов защититься от этого.

// Изменение документа: data

// В случае, если мы хотим поработать не с элементом (HTML-тегом), а с неким
// другим узлом - текстовым либо комментарием, мы можем воспользоваться свойст-
// -вом data. Он возвращает или содержимое текстового узла либо комментарий.
// Посмотрим на него в примере и вернем вид страницы на прежний:

// Возвращаю прежний вид страницы
textElement.innerHTML = textElementContent;

let textElement3 = document.querySelector('.lesson__text');
let getComment = textElement.nextSibling;
console.log(getComment);
// => <!-- А я комментарий, а мне норм :D -->

// В примере выше мы создали переменную textElement3 и сохранили в неё элемент
// с классом "lesson__text", далее мы создали переменную getComment и сохранили
// в неё следующий узел, который идет после элемента с классом "Lesson__text".
// Выведя в консоль этот узел мы видим, что это простой комментарий, идущий
// сразу после закрывающего div'а, который относится к элементу "lesson__text",
// то есть очень важно, чтобы после него ничего не стояло - ни текста, ни пробела
// или еще чего нибудь такого, что могло бы сохраниться в переменную вместо этого
// комментария. Ведь мы помним, что enter это ТОЖЕ узел и текст это ТОЖЕ узел.
// Так вот, чтобы получить сам ТЕКСТ комментария, то есть его содержимое, нам
// необходимо просто использовать свойство data:

console.log(getComment.data);
// => "А я комментарий, а мне норм :D"

// Смотрим в консоль - текст комментария, всё получилось! но это еще не всё...
// Мы можем ИЗМЕНИТЬ наш комментарий или любой другой текстовый узел! -

getComment.data = "Я как бы комментарий, но мне уже не норм..."
console.log(getComment.data);
// => "Я как бы комментарий, но мне уже не норм..."

// Здесь ничего разжевывать не нужно - берем узел, что находится внутри перем.
// getComment, ставим точку и прописываем свойство, пишем оператор присваивания
// и через пробел новую строку. Далее выводим результат в консоль и видим, что
// текст комментария изменился! а чтобы в этом полностью убедиться, достаточно
// посмотреть на комментарий через DTools - там комментарий также изменился.
// А теперь переходим к самому интересному!

// Изменение документа: создание элементов и узлов

// Наконец-то, спустя столько времени мы научимся создавать элементы и узлы в
// самом JS-файле! сделать это можно одним из нескольких методов, один из которых
// это метод createElement. Посмотрим на него сразу же в примере:

let newElement = document.createElement('div');
console.log(newElement);
// => <div></div>

// Итак, первым делом мы создаем переменную newElement и ставлю знак равно, т.е
// оператора присваивания. Далее я пишу слово document, ставлю точку и прописываю
// название метода, затем ставлю круглые скобки и уже внутри них я пишу название
// того тега, который хочу создать - в нашем случае это простейший div. Ну а в
// конце я просто вывожу его в консоль и вижу.. ВИЖУ, ЧТО У НАС РОДИЛСЯ НОВЫЙ
// ЭЛЕМЕНТ - DIV! отлично, а теперь наполним этот новорожденный div контентом,
// сделаем мы это через уже знакомое нам свойство innerHTML:

newElement.innerHTML = `Это тоже очень <span class="yellow">важный</span> текст!`;
console.log(newElement);
// => <div>...</div>

// Ну вот, теперь наш div наполнен своим собственным контентом! круто, не так ли?
// А теперь мы создадим новый текстовый УЗЕЛ! для этого мы используем метод
// createTextNode, который создает текстовые узлы. В круглых скобках необходимо
// передавать исключительно ТЕКСТ (логично, да?):

let newTextNode = document.createTextNode("Допустим, что это текст :]");
console.log(newTextNode);
// => "Допустим, что это текст :]"

// Ну вот, текствый узел тоже был создан! то есть, как вы (читатель) поняли,
// создавать элементы и узлы таким образом просто, но есть один нюанс..

// Какой? - узнаем позже!