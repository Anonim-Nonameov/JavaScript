// Поиск прозивольного элемента: продолжение

// В прошлый раз мы остановились на том, что создали две переменные, которые
// хранят в себе две коллекции: живую и статичную, и мы проверили в чем же их
// разница. Последнее предложение в старом файле было таковым: "А говорил я о
// том, что статичная коллекция содержит ту информацию, которая была получена
// на момент использования этого метода, а мы создали этот элемент ПОСЛЕ его
// использования!". С этого то я и продолжу - после того как мы создали пере-
// менную со статичной коллекции, она собрала в себе все элементы с неким клас-
// сом, НО на этом всё - эта коллекция ни на какие изменения в DOM реагировать
// никак не будет. Живая коллекция наоборот, всегда содержит в себе только
// самую "свежую" информацию. А мы идем дальше!

// querySelectorAll VS другие методы

// На практике, чаще всего используется querySelectorAll, так как мы в него
// можем указать абсолютно любой CSS-селектор. Другие методы поиска юзаются (то
// есть используются) только тогда, когда нам нужны их уникальные возможности,
// например получение одного объекта, или получение живой коллекции. И Жека
// специально для нас составил табличку элементов, где показано, что умеет и
// что делает каждый изученный нами метод поиска. Я же взял и перенес её сюда:


/*

Метод поиска           | Ищет по...           | Возвращает...       |  Ищет внутри элемента/Живая коллекция?
------------------------------------------------------------------------------------------------------------
QuerySelector          | Любому CSS-селектору | Один объект         |   Да - Нет (статичная)
------------------------------------------------------------------------------------------------------------
QuerySelectorAll       | Любому CSS-селектору | Коллекция объектов  |   Да - Нет (статичная)
------------------------------------------------------------------------------------------------------------
getElementById         | ID   				  | Один объект     	|   Нет - Нет (статичная)
------------------------------------------------------------------------------------------------------------
getElementsByTagName   | Тегу или *  		  | Коллекцию объектов  |   Да - Да
------------------------------------------------------------------------------------------------------------
getElementsByClassName | Имени класса		  | Коллекцию объектов  |   Да - Да
------------------------------------------------------------------------------------------------------------
getElementsByName      | Атрибуту name  	  | Коллекцию объектов  |   Нет - Да
------------------------------------------------------------------------------------------------------------

*/

// Ух.. во это я заморочился конечно! на этой таблице представлены все изучен-
// ные нами методы, а также то что они возвращают. Кроме того, на ней показано,
// ищут ли они внутри каких-либо элементов или нет, а еще то, какую коллекцию
// они возвращают (живую или же статичную).

// Метод поиска closest

// Рассмотрим еще один метод поиска - closest! этот метод ищет ближайшего предка,
// который соответствует указанному CSS - селектору. Причем сам элемент также
// включается в поиск, принмимает в нем участие. А я напомню, что предки элемента
// это родитель, родитель родителя, его родитель и так далее. Вместе они образуют
// некое дерево, некую цепочку иерархии от элемента до вершины. Другими словами,
// метод closest поднимается вверх по этому дереву, пока не найдет родителя, кото-
// рый соответствует CSS - селектору. Метод возвращает либо найденного родителя,
// либо null, если такой элемент не найден.

// И еще одно напоминание: parentElement возвращает НЕПОСРЕДСТВЕННОГО родителя
// элемента, в то время как closest ищет поднимаясь вверх по иерархии.
// А теперь пример использования:

let elem = document.querySelector('.lesson__sub-list-item');
let parentList = elem.closest('.lesson__list');
console.log(parentList);

// Первым делом мы получаем в переменную первый (так как qS возвращает именно
// первый элемент, который соот. указ. селектору) элемент под-списка, затем мы
// сохраняем в переменную элемент ".lesson__list" через метод closest, и в конце
// выводим его в консоль. Всё получилось! но осталось добавить, что метод closest
// очень и очень полезен, и он часто испольуется для проверки на существование
// того или иного родителя, либо для изменения родителя конкретного элемента.

// Метод проверки matches

// Сейчас мы изучим следующий метод поиска - matches. На самом деле это даже не
// метод поиска - это метод проверки. Он скорее проверяет, удовлетворяет ли эле-
// мент CSS - селектору и возвращает true или false в зависимости от результата.
// На примере будет намного легче понять, как он работает! -

let elems = document.querySelectorAll('.lesson__list-item');

for (let elem of elems) {
	if (elem.matches('[class$="lesson__list-item_red"]')) {
		console.log("Красный")
	} else if (elem.matches('[class$="lesson__list-item_blue"]')) {
		console.log("Синий")
	}
}

// Готово! теперь объясняю: сначала мы получаем коллекцию ВСЕХ элементов с клас-
// сом .lesson__list-item в переменную elems, далее с помощью цикла for ... of
// мы перебираем найденные коллекции и при помощи условного ветвления проверяем,
// используя matches, есть ли у элемента атрибут class с таким-то классом и спец.
// модификатором (см. методология БЭМ) red. Если есть - выводим в консоль слово
// "Красный", если же ничего не нашлось, то мы при помощи else if и matches ищем
// элемент с атрибутом class с таким-то классом и спец. модификатором blue. Если
// он есть, выводим в консоль слово "Синий". Всё просто! то есть мы через цикл
// for ... of буквально перебираем (как документики) элементы с таким-то классом,
// а дальше мы ищем те элементы, у которых есть класс с опред. модификатором, и в
// зависимости от полученного бул. значения выводим в консоль какое-то слово.

// Осталось еще добавить, что получив объект тем или иным способом, мы можем
// применять свойства навигации о которых говорили ранее. Например - то самое
// свойство nextElementSibling:

let text = document.querySelector('.lesson__text');
let list = text.nextElementSibling;
console.log(list);
// => <ul name="list" class="lesson__list">...</ul>

// Думаю, объяснять, что и где произошло - излишество. Не так ли? :)

// А на этом пока что всё. Остальное - позже, главное дождитесь :)