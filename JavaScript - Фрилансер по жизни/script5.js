// Поиск прозивольного элемента: продолжение

// В прошлый раз мы остановились на том, что создали две переменные, которые
// хранят в себе две коллекции: живую и статичную, и мы проверили в чем же их
// разница. Последнее предложение в старом файле было таковым: "А говорил я о
// том, что статичная коллекция содержит ту информацию, которая была получена
// на момент использования этого метода, а мы создали этот элемент ПОСЛЕ его
// использования!". С этого то я и продолжу - после того как мы создали пере-
// менную со статичной коллекции, она собрала в себе все элементы с неким клас-
// сом, НО на этом всё - эта коллекция ни на какие изменения в DOM реагировать
// никак не будет. Живая коллекция наоборот, всегда содержит в себе только
// самую "свежую" информацию. А мы идем дальше!

// querySelectorAll VS другие методы

// На практике, чаще всего используется querySelectorAll, так как мы в него
// можем указать абсолютно любой CSS-селектор. Другие методы поиска юзаются (то
// есть используются) только тогда, когда нам нужны их уникальные возможности,
// например получение одного объекта, или получение живой коллекции. И Жека
// специально для нас составил табличку элементов, где показано, что умеет и
// что делает каждый изученный нами метод поиска. Я же взял и перенес её сюда:


/*

Метод поиска           | Ищет по...           | Возвращает...       |  Ищет внутри элемента/Живая коллекция?
------------------------------------------------------------------------------------------------------------
QuerySelector          | Любому CSS-селектору | Один объект         |   Да - Нет (статичная)
------------------------------------------------------------------------------------------------------------
QuerySelectorAll       | Любому CSS-селектору | Коллекция объектов  |   Да - Нет (статичная)
------------------------------------------------------------------------------------------------------------
getElementById         | ID   				  | Один объект     	|   Нет - Нет (статичная)
------------------------------------------------------------------------------------------------------------
getElementsByTagName   | Тегу или *  		  | Коллекцию объектов  |   Да - Да
------------------------------------------------------------------------------------------------------------
getElementsByClassName | Имени класса		  | Коллекцию объектов  |   Да - Да
------------------------------------------------------------------------------------------------------------
getElementsByName      | Атрибуту name  	  | Коллекцию объектов  |   Нет - Да
------------------------------------------------------------------------------------------------------------

*/

// Ух.. во это я заморочился конечно! на этой таблице представлены все изучен-
// ные нами методы, а также то что они возвращают. Кроме того, на ней показано,
// ищут ли они внутри каких-либо элементов или нет, а еще то, какую коллекцию
// они возвращают (живую или же статичную).

// Метод поиска closest

// Рассмотрим еще один метод поиска - closest! этот метод ищет ближайшего предка,
// который соответствует указанному CSS - селектору. Причем сам элемент также
// включается в поиск, принмимает в нем участие. А я напомню, что предки элемента
// это родитель, родитель родителя, его родитель и так далее. Вместе они образуют
// некое дерево, некую цепочку иерархии от элемента до вершины. Другими словами,
// метод closest поднимается вверх по этому дереву, пока не найдет родителя, кото-
// рый соответствует CSS - селектору. Метод возвращает либо найденного родителя,
// либо null, если такой элемент не найден.

// И еще одно напоминание: parentElement возвращает НЕПОСРЕДСТВЕННОГО родителя
// элемента, в то время как closest ищет поднимаясь вверх по иерархии.
// А теперь пример использования:

let elem = document.querySelector('.lesson__sub-list-item');
let parentList = elem.closest('.lesson__list');
console.log(parentList);

// Первым делом мы получаем в переменную первый (так как qS возвращает именно
// первый элемент, который соот. указ. селектору) элемент под-списка, затем мы
// сохраняем в переменную элемент ".lesson__list" через метод closest, и в конце
// выводим его в консоль. Всё получилось! но осталось добавить, что метод closest
// очень и очень полезен, и он часто испольуется для проверки на существование
// того или иного родителя, либо для изменения родителя конкретного элемента.

// Метод проверки matches

// Сейчас мы изучим следующий метод поиска - matches. На самом деле это даже не
// метод поиска - это метод проверки. Он скорее проверяет, удовлетворяет ли эле-
// мент CSS - селектору и возвращает true или false в зависимости от результата.
// На примере будет намного легче понять, как он работает! -

let elems = document.querySelectorAll('.lesson__list-item');

for (let elem of elems) {
	if (elem.matches('[class$="lesson__list-item_red"]')) {
		console.log("Красный")
	} else if (elem.matches('[class$="lesson__list-item_blue"]')) {
		console.log("Синий")
	}
}

// Готово! теперь объясняю: сначала мы получаем коллекцию ВСЕХ элементов с клас-
// сом .lesson__list-item в переменную elems, далее с помощью цикла for ... of
// мы перебираем найденные коллекции и при помощи условного ветвления проверяем,
// используя matches, есть ли у элемента атрибут class с таким-то классом и спец.
// модификатором (см. методология БЭМ) red. Если есть - выводим в консоль слово
// "Красный", если же ничего не нашлось, то мы при помощи else if и matches ищем
// элемент с атрибутом class с таким-то классом и спец. модификатором blue. Если
// он есть, выводим в консоль слово "Синий". Всё просто! то есть мы через цикл
// for ... of буквально перебираем (как документики) элементы с таким-то классом,
// а дальше мы ищем те элементы, у которых есть класс с опред. модификатором, и в
// зависимости от полученного бул. значения выводим в консоль какое-то слово.

// Осталось еще добавить, что получив объект тем или иным способом, мы можем
// применять свойства навигации о которых говорили ранее. Например - то самое
// свойство nextElementSibling:

let text = document.querySelector('.lesson__text');
let list = text.nextElementSibling;
console.log(list);
// => <ul name="list" class="lesson__list">...</ul>

// Думаю, объяснять, что и где произошло - излишество. Не так ли? :)
// Вкратце - мы получили в переменную text некий элемент по селектору класса,
// а класс у него "lesson__text". Впрочем, оно и не важно - далее мы получаем
// в уже другую переменную list СЛЕДУЮЩИЙ элемент, то есть соседний по отноше-
// нию к "lesson__text". В нашем случае это список с классом "lesson_list", и
// именно его мы и получили в переменную и затем вывели его (элемент) в консоль.
// Это доказывает тот факт, что мы можем применять все, любые свойства навигации
// к элементам, найденным с помощью методов поиска!

// Изменение документа

// Отлично, мы научились передвигаться по дереву DOM, даже находить и получать
// произвольные объекты, НО всё это работает только "для чтения"! а мы же хотим
// не только получать то, что уже есть, но и изменять а также создавать свой
// собственный HTML-код прямо из JS! в этом нам помогут следующие СПЕЦИАЛЬНЫЕ
// методы, как раз таки созданные для этих целей (разве не круто?):
// A.S: у меня в этот момент аж дрожь по телу пробежала от волнения :D

// Изменение документа: содержимое элемента - innerHTML

// И так, начнем с получения и изменения СОДЕРЖИМОГО элемента с помощью свойства
// innerHTML. Узнать про то, как он работает, мы можем на практике:

// Первым делом мы получаем объект
let textElement = document.querySelector('.lesson__text');

// А затем получаем содержимое объекта "как есть" вместе с HTML
let textElementContent = textElement.innerHTML;
console.log(textElementContent, "- контент, содержащийся в объекте 'lesson__text'");
// => "Текст, причем очень важный текст - текстище!"

// Сразу приступаю к объяснению: получаем в переменную textElement некий объект
// с классом "lesson__text", в нем также есть некое содержимое. Дальше, в перем.
// textElementContent мы получаем СОДЕРЖИМОЕ этого объекта следующим образом:
// первым делом мы прописываем название той переменной, которая содержит в себе
// объект с классом "lesson__text", у нас эта перем. называется textElement. А
// дальше мы ставим точку и прописываем свойство innerHTML. Таким образом мы по-
// -лучим содержимое КАК ЕСТЬ, вместе с HTML-тегами (если они там содержатся), а
// дальше мы просто выводим полученную перем. в консоль, всё максимально просто.
// Это всё конечно хорошо, но мы ОПЯТЬ что-то получаем и не изменяем ничего! так
// вот - сейчас мы это исправим!

textElement.innerHTML = 'Ладно, сейчас это не такой уж и <span class="yellow">важный</span> текст.'

// Что мы сделали? при помощи свойства innerHTML мы просто-напросто изменили
// содержимое нашего элемента, что находится в переменной "textElement". Чтобы
// проверить, действительно ли что-то поменялось на странице или нет, достаточно
// просто перезагрузить её - изменения на лицо! но следует отметить, что перем.
// textElementContent своё "оригинальное" содержимое НЕ изменила (возможно это
// потому, что qS возвращает СТАТИЧНУЮ коллекцию). Это позволяет нам не полностью 
// изменять содержимое, а "дописывать" новое.

// "Дописывать содержимое" значит добавлять какой-то контент к уже имеющемуся.
// Сделать это можно при помощи обратных кавычек, например:

textElement.innerHTML =
	`${textElementContent} <p>Но кто знает, может быть этот текст
	уже и не такой уж и <span class="yellow">важный</span>?</p>`;

console.log(textElement.innerHTML, "- результат после добавления контента (на странице его нет)")

// Сейчас мы именно ДОБАВИЛИ контент, а не изменили его полностью. Мы сделали
// так, чтобы у textElement вернулся его изначальный контент (делается это ещё
// в самом начале: `${textElementContent} ...`), а затем добавили параграф и
// внутри него некий текст. А всё благодаря тому, что мы ещё до всего этого
// сохранили в переменную textElementContent дефолтную, изначальную информацию.
// Далее мы выводим в консоль текущий контент элемента и сверяем его с преды-
// -дущим - разница есть, хоть и не совсем огромная. И становится понятно, что
// с JavaScript'ом у нас открываются ОГРОМНЫЕ возможности для манипуляций со
// страничкой, ведь то, что мы сделали - лишь капля в море. Идем дальше!

// Изменение документа: outerHTML

// Метод outerHTML получает элемент ЦЕЛИКОМ. Отличия от innerHTML небольшие, я
// бы даже сказал что их и нету: кроме получения содержимого объекта, мы полу-
// -чаем и САМ объект. Легче понять на примере:

// P.S - , но я сразу вам скажу: все манипуляции с outerHTML я закомментировал,
// так как после того, как мы меняем страницу через outerHTML верунть всё обратно
// НЕВОЗМОЖНО, или это только я не смог всё вернуть. В любом случае - если захо-
// -тите, то уберете комментарии, но потом обязательно закомментируйте обратно,
// иначе будет/может произойти путаница.
// P.S.S - я всё таки решил убрать тот добавленный контент :D

// Возвращаем прежний вид страницы, убрав добавленный контент
textElement.innerHTML = textElementContent;

// Получаем содержимое объекта "как есть" вместе с HTML, а также сам элемент
// textElementContent = textElement.outerHTML;
// console.log(textElementContent);
// => <div class="lesson__text">...</div>

// На этот раз в консоль мы получили САМ элемент, включая его содержимое - это
// div с классом "lesson__text", а внутри него текст со span'ом. А здесь уже
// разница на глаз - если через innerHTML мы получали лишь "внутренности" этого
// объекта, то с outerHTML мы получаем уже сам объект, его "оболочку". Но и на
// этом интересности не кончаются - есть еще одна очень интересная особенность!
// Давайте попробуем изменить документ через outerHTML:

// textElement.outerHTML = `<p>Эх... этот текст уже не <span class="yellow">важный</span> :(</p>`;

// Мы обратились к элементу, написали .outerHTML и записали туда абсолютно новый
// объект, вместо div'а с классом "lesson__text". В результате мы получили уже
// полностью измененный документ, хоть и в файле "index.html" ничего не изме-
// -нилось. Однако, разницу можно увидеть через DTools - мы увидим, что на стра-
// -нице ИСЧЕЗ этот div и его заменил тег p. Но что если мы захотим получить
// outerHTML данного объекта?

// console.log(textElement.outerHTML);
// => <div class="lesson__text">...</div>

// В таком случае мы получим старую, оригинальную запись. Ну, идем дальше!

// Изменение документа: просто текст элемента - textContent

// Следующие свойство для изменения документа называется просто, его название по-
// -хоже на название одной из наших переменных - textContent. Это свойство по-
// -хоже на предыдущие, но имеет одно принципиальное отличие. Рассмотрим на при-
// -мере, так будет легче:

textElement = document.querySelector(".lesson__text");
textElementContent = textElement.textContent;
console.log(textElementContent);
// => "Текст, причем очень важный текст - текстище!"

// Здесь ничего интересного: заменяем значение переменной textElement на то же
// самое (чтобы не вспоминать, какое значение было у textElement), а переменной
// textElementContent даем след. значение: "текстовый контент элемента, который
// находится в переменной textElement". То есть этой переменной мы задали самый
// обычный текстовый контент в качестве значения, а далее мы вывели его в кон-
// -соль, там нам выдало простейший текст, без тегов. Но почему без тегов? ответ
// очень прост - это свойство показывает нам исключительно ТЕКСТОВЫЙ контент,
// но его особенность в другом...

// В чем же? узнаем чуть позже!)