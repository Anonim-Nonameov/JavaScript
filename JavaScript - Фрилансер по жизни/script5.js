// Поиск прозивольного элемента: продолжение

// В прошлый раз мы остановились на том, что создали две переменные, которые
// хранят в себе две коллекции: живую и статичную, и мы проверили в чем же их
// разница. Последнее предложение в старом файле было таковым: "А говорил я о
// том, что статичная коллекция содержит ту информацию, которая была получена
// на момент использования этого метода, а мы создали этот элемент ПОСЛЕ его
// использования!". С этого то я и продолжу - после того как мы создали пере-
// менную со статичной коллекции, она собрала в себе все элементы с неким клас-
// сом, НО на этом всё - эта коллекция ни на какие изменения в DOM реагировать
// никак не будет. Живая коллекция наоборот, всегда содержит в себе только
// самую "свежую" информацию. А мы идем дальше!

// querySelectorAll VS другие методы

// На практике, чаще всего используется querySelectorAll, так как мы в него
// можем указать абсолютно любой CSS-селектор. Другие методы поиска юзаются (то
// есть используются) только тогда, когда нам нужны их уникальные возможности,
// например получение одного объекта, или получение живой коллекции. И Жека
// специально для нас составил табличку элементов, где показано, что умеет и
// что делает каждый изученный нами метод поиска. Я же взял и перенес её сюда:


/*

Метод поиска           | Ищет по...           | Возвращает...       |  Ищет внутри элемента/Живая коллекция?
------------------------------------------------------------------------------------------------------------
QuerySelector          | Любому CSS-селектору | Один объект         |   Да - Нет (статичная)
------------------------------------------------------------------------------------------------------------
QuerySelectorAll       | Любому CSS-селектору | Коллекция объектов  |   Да - Нет (статичная)
------------------------------------------------------------------------------------------------------------
getElementById         | ID   				  | Один объект     	|   Нет - Нет (статичная)
------------------------------------------------------------------------------------------------------------
getElementsByTagName   | Тегу или *  		  | Коллекцию объектов  |   Да - Да
------------------------------------------------------------------------------------------------------------
getElementsByClassName | Имени класса		  | Коллекцию объектов  |   Да - Да
------------------------------------------------------------------------------------------------------------
getElementsByName      | Атрибуту name  	  | Коллекцию объектов  |   Нет - Да
------------------------------------------------------------------------------------------------------------

*/

// Ух.. во это я заморочился конечно! на этой таблице представлены все изучен-
// ные нами методы, а также то что они возвращают. Кроме того, на ней показано,
// ищут ли они внутри каких-либо элементов или нет, а еще то, какую коллекцию
// они возвращают (живую или же статичную).

// Метод поиска closest

// Рассмотрим еще один метод поиска - closest! этот метод ищет ближайшего предка,
// который соответствует указанному CSS - селектору. Причем сам элемент также
// включается в поиск, принмимает в нем участие. А я напомню, что предки элемента
// это родитель, родитель родителя, его родитель и так далее. Вместе они образуют
// некое дерево, некую цепочку иерархии от элемента до вершины. Другими словами,
// метод closest поднимается вверх по этому дереву, пока не найдет родителя, кото-
// рый соответствует CSS - селектору. Метод возвращает либо найденного родителя,
// либо null, если такой элемент не найден.

// И еще одно напоминание: parentElement возвращает НЕПОСРЕДСТВЕННОГО родителя
// элемента, в то время как closest ищет поднимаясь вверх по иерархии.
// А теперь пример использования:

let elem = document.querySelector('.lesson__sub-list-item');
let parentList = elem.closest('.lesson__list');
console.log(parentList);

// Первым делом мы получаем в переменную первый (так как qS возвращает именно
// первый элемент, который соот. указ. селектору) элемент под-списка, затем мы
// сохраняем в переменную элемент ".lesson__list" через метод closest, и в конце
// выводим его в консоль. Всё получилось! но осталось добавить, что метод closest
// очень и очень полезен, и он часто испольуется для проверки на существование
// того или иного родителя, либо для изменения родителя конкретного элемента.

// Метод проверки matches

// Сейчас мы изучим следующий метод поиска - matches. На самом деле это даже не
// метод поиска - это метод проверки. Он скорее проверяет, удовлетворяет ли эле-
// мент CSS - селектору и возвращает true или false в зависимости от результата.
// На примере будет намного легче понять, как он работает! -

let elems = document.querySelectorAll('.lesson__list-item');

for (let elem of elems) {
	if (elem.matches('[class$="lesson__list-item_red"]')) {
		console.log("Красный")
	} else if (elem.matches('[class$="lesson__list-item_blue"]')) {
		console.log("Синий")
	}
}

// Готово! теперь объясняю: сначала мы получаем коллекцию ВСЕХ элементов с клас-
// сом .lesson__list-item в переменную elems, далее с помощью цикла for ... of
// мы перебираем найденные коллекции и при помощи условного ветвления проверяем,
// используя matches, есть ли у элемента атрибут class с таким-то классом и спец.
// модификатором (см. методология БЭМ) red. Если есть - выводим в консоль слово
// "Красный", если же ничего не нашлось, то мы при помощи else if и matches ищем
// элемент с атрибутом class с таким-то классом и спец. модификатором blue. Если
// он есть, выводим в консоль слово "Синий". Всё просто! то есть мы через цикл
// for ... of буквально перебираем (как документики) элементы с таким-то классом,
// а дальше мы ищем те элементы, у которых есть класс с опред. модификатором, и в
// зависимости от полученного бул. значения выводим в консоль какое-то слово.

// Осталось еще добавить, что получив объект тем или иным способом, мы можем
// применять свойства навигации о которых говорили ранее. Например - то самое
// свойство nextElementSibling:

let text = document.querySelector('.lesson__text');
let list = text.nextElementSibling;
console.log(list);
// => <ul name="list" class="lesson__list">...</ul>

// Думаю, объяснять, что и где произошло - излишество. Не так ли? :)
// Вкратце - мы получили в переменную text некий элемент по селектору класса,
// а класс у него "lesson__text". Впрочем, оно и не важно - далее мы получаем
// в уже другую переменную list СЛЕДУЮЩИЙ элемент, то есть соседний по отноше-
// нию к "lesson__text". В нашем случае это список с классом "lesson_list", и
// именно его мы и получили в переменную и затем вывели его (элемент) в консоль.
// Это доказывает тот факт, что мы можем применять все, любые свойства навигации
// к элементам, найденным с помощью методов поиска!

// Изменение документа

// Отлично, мы научились передвигаться по дереву DOM, даже находить и получать
// произвольные объекты, НО всё это работает только "для чтения"! а мы же хотим
// не только получать то, что уже есть, но и изменять а также создавать свой
// собственный HTML-код прямо из JS! в этом нам помогут следующие СПЕЦИАЛЬНЫЕ
// методы, как раз таки созданные для этих целей (разве не круто?):
// A.S: у меня в этот момент аж дрожь по телу пробежала от волнения :D

// Изменение документа: содержимое элемента - innerHTML

// И так, начнем с получения и изменения СОДЕРЖИМОГО элемента с помощью свойства
// innerHTML. Узнать про то, как он работает, мы можем на практике:

// Первым делом мы получаем объект
let textElement = document.querySelector('.lesson__text');

// А затем получаем содержимое объекта "как есть" вместе с HTML
let textElementContent = textElement.innerHTML;
console.log(textElementContent, "- контент, содержащийся в объекте 'lesson__text'");
// => "Текст, причем очень важный текст - текстище!"

// Сразу приступаю к объяснению: получаем в переменную textElement некий объект
// с классом "lesson__text", в нем также есть некое содержимое. Дальше, в перем.
// textElementContent мы получаем СОДЕРЖИМОЕ этого объекта следующим образом:
// первым делом мы прописываем название той переменной, которая содержит в себе
// объект с классом "lesson__text", у нас эта перем. называется textElement. А
// дальше мы ставим точку и прописываем свойство innerHTML. Таким образом мы по-
// -лучим содержимое КАК ЕСТЬ, вместе с HTML-тегами (если они там содержатся), а
// дальше мы просто выводим полученную перем. в консоль, всё максимально просто.
// Это всё конечно хорошо, но мы ОПЯТЬ что-то получаем и не изменяем ничего! так
// вот - сейчас мы это исправим!

textElement.innerHTML = 'Ладно, сейчас это не такой уж и <span class="yellow">важный</span> текст.'

// Что мы сделали? при помощи свойства innerHTML мы просто-напросто изменили
// содержимое нашего элемента, что находится в переменной "textElement". Чтобы
// проверить, действительно ли что-то поменялось на странице или нет, достаточно
// просто перезагрузить её - изменения на лицо! но следует отметить, что перем.
// textElementContent своё "оригинальное" содержимое НЕ изменила (возможно это
// потому, что qS возвращает СТАТИЧНУЮ коллекцию). Это позволяет нам не полностью 
// изменять содержимое, а "дописывать" новое.

// "Дописывать содержимое" значит добавлять какой-то контент к уже имеющемуся.
// Сделать это можно при помощи обратных кавычек, например:

textElement.innerHTML =
	`${textElementContent} <p>Но кто знает, может быть этот текст
	уже и не такой уж и <span class="yellow">важный</span>?</p>`;

console.log(textElement.innerHTML, "- результат после добавления контента (на странице его нет)")

// Сейчас мы именно ДОБАВИЛИ контент, а не изменили его полностью. Мы сделали
// так, чтобы у textElement вернулся его изначальный контент (делается это ещё
// в самом начале: `${textElementContent} ...`), а затем добавили параграф и
// внутри него некий текст. А всё благодаря тому, что мы ещё до всего этого
// сохранили в переменную textElementContent дефолтную, изначальную информацию.
// Далее мы выводим в консоль текущий контент элемента и сверяем его с преды-
// -дущим - разница есть, хоть и не совсем огромная. И становится понятно, что
// с JavaScript'ом у нас открываются ОГРОМНЫЕ возможности для манипуляций со
// страничкой, ведь то, что мы сделали - лишь капля в море. Идем дальше!

// Изменение документа: outerHTML

// Метод outerHTML получает элемент ЦЕЛИКОМ. Отличия от innerHTML небольшие, я
// бы даже сказал что их и нету: кроме получения содержимого объекта, мы полу-
// -чаем и САМ объект. Легче понять на примере:

// P.S - , но я сразу вам скажу: все манипуляции с outerHTML я закомментировал,
// так как после того, как мы меняем страницу через outerHTML верунть всё обратно
// НЕВОЗМОЖНО, или это только я не смог всё вернуть. В любом случае - если захо-
// -тите, то уберете комментарии, но потом обязательно закомментируйте обратно,
// иначе будет/может произойти путаница.
// P.S.S - я всё таки решил убрать тот добавленный контент :D

// Возвращаем прежний вид страницы, убрав добавленный контент
textElement.innerHTML = textElementContent;

// Получаем содержимое объекта "как есть" вместе с HTML, а также сам элемент
// textElementContent = textElement.outerHTML;
// console.log(textElementContent);
// => <div class="lesson__text">...</div>

// На этот раз в консоль мы получили САМ элемент, включая его содержимое - это
// div с классом "lesson__text", а внутри него текст со span'ом. А здесь уже
// разница на глаз - если через innerHTML мы получали лишь "внутренности" этого
// объекта, то с outerHTML мы получаем уже сам объект, его "оболочку". Но и на
// этом интересности не кончаются - есть еще одна очень интересная особенность!
// Давайте попробуем изменить документ через outerHTML:

// textElement.outerHTML = `<p>Эх... этот текст уже не <span class="yellow">важный</span> :(</p>`;

// Мы обратились к элементу, написали .outerHTML и записали туда абсолютно новый
// объект, вместо div'а с классом "lesson__text". В результате мы получили уже
// полностью измененный документ, хоть и в файле "index.html" ничего не изме-
// -нилось. Однако, разницу можно увидеть через DTools - мы увидим, что на стра-
// -нице ИСЧЕЗ этот div и его заменил тег p. Но что если мы захотим получить
// outerHTML данного объекта?

// console.log(textElement.outerHTML);
// => <div class="lesson__text">...</div>

// В таком случае мы получим старую, оригинальную запись. Ну, идем дальше!

// Изменение документа: просто текст элемента - textContent

// Следующие свойство для изменения документа называется просто, его название по-
// -хоже на название одной из наших переменных - textContent. Это свойство по-
// -хоже на предыдущие, но имеет одно принципиальное отличие. Рассмотрим на при-
// -мере, так будет легче:

let textElement2 = document.querySelector(".lesson__text");
let textElementContent2 = textElement2.textContent;
console.log(textElementContent);
// => "Текст, причем очень важный текст - текстище!"

// Здесь ничего интересного: создаем переменную textElement, присваиваем её в
// качестве значения элемент с классом "lesson__text", далее создаём переменную
// textElementContent2 и даем ей след. значение: "текстовый контент элемента,
// который находится в переменной textElement2". То есть этой переменной мы за-
// -дали самый обычный текстовый контент в качестве значения, а далее мы вывели
// его в консоль, там нам выдало простейший текст, без тегов. Но почему без те-
// -гов? ответ очень прост - это свойство показывает нам исключительно ТЕКСТОВЫЙ
// контент, но его особенность в другом - с ним нельзя добавлять HTML-код на
// страницу:

textElement2.textContent = `Ладно, сейчас это не такой уж и <span class="yellow">важный</span> текст.`;

console.log(textElement2.textContent);
// => "Ладно, сейчас это не такой уж и <span class="yellow">важный</span> текст."

// Как не трудно заметить, все теги преобразовались в простую строку, а не в
// какой нибудь HTML-код. Это и есть основная особенность этого свойства - с ним
// мы можем получить текст или просто его изменить, но HTML с его помощью нам
// не добавить. Это полезная возможность textContent'а  - записывать текст "безо-
// -пасным способом", если мы не хотим чтобы на сайте появился произвольный какой
// нибудь HTML-код. textContent - один из способов защититься от этого.

// Изменение документа: data

// В случае, если мы хотим поработать не с элементом (HTML-тегом), а с неким
// другим узлом - текстовым либо комментарием, мы можем воспользоваться свойст-
// -вом data. Он возвращает или содержимое текстового узла либо комментарий.
// Посмотрим на него в примере и вернем вид страницы на прежний:

// Возвращаю прежний вид страницы
textElement.innerHTML = textElementContent;

let textElement3 = document.querySelector('.lesson__text');
let getComment = textElement.nextSibling;
console.log(getComment);
// => <!-- А я комментарий, а мне норм :D -->

// В примере выше мы создали переменную textElement3 и сохранили в неё элемент
// с классом "lesson__text", далее мы создали переменную getComment и сохранили
// в неё следующий узел, который идет после элемента с классом "Lesson__text".
// Выведя в консоль этот узел мы видим, что это простой комментарий, идущий
// сразу после закрывающего div'а, который относится к элементу "lesson__text",
// то есть очень важно, чтобы после него ничего не стояло - ни текста, ни пробела
// или еще чего нибудь такого, что могло бы сохраниться в переменную вместо этого
// комментария. Ведь мы помним, что enter это ТОЖЕ узел и текст это ТОЖЕ узел.
// Так вот, чтобы получить сам ТЕКСТ комментария, то есть его содержимое, нам
// необходимо просто использовать свойство data:

console.log(getComment.data);
// => "А я комментарий, а мне норм :D"

// Смотрим в консоль - текст комментария, всё получилось! но это еще не всё...
// Мы можем ИЗМЕНИТЬ наш комментарий или любой другой текстовый узел! -

getComment.data = "Я как бы комментарий, но мне уже не норм..."
console.log(getComment.data);
// => "Я как бы комментарий, но мне уже не норм..."

// Здесь ничего разжевывать не нужно - берем узел, что находится внутри перем.
// getComment, ставим точку и прописываем свойство, пишем оператор присваивания
// и через пробел новую строку. Далее выводим результат в консоль и видим, что
// текст комментария изменился! а чтобы в этом полностью убедиться, достаточно
// посмотреть на комментарий через DTools - там комментарий также изменился.
// А теперь переходим к самому интересному!

// Изменение документа: создание элементов и узлов

// Наконец-то, спустя столько времени мы научимся создавать элементы и узлы в
// самом JS-файле! сделать это можно одним из нескольких методов, один из которых
// это метод createElement. Посмотрим на него сразу же в примере:

let newElement = document.createElement('div');
console.log(newElement);
// => <div></div>

// Итак, первым делом мы создаем переменную newElement и ставлю знак равно, т.е
// оператора присваивания. Далее я пишу слово document, ставлю точку и прописываю
// название метода, затем ставлю круглые скобки и уже внутри них я пишу название
// того тега, который хочу создать - в нашем случае это простейший div. Ну а в
// конце я просто вывожу его в консоль и вижу.. ВИЖУ, ЧТО У НАС РОДИЛСЯ НОВЫЙ
// ЭЛЕМЕНТ - DIV! отлично, а теперь наполним этот новорожденный div контентом,
// сделаем мы это через уже знакомое нам свойство innerHTML:

newElement.innerHTML = `Я не такой уж и <span class="yellow">важный</span> текст, но
	порох еще есть!`;
console.log(newElement);
// => <div>...</div>

// Ну вот, теперь наш div наполнен своим собственным контентом! круто, не так ли?
// А теперь мы создадим новый текстовый УЗЕЛ! для этого мы используем метод
// createTextNode, который создает текстовые узлы. В круглых скобках необходимо
// передавать исключительно ТЕКСТ (логично, да?):

let newTextNode = document.createTextNode("Допустим, что это текст :]");
console.log(newTextNode);
// => "Допустим, что это текст :]"

// Ну вот, текствый узел тоже был создан! то есть, как вы (читатель) поняли,
// создавать элементы и узлы таким образом просто, но есть один нюанс - все эти
// созданные нами элементы находятся внутри переменных, их нет в документе! так
// как же нам их туда вставить? об этом мы и поговорим!

// Изменение документа: методы вставки

// Вставить созданный элемент или узел нам помогут методы, которые были созданы
// разработчиками JavaScript'а специально для этих целей. Итак, первый метод
// называется before! из названия становится ясно, что он вставляет элемент или
// узел ПЕРЕД объектом. Ну а вообще он работает так же, как и одноимённое CSS
// свойство before, которое вставляет контент ДО элемента. Посмотрим на него
// в примере, но создавать отдельные элементы мы не будем - мы их уже создали
// и они хранятся в своих переменных, единственное что я с ними сделаю, то я
// просто-напросто перезапишу элемент с классом "lesson__text", который находится
// в переменной textElement, для наглядности и для того, чтобы не возникало ника-
// -ких путаниц, по типу "а что в этом элементе находится? / был ли он изменен?".
// Применять этот метод мы будем именно на textElement, т.к нам надо вставить
// новый элемент ДО какого нибудь другого. И другие методы, о которых мы поговорим
// позже, будут точно так же применяться к этому элементу. А пока что смотрим:

textElement = document.querySelector('.lesson__text');
// textElement.before(newElement);

// Готово, чтобы увидеть результат достаточно зайти в браузер - у нас появился
// супер-важный текст до нашего уже существующего! мы в 1-ый раз смогли не только
// создать элемент, но и вставить его не страницу, и это круто. Но нам этом мы
// останавливаться не будем - идем дальше, к следующему крутому методу вставки!

// Следующий метод называется after, и работает он также как и метод before и
// свойство before, но действует он наоборот - он вставляет текст ПОСЛЕ элемента.
// В общем, он максимально похож на CSS свойство after, которое точно таким же
// образом вставляет контент после какого нибудь элемента. Ну, погнали смотреть:

// textElement.after(newElement);

// Отлично, наш элемент появился непосредственно ПОСЛЕ уже существующего. И я
// прошу вас заметить - наш элемент уже больше не стоит ДО того, который уже
// был! почему так произошло я не знаю, ведь я не комментировал код на 356 стр.,
// но оно, наверное, к лучшему. И мы опять же идем дальше - следующий метод!

// А следующим методом у нас является prepend. Он действует несколько иначе,
// нежели предыдущие методы вставки - он добавляет элемент ВНУТРЬ уже заранее
// созданного. То есть, мы как-бы "вкладываем" наш элемент в другой. Но помимо
// всего этого, этот метод добавляет элемент В НАЧАЛО объекта. Представьте, что
// мы применили данный метод к какому нибудь диву, в котором есть множество дру-
// -гих элементов. Представили? молодцы! ну а теперь представьте, что мы добавляем
// наш элемент ПЕРВЕЕ всех остальных. Если в этом диве хранится 10 других дивов,
// то наш элемент будет первым, и только после него пойдут все остальные. Ну вот,
// теперь смотрим на метод в деле:

// textElement.prepend(newElement);

// Превосходно, теперь наш элемент находится ВНУТРИ другого элемента и появился
// он ДО исходного текста, что не может не радовать - мы хоть что-то сделали!
// И чтобы проверить, добавился ли наш текст, мы можем воспользоваться DTools:
// заходим во вкладку "элементы" и ищем див с классом "lesson__text", открываем
// его (кнопка в виде треугольника слева от тега <div>) и смотрим внутрь.. ну,
// а там у нас действительно наш тег и другой, исходный! Замечательно, теперь
// мы опять идем дальше - следующий и заключительный метод вставки!

// Последним методом для вставки элементов является метод append. Принцип действия
// у него максимально простецкий - он вставляет передаваемый ему в виде аргумента
// элемент, ВНУТРЬ уже существующего, добавляя его в самый конец (после всех уже
// существующих дочерних элементов). Вкратце, он делает то же самое, что и преды-
// -дущий метод, но действует по другому. Если прошлый метод брал и добавлял эле-
// -мент внутрь и перед остальными, то этот берет и добавляет элемент внутрь и
// ПОСЛЕ других. Посмотрим на то, как он работает, на примере:

// textElement.append(newElement);

// Ну вот, гАтово. Проверяем через DTools - div, что находится внутри переменной
// newElement появился точно внутри div'а, который в свою очередь находится в
// переменной textElement. И это не всё - он появился ПОСЛЕ основного контента,
// и это самое главное. Вот вам "карточка", которая показывает, где появится
// добавляемый элемент с разными методами вставки:

/*

		- before()

 <ul class="lesson__list">
		- prepend()
  <li>Пункт №1</li>
  <li>Пункт №2</li>
  <li>Пункт №3</li>
		- append()
</ul>
		- after()

*/

// Элемент с классом lesson__list наш объект. А на самом примере чётко показано,
// где появится добавляемый элемент используя тот или иной метод вставки. Если
// же говорить "по-человечески", то всё примерно так: используя метод before, мы
// добавляем элемент ДО уже существующего. Используя метод prepend, мы добавляем
// наш элемент ВНУТРЬ уже существующего и ДО того контента, что уже там находится.
// Используя метод append, мы добавляем элемент ВНУТРЬ и ПОСЛЕ того контента, что
// уже там находится. А вот метод after делает то же самое, что и before, но
// добавляет наш элемент ПОСЛЕ уже существующего. Ну вот, идём дальше!

// P.S: я закомментирую всё то, что мы делали раньше, а именно - участки кода,
// где мы тестировали изученные методы. Всё это потому, что мне не нравится,
// что на странице будет какой-то лишний текст и я не смогу его убрать оттуда.

// Любым из этих методов вставки мы можем добавлять НЕСКОЛЬКО фрагментов сразу,
// например вот так:

// textElement.append(newElement, "Ну допустим, что это тоже текст.");

// Как не трудно заметить, вставился не только сам элемент, но и дополнительный
// текст, который мы "отправили" вместе с ним. Кроме того - необязательно же
// добавлять только элементы! можно и строку добавить, при желании:

// P.S: код на 442-ой строке тоже был закомментирован, ибо мешает.

// textElement.append(`Крутой текст, <span class="yellow">очень</span>
// 	крутой текст. Важный и крутой текст`);

// Зайдя в браузер первое, что мы увидим - текст, а после него - еще один текст!
// но во втором явно что-то не так. Например тот span, который мы с вами добавили
// отобразился как простой текст! это всё потому, что эти методы вставляют наши
// текста БЕЗОПАСНЫМ способом, то есть как свойство textContent. Это свойство
// добавляет на сайт лишь ТЕКСТ, но никак не HTML-теги, об этом нам с вами уже
// очень хорошо известно. В такие моменты, когда ситуация заставляет нас брать
// и создавать какие-то отдельные переменные для элементов, потом их заполнять,
// потом выбирать куда отправить.. ух. Ну короче, в такие моменты нам может
// помочь один специальный метод, о котором мы и будем говорить дальше.

// Встречайте - insertAdjacentHTML/Text/Element.

// Это мощный и универсальный метод для вставки HTML-кода, текста или элемента
// на страницу. Мы будем рассматривать его на примере, заранее закомментировав
// старый код (на 450-451 строках) - мешает:

// textElement.insertAdjacentHTML (
// 	"afterend",
// 	`<p>Нет, это Я самый <span class="yellow">важный</span> текст на странице!</p>`
// );

// Что мы сделали в коде выше? всё просто - применили к элементу, что находится
// в переменной textElement метод insertAdjacentHTML, раскрыв скобки. После этого
// мы (уже внутри метода) прописали строку "afterend", это первый параметр, кото-
// -рый добавляется в метод. Он означает, что наш HTML-код будет добавлен непо-
// -средственно ПОСЛЕ textElement'а. После этого, уже в абсолютно другой строке
// мы написали сам HTML-код, который и должен будет добавиться на страницу - это
// второй параметр, добавляемый в метод. После срабатывания этого метода, контент
// добавляется на сайт - после textElement добавлен созданный НАМИ код! но у нас
// есть возможность выбора относительно того места, куда будет добавлен наш HTML:

// (A.S: все эти параметры были проверены на роботоспособность лично мною)
// "beforebegin" - вставляет HTML непосредственно ПЕРЕД textElement.
// "afterbegin" - вставляет HTML в НАЧАЛО textElement.
// "beforeend" - вставляет HTML в КОНЕЦ textElement.
// "afterend" - вставляет HTML непосредственно ПОСЛЕ textElement.

// Зайдя в браузер и открыв Chrome DevTools (вкладка "Элементы"), будет не трудно
// заметить, что наш HTML-код был добавлен на страницу. И самое главное, что HTML
// был добавлен как HTML, а текст был добавлен как строка! если бы мы сделали то
// же самое через textContent, то даже теги бы перенеслись на страницу как текст.
// Но выше, на 462 строке я написал следующее: "insertAdjacentHTML/Text/Element",
// и это значит, что помимо insertAdjacentHTML есть еще два метода, конец которых
// заканчивается либо на Text, либо на Element (логично :-D). Первый добавляет
// простой текст на страницу:

// textElement.insertAdjacentText(
// 	"beforebegin",
// 	"К сожалению, я уже давным-давно не важный текст..."
// );

// Второй добавляет заранее созданый элемент на страницу:

// textElement.insertAdjacentElement(
// 	"beforeend",
// 	newElement
// )

// Зайдя в браузер мы увидим, что текст был добавлен ДО нашего textElement'а,
// а вот элемент был добавлен в конец textElement'а. Но на практике, чаще всего
// используется метод insertAdjacentHTML, по одной простой причине: вы хотите
// просто добавить текст на сайт? есть методы before, append, prepend и after!
// о, нет. вы хотите добавить элемент на сайт? используйте всё те же методы!
// Вкратце и без шутки, то всё действительно так - в JavaScript'е были и есть
// уже созданные методы для вставки текста и элементов, а для текста вообще был
// придуман textContent.. правда, методы before/after/append/prepend могут не
// только элементы, но и текст добавлять, поэтому даже textContent отлетает.
// В силу этих причин и используется insertAdjacentHTML, универсальный метод.

// А теперь, как по традиции, закрепим изученное на простом коде, где элемент
// с классом lesson__list наш объект, а использоваться будет старый добрый метод
// insertAdjacentHTML/Text/Element:

/*

		- beforebegin

 <ul class="lesson__list">
		- afterbegin
  <li>Пункт №1</li>
  <li>Пункт №2</li>
  <li>Пункт №3</li>
		- beforeend
</ul>
		- afterend

*/

// Повторяю: параметр beforebegin добавляет HTML/Текст/Элемент ДО объекта; па-
// -раметр afterbegin добавляет HTML/Текст/Элемент в НАЧАЛО объекта; параметр
// beforeend добавляет HTML/Текст/Элемент в КОНЕЦ объекта; параметр afterend
// добавляет HTML/Текст/Элемент ПОСЛЕ объекта. Всё, идем дальше!

// Изменение документа: перенос элемента

// Мы продвигаемся дальше и всё же стоит отметить, что мы можем вставлять не
// только узлы, но и переносить существующие. Делать это можно при помощи самых
// обычных методов вставки, по типу append, prepend и прочих. "Но почему?" - воз-
// -никает резонный вопрос. Ответ на него один: все методы вставки АВТОМАТИЧЕСКИ
// удаляют узлы со старых мест. Посмотрим на примере, заранее закомментировав ВСЁ
// то, что мы делали до этого, по одной простой причине - мешает:

// let lessonBlock = document.querySelector('.lesson');
// let title = document.querySelector('h3');

// Итак, мы создали две переменные - lessonBlock и title. Первая сохранит в себя
// весь div с классом lesson (это что-то вроде контейнера на странице), а вторая
// сохранит тег h3 с надписью "Урок №13" соответсвенно. Дальше, мы просто берем
// и добавляем ВНУТРЬ элемента, что находится в коробке lessonBlock и уже ПОСЛЕ
// существующего контента элемент h3, который находится в уже другой коробке,
// коробке title:

// lessonBlock.append(title);

// Отлично! таким образом, мы ПЕРЕНЕСЛИ тег h3 внутрь и в конец div'а с классом
// lesson. Что же касается прошлого узла, то он удалился - в ином случае, у нас
// на странице было бы целых два тега h3 с надписью "Урок №13" :)

// Изменение документа: копирование узлов

// Что, если мы хотим не перенести элемент, а КОПИРОВАТЬ его? в таком случае,
// нам поможет метод cloneNode, который позволяет нам его скопировать в любое
// желаемое место. Взглянем на пример, закомментировав предыдущий код:

let textElement4 = document.querySelector('.lesson__text');
let lessonBlock = document.querySelector('.lesson')
let cloneTextElement = textElement.cloneNode();

lessonBlock.append(cloneTextElement)

// Применили метод, смотрим в браузер: ..ничего. И в правду - ничего! но почему?
// На самом деле, зайдя в DTools мы увидим, что элемент ПОЯВИЛСЯ внутри и в конце
// тега div с классом "lesson", но тогда почему он скопировался туда без своего же
// содержимого? ответ прост - всё зависит от настроек метода cloneNode(). Если мы
// внутри круглых скобок пропишем слово "true", тогда произойдет ГЛУБОКОЕ копиро-
// -вание, которое мало того, что скопирует элемент, так еще и его содержимое:

cloneTextElement = textElement.cloneNode(true);
lessonBlock.append(cloneTextElement);

// Зайдя в браузер мы сразу же увидим наш элемент с классом "lesson__text" как в
// самом начале блока div с классом "lesson", так и в его конце. На этот раз, у
// нас получилась ПОЛАНЯ копия элемента textElement. Шедеврально! идём дальше :)

// Изменение документа: удаление узлов

// Часто бывает так, что создали мы элемент, добавили его на страницу, а удалить
// его у нас ну никак не получается, вот просто никак! нам постоянно приходится
// комментировать те куски кода, в которых мы создаем элемент, наполняем его и
// затем уже добавляем это дитё на страницу. В такие моменты жизни нам может по-
// -мочь (и поможет!) метод remove(). Если говорить вкрацте, то да - он просто
// возьмет и удалит элемент со страницы, хоть в дереве DOM он и останется:

cloneTextElement.remove();

// Вот и всё, элемент стёрт с лица зем.. кхе, со страницы. Идём дальше, идём!

// Стили и классы

// Отлично, мы научились изменять наш HTML-код "на лету" из нашего JS файла,
// но что нам делать, когда речь пойдет о CSS-стилях и классах элементов?
// сейчас мы с вами научимся менять стили элемента, включая классы из JS файла
// также легко, как мы с вами меняем HTML-код!

// Стили и классы: управление классами - className & classList

// className

// Начнем мы с управления классами и сразу стоит отметить, что в JavaScript'е
// изменение классов - это одно из наиболее применяемых и используемых действий.
// Для управления классами используются два свойства - className и classList, а
// начнём мы с className. Разберём его на примере:

let element = document.querySelector('.lesson__list-item_what');
let elementClassNames = element.className;

console.log(elementClassNames);
// => lesson__list-item lesson__list-item_what

// В консоли по итогу мы получаем два класса этого элемента, которые были записаны
// у него в HTML-документе. Замечательно, мы получили имена классов элемента, но
// как нам их изменить? делается это максимально просто, точно также, как мы с
// вами меняли текст элемента через метод textContent:

element.className = "fool";

// Мы просто обратились к элементу, лежащему внутри переменной element и изменили
// список его классов на какой-то определенный, на "fool" (с англ. - дурачок).
// На самом деле, это является большой проблемой данного свойства, а именно тут
// проблемой является то, что перезаписываются ВСЕ классы элемента, при этом появ-
// -ляется другой, заданный нами. Конечно, мы можем брать предыдущую переменную,
// прибавлять к ней строку какую-нибудь (в смысле, добавлять еще один класс), да,
// но зачем всё это, когда у нас есть свойство classList? :)

// classList

// Начнем с того, что свойство classList является специальным ОБЪЕКТОМ, имеющий
// различные методы для добавления или удаления одного конкретного класса. Каждый
// такой метод мы разберем на примерах! первый метод используется именно для ДО-
// -БАВЛЕНИЯ класса к элементу, называется он просто - add. Использовать мы будем
// ту же переменную element, перед этим заменив её текущий класс на предыдущий:

// A.S: Прописывая это свойство к элементу, мы получаем ПОЛНЫЙ доступ к атрибуту
// class элемента и полный контроль над ним.

// Меняем класс на старый

element.className = "lesson__list-item lesson__list-item_what";

// Метод add - добавление класса

element.classList.add("active");

// Зайдя в браузер, а именно в Developer Tools, мы можем убедиться, что к элементу
// добавился новый класс - active! Но заметьте, что при добавлении класса к эле-
// -менту, его старые не удалились. Это огромный плюс, ведь нам не придется пере-
// -записывать классы обратно (при необходимости)! но тут вы спросите: "хорошо,
// добавлять классы научились, а как их потом удалить?"; а я вам отвечу, что это
// делается также легко, как мы их добавляем. Делается это при помощи метода,
// который и служит для удаления класса, называется он remove:

// Метод remove - удаление класса

element.classList.remove("active");

// Опять заходим в бразуер и смотрим в DevTools: класс active удалён. И опять же
// я прошу вас заметить, что старые, уже существующие классы не были тронуты этим
// методом. Ну вот, добавлять и удалять классы мы научились, это просто чудесно!
// Но я прошу вас вспомнить про модальные окна на сайтах, поп-апы и меню-бургеры:
// в каждом отдельном случае, на сайтах требуется нажать на какую-то кнопку и
// только после этого открывается мод. окно/поп-ап/меню-бургер. Обычно, при реали-
// -зации таких вещей в основном исползуются классы - когда у элемента есть класс
// active, он есть на странице, если же его нет - он скрыт. Из этого в первую оче-
// -редь вытекает, что обычно эти вещи уже ЕСТЬ на странице, а во вторых выходит
// так, что к ним уже подготовлены определенные стили, которые срабатывают в тот
// момент, когда у элемента есть определенный класс. Например, у элемента по умол.
// у свойства display стоит значение none, а при active оно меняется на block.
// Тут может появится вопрос: "как сделать так, чтобы при клике по элементу у него
// то появлялся один класс, то удалялся?"; ответ на него достаточно прост - в этом
// нам помогут "обработчики событий", о которых мы поговорим позже, и следующий
// метод свойства classList - toggle! его работа заключается в том, что он берёт
// и добавляет к элементу класс только в том случае, если его нет. Если он уже
// есть, то действует наоборот - его удаляет:

element.classList.toggle("active");

// Заходим в DTools и видим, что к элементу добавился наш класс. Так как у нас
// его не было, метод toggle решил именно ДОБАВИТЬ элементу этот класс, в ином
// случае, если бы у нас БЫЛ этот класс, то он бы действовал наоборот - удалил
// бы его. Чудесно, добавлять и удалять классы мы научились, но как проверить
// не заходя в код/DTools, есть ли у элемента такой-то класс? делается это
// максимально просто: для таких целей был предусмотрен метод contains, который
// возвращает нам два булевых значения - true & false в зависимости от того,
// есть ли класс или нет (если есть - true, если нет - false). Чтобы проверить,
// действительно ли есть у элемента класс или нет, мы должны использовать команду
// console.log, дабы вывести результат в консоль. Но помимо простого console.log
// мы можем использовать условное ветвление и если у элемента есть такой класс,
// мы можем выполнять какие-то действия:

// Метод contains - проверка элемента на наличие определенного класса

if (element.classList.contains("active")) {
	console.log("У element есть класс active!");
} else {
	console.log("У element нет класса active!")
}

// => "У element есть класс active!" / "У element нет класса active!"

// Готово! код выше проверяет, есть ли у элемента в переменной element класс
// active, если он есть, то в круглые скобки у if передается true и код внутри
// фигурных скобок срабатывает. Внутри фигурных скобок у нас простая команда
// console.log, через которую мы выводим в консоль надпись "У element есть класс
// active!". Если же у элемента НЕТ класса active, в if передается false и уже
// срабатывает else, а вот в фигурных скобках у else мы выводим другую надпись в
// консоль, "У element нет класса active!" - всё просто!

// Помимо всего прочего, свойство classList является перебираемым. Это означает,
// что мы можем перечислить все классы элемента при помощи for...of. Делается
// это следующим образом:

for (let className of element.classList) {
	console.log(className);
}

// => lesson__list-item
// => lesson__list-item_what
// => active

// Прекрасно, зайдя в консоль мы увидим целый список (ага, конечно, СПИСОК)
// из существующих классов элемента!

// Стили и классы: управление стилями - elem.style

// Итак, с управлением классами разобрались, теперь движемся к стилям! первое,
// что мы изучим для управления CSS-стилями - свойство style. Оно не только
// помогает нам в управлении стилями, нет.. оно даёт нам полный контроль над
// атрибутом style у элемента! (ну, фактически). Посмотрим на пример:

element = document.querySelector(".lesson__list-item_red span");

// Задаем стили с помощью CSS свойства:
element.style.color = "pink";

// Готово! теперь заходим в браузер и смотрим: наш шестой элемент, который до
// выполнения кода был красным, стал розовым.

// elem.style - большие свойства

// Это всё хорошо, но также следует омтетить, что CSS-свойства, названия которых
// состоят из нескольких слов, например margin-bottom, следует записывать в стиле
// CamelCase, а точнее в его другом формате, lowerCamelCase. Тут, первая буква в
// слове - строчная (мелкая), а в другом слове - большая, например: javaScript.
// Применим к нашему элементу свойства, у которых в названии больше одного слова:
// P.S: я задам ему свойство display: inline-block, чтобы другое применилось

// Меняем значение свойства display с block на inline-block, чтобы всё применилось
element.style.display = "inline-block";

// margin-bottom
element.style.marginBottom = "50px";

// text-transform
element.style.textTransform = "uppercase";

// Прекрасно, вновь смотрим в браузер: наш "красный" элемент отобразился в.. ну,
// ПРОПИСНОМ формате, а еще оттолкнул самый последний элемент на 50 пикселей.
// На самом деле тут нет ничего сложного, просто надо знать, что те свойства,
// у которых в названии много слов, надо записывать в стиле lowerCamelCase и..
// в общем-то, всё. Также следует отметить, что каждое свойство надо писать
// на новой строке, то есть писать свойства надо отдельно.
// И кстати, прошу вас на этом моменте остановиться и зайти в браузере на DevTools,
// а именно - во вкладу "Элементы". Там вы должны найти тот самый шестой элемент
// из списка, к которому мы и применяли все эти стили. Посмотрите-ка на него
// повнимательнее, видите? у этого элемента появился один ОГРОМНЫЙ атрибут style,
// в котором как раз и собраны все стилевые свойства.

// elem.style - получение значения свойства

// Кроме изменения свойств и написания их в других форматах, мы можем ещё и
// получить значение свойства. Но здесь есть одно ключевое условие: получить
// значение какого-нибудь стилевого свойства можно только в том случае, если
// оно было записано в атрибуте style у элемента. То есть - если у свойства,
// например, margin-bottom есть какое-то значение и мы хотим его получить,
// но его нет в атрибуте style, то ничего не выйдет. А теперь к сути - чтобы
// получить значение свойства, нам надо просто использовать логирование или
// присваивание в переменную. Как это происходит? вы создаёте переменную, а
// затем просто присваиваете ей следующее: elem.style.свойство, без назначения
// какого-либо значения. А вот в случае с логированием, то есть с console.log,
// мы делаем то же самое, но без переменной. Посмотрим на пример с логированием:

console.log(element.style.marginBottom);
// => 50px

// Таким образом, в консоли у нас появляется следующая запись: "50px".
// Но, если бы у атрибута style не было бы таких стилевых свойств, то мы бы не 
// смогли получить в консоли это значение. Но как нам удалить все эти стилевые
// свойства, если нам это понадобится?..

// elem.style - сброс стилей

// Если нам вдруг понадобилось взять и стереть все те стили, которые мы взяли
// и поприсваивали, то мы можем использовать одно свойст.. кхе, нет, то есть
// мет.. тьфу, нет! никаких свойств и методов. Но вы можете меня спросить - "а
// как же тогда удалить стили у элемента?", и я вам отвечу, что можно просто
// взять и сделать ТАК:

element.style.marginBottom = "";

// Тут даже нечего объяснять. Мы просто взяли и присвоили такому-то CSS-свойству..
// пустые кавычки. Если вкратце - это означает, что мы берем и сбрасываем стили
// конкретного свойства у элемента. Теперь можно взять и сбросить ВСЕ стили,
// которые мы написали к нашему элементу:

element.style.display = "";
element.style.color = "";
element.style.textTransform = "";

// Готово! теперь наш старый элемент вернулся. Но есть одно но (как обычно и
// бывает) - у элемента остался атрибут style. Это можно взять и проверить, зайдя
// в DevTools. Нет, он никак не мешает, он там совершенно пустой, это я так,
// чтобы вы знали :)

// Стили и классы: управление стилями - elem.style.cssText

// Как говорилось выше, при использовании свойства style каждое CSS-свойство
// необходимо писать отдельно, на новой строке. Это крайне неудобно, да и к тому
// же сильно засоряет наш код, однако у этой проблемы есть своё универсальное
// решение - свойство cssText! оно позволяет нам записать сразу множество стилей
// для одного элемента. Посмотрим на пример:

element.style.cssText = `
	display: inline-block;
	text-transform: uppercase;
	color: pink;
	margin: 30px 0 30px 0;
`;

// Итак, сейчас объясню, что и где произошло: мы обращаемся к атрибуту style
// элемента element, применяя к нему свойство cssText. Затем, через свойство
// cssText мы берём и "заполняем" наш атрибут style определенными свойствами:
// display, color и прочее-прочее, в итоге все стили применяются к объекту, ну
// или по другому - к объекту. Минус такого подхода заключается в том, что он
// перезаписывает абсолютно ВСЕ стили, записанные в атрибуте style до применения
// свойства cssText.

// elem.style.cssText - сброс стилей

// При использовании свойства cssText стили сбрасываются точно также, как и в
// случае со свойством style - нам достаточно просто применить оператор присвоения
// и присвоить свойству пустые кавычки, не важно какие, главное кавычки:

element.style.cssText = ""; // '', `` 

// Готово! залетаем в браузер и видим, что стили у элемента обнулились.

// Стили и классы: управление стилями - getComputedStyle

// Итак, чуть выше я уже рассказывал о том, что иногда бывает так, что нам нужно,
// ОЧЕНЬ нужно получить значение стилей какого-то конкретного элемента. В этом не
// простом деле нам очень поможет метод getComputedStyle. Но перед тем как мы с
// вами начнем его рассматривать я отмечу, что уже ранее говорил о том, что мы
// можем получить значение того или иного CSS-свойства, обратившись через него же
// (то есть через CSS-свойство) к свойству style определенного элемента:

console.log(element.style.fontSize);
// => "" (ничего мы не получим в консоль, свойства font-size в style нету)

// Да, так можно делать и никто нам не запрещает этого, но здесь тоже есть свой
// ОГРОМНЫЙ минус - мы получим значение CSS-свойства только в том случае, если
// оно есть в атрибуте style элемента. То есть, что это значит? если, например,
// свойства padding-top НЕТ в атрибуте style у какого нибудь элемента, а мы хотим
// его получить, то мы ничего не получим, поскольку его там просто-напросто нет.
// Именно по этой причине, код выше выдал нам в консоли пустую строку, потому
// что в атрибуте style нет такого стилевого свойства.

// Так вот, к чему я всё это - метод getComputedStyle может помочь нам решить
// эту проблему. Этот метод просто берёт и...

// Что он делает? узнаем позже!) 